<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS3渐变(Gradients)]]></title>
    <url>%2F2019%2F08%2F06%2FCSS3%E6%B8%90%E5%8F%98(Gradients)%2F</url>
    <content type="text"><![CDATA[CSS3 渐变可以让你在两个或多个指定的颜色之间显示平稳的过渡，它有两种渐变分别为线性渐变和径向渐变 CSS3 定义了两种类型的渐变： 线性渐变（Linear Gradients）：向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）： 由它们的中心定义 浏览器支持： 属性 浏览器类别 IE浏览器 谷歌浏览器 火狐浏览器 linear-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- radial-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- repeating-linear-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- repeating-radial-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- 1. 线性渐变(linear gradients)​ 为了创建一个线性渐变，必须至少定义两种颜色结点(颜色结点即想要呈现平稳过渡的颜色)。同时，也可以设置一个起点和一个方向（或一个角度）。 线性渐变-从上到下（默认情况下）： 123456789div&#123; width:450px; height: 300px; background: linear-gradient(#03a9f4, #f71ab95e); /* 标准的语法 */ /* 以下三种均是为了适应浏览器而写，因为我用的是Google浏览器，所以下面只举适应谷歌浏览器的例子 */ background: -webkit-linear-gradient(#03a9f4, #f71ab95e); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(#03a9f4, #f71ab95e); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(#03a9f4, #f71ab95e); /* Firefox 3.6 - 15 */&#125; 线性渐变-从左到右： 123456div&#123; width: 450px; height: 300px; background: linear-gradient(left, #03a9f4, #f71ab95e);/* 标准写法，谷歌浏览器不兼容 */ background: -webkit-linear-gradient(left, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-对角：可以通过指定水平和垂直的起始位置来制作一个对角渐变 123456div&#123; width: 450px; height: 300px; background: linear-gradient(left top, #03a9f4, #f71ab95e);/* 标准写法，谷歌浏览器不兼容 */ background: -webkit-linear-gradient(left top, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-自定义角度：如果想要在渐变的方向上做更多的控制，可以自定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right等等） 注意：很多浏览器(Chrome,Safari,fiefox等)使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度 123456div&#123; width: 450px; height: 300px; background: linear-gradient(150deg, #03a9f4, #f71ab95e);/* 标准写法 */ background: -webkit-linear-gradient(150deg, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-使用多个颜色结点： 123456div&#123; width: 450px; height: 300px; background: linear-gradient(pink,#03a9f4, #f71ab95e);/* 标准语法 */ background: -webkit-linear-gradient(pink,#03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 使用透明度（transparent）：CSS3 渐变也支持透明度，可用于创建减弱变淡的效果。为了添加透明度，我们使用 rgba()函数来定义颜色结点。rgba()函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。 123456div&#123; width: 450px; height: 300px; background: linear-gradient(right,rgba(247,26,185,0.37 ),rgba(3,169,244,0.8));/* 标准语法 */ background: -webkit-linear-gradient(right,rgba(247,26,185,0.37 ),rgba(3,169,244,0.8));/* 谷歌浏览器 */&#125; 重复的线性渐变：repeating-linear-gradient() 函数用于重复线性渐变 12345div&#123; width: 450px; height: 300px; background: -webkit-repeating-linear-gradient(#03a9f4 30%, #f71ab95e 70%);/* 谷歌浏览器 */&#125; 2. 径向渐变(radial-gradient)​ 径向渐变(radial-gradient)由它的中心定义。必须至少定义两种颜色结点(颜色结点即你想要呈现平稳过渡的颜色)。同时，也可以指定渐变的中心、形状（圆形或椭圆形）、大小(closest-side：最近；farthest-corner：最远)。 默认情况下，渐变的中心是 center，渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落） 默认情况下： 12345div&#123; width:150px; height: 150px; background: -webkit-radial-gradient(#03a9f4 30%, #f71ab95e 70%);&#125; 设置径向渐变的大小以及形状：shape 参数定义了形状，它可以是值 circle（圆形）或 ellipse（椭圆形）。默认值是ellipse 123456789div&#123; width: 150px; height: 150px; background: radial-gradient(circle, #03a9f4, #f71ab95e);/*我试了一下，在谷歌浏览器里如果设置形状就没办法显示*/ /* 其他浏览器 */ background: -webkit-radial-gradient(circle, closest-side,#03a9f4,#f71ab95e); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(circle,closest-side,#03a9f4,#f71ab95e); /* Opera 11.1 - 12.0 */ background:-moz-radial-gradient(circle, closest-side,#03a9f4,#f71ab95e); /* Firefox 3.6 - 15 */&#125; size 参数定义了渐变的大小。它可以是以下四个值： closest-side：径向渐变的半径长度为从圆心到离圆心最近的边 farthest-side：径向渐变的半径长度为从圆心到离圆心最远的边 closest-corner：径向渐变的半径长度为从圆心到离圆心最近的角 farthest-corner：径向渐变的半径长度为从圆心到离圆心最远的角 12345div&#123; width:450px; height: 300px; background: radial-gradient(60% 55%, closest-side,#03a9f4,#f71ab95e); /* 标准的语法 */ background: -webkit-radial-gradient(40% 55%, closest-side,#03a9f4,#f71ab95e); /* 谷歌浏览器 */ 重复的径向渐变：repeating-radial-gradient()函数用于重复径向渐变 效果像一朵花一样很好看~ 123456div&#123; width:450px; height: 300px; background: repeating-radial-gradient(#03a9f4 40%,#f71ab95e 60%); /* 标准的语法 */ background: -webkit-repeating-radial-gradient(#03a9f4 40%,#f71ab95e 60%);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和css知识点]]></title>
    <url>%2F2019%2F08%2F01%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[HTML部分知识点总结 块元素（将内容分块显示）：特立独行，不在一行中显示 eg：h1,h2,…,h6,p,blockquote . 块元素在内容前后分别有一个默认的换行内联元素（显示在所在的段落中）：随波逐流 eg：q,a,em link：利用外部样式表为本页面增加样式（不再需要style） eg：新建一个lounge.css文件1&lt;link type="test/css" rel="stylesheet" href="lounge.css"&gt; em ：斜体；strong：加粗；b：加粗（强调文本）1&lt;em&gt;我是一个斜体标签&lt;/em&gt; q：短引用（段落中的引用）；blockquote：长引用（引用独立的文字） 12&lt;q&gt;千里之行，始于足下&lt;\q&gt;&lt;blockquote&gt;我是一个长引用&lt;/blockquote&gt; br：换行 code：显示计算机程序代码 li：列表元素；ol：有序列表；ul：无序列表（不与p标签写在一起，都是块元素）123456&lt;ol&gt; &lt;li&gt;Walla, WA&lt;/li&gt; &lt;li&gt;Magic city, ID&lt;/li&gt; &lt;li&gt;Bountiful, UT&lt;/li&gt; &lt;li&gt;Last chance, CO&lt;/li&gt;&lt;/ol&gt; StarBuzzCoffee.com是域名（范围大）；www.StarBuzzCoffee.com是网站名（范围小） 链接页面的方式：a.相对路径：只能链接同一网站的页面 b.URL：通常用来链接其他网站 为链接增加标题以便访问：a herf=”” title=”” 当鼠标移到链接上，停留一秒，就可以看到这个工具提示1Read the &lt;a href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt;. 使用id属性为超链接a创建目标 用id链接到元素：要链接到页面中的一个特定目标，只需在链接最后加一个#，再加上目标标志符1&lt;a href="index.html#chai"&gt;See Chai Tea&lt;/a&gt; 使用target打开新窗口 1&lt;a target="_blank" href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt; 调整图像大小：width和heightsrc：引入和替代 href：引用和链接 alt：当图片无法识别时的提示 title：鼠标点击图片时的提示 target=”_black”：在新窗口打开新页面 target=”_self”：在原来的窗口打开页面 1&lt;img src="../images/red.jpg" alt="" width="200" height="200"&gt; W3C验证工具：http://validator.w3.org 绝对路径：相对于计算机的路径 相对路径：一般使用 背景定位常用指令：水平方向Left center right；垂直方向top center bottom css知识点汇总注：在CSS中，不需要给元素两边加尖括号&lt;&gt;，所有元素都叫做选择器 把css放入html：在head元素中增加开始和结束style标记，css规则要放在style里 margin-left, margin-right：左右外边距，占页面的20% 12margin-left: 20%;margin-right: 20%; border：定义页面主体周围的边框 虚线：dotted，实线：solid，颜色为黑色 1border: 2px dotted black; padding：在页面主体周围创建一些内边距 1padding:10px 10px 10px 10px; font-family：定义文本使用的字体1font-family: sans-serif; color：设置文字颜色1color:red; border-bottom：加下划线 eg：在h1标题下加下划线123h1&#123; border-bottom: 1px solid black; &#125; 盒子模型=内容+内填充+外边距+边框]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Operation Of Hexo]]></title>
    <url>%2F2019%2F08%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment The Step Of Upload12345$ hexo s$ hexo clean$ hexo g$ hexo s$ hexo d]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js字符串和数组方法]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串方法 前面我们学习了字符串，用字面量方式声明一个字符串： 123var str = ' nihao';str.length; //获取字符串的长度str.charAt(2); 获取传入下标序号处的字符(ES5中可以用str[2]) 注意：如果不传默认值为”0”，当传入的下标超出字符串长度时返回”null” 字符串其他方法： 123456789101112str.charCodeAt(2); //获取传入下标序号处的字符的Unicode 编码值，如果不传值默认值为"0"String.fromCharCode(); //传入Unicode编码值返回对应的字符，可以传多个编码，用','分割str.indexOf(); //获取()中字符在字符串中从左向右第一次出现的下标str.lastIndexOf(); //获取()中字符在字符串中从右向左第一次出现的下标//上面两个方法可以传多个连续的字符，未找到返回-1，第二个可选参数为开始位置的下标(负数和不写默认是从0/最后开始)str.substring(); //截取两个参数之间的字符串，传入的两个参数会自动检测大小，按照从小到大的顺序截取，不写和负数默认从0开始str.slice(); //同上，但不会自动检测参数大小，参数为负数时从后向前计算(最后一个字符为-1，依次向前-2，-3...)//被截取的字符串包含第一个参数位置的字符，不包括第二个参数位置的字符，如果只有一个参数则是从第一个参数截取到字符串结尾str.toUpperCase(); //把字符串的字母字符转换成大写str.toLowerCase(); //把字符串的字母字符转换成小写str.split('.'); //用参数的字符将字符串分割成数组，第二个可选参数限制生成数组的长度(超出的部分会被舍去)//不传参会返回只有一个数据(该字符串)的数组；分割每个字符需要传一个空字符串''；分隔符在左右也会在数组(开头/结尾)生成空字符 数组方法 数组的声明方式 12var arr = [1,2,3]; //字面量写法，推荐这种写法var arr = new Array(1,2,3); //构造函数实例化写法 构造函数实例写法在参数只有一个且是数字它会理解为长度，是字符串它会理解为内容，所以用推荐第一种写法 如果定义后的数组重新定义长度，那么数组会变成新的长度，多余的数据舍去，增多的数据为空(字符串length重新设置不会改变长度)： 123arr.length = 2; //[1,2]arr.length = 0; //快速清空一个数组arr[3] = 4; //[1,2, ,4]; 数组其他方法： 123456789101112131415161718192021arr.join(''); //用参数的字符把数组里的内容连成字符串，split的反义词arr.push(); //向数组后添加数据arr.unshift(); //向数组前添加数据//添加方法返回值为新数组的长度arr.pop(); //从数组后删除数据arr.shift(); //从数组前删除数据//删除方法返回值为被删除的数据arr.splice(); //数组的删除、替换和添加方法，根据参数作用不同arr.splice(a,b); //删除：a为删除的起点位置，b为删除数据的数量，只有删除的时候会有返回值(既被删除的数据，但是装在数组里)arr.splice(a,b,c,...n); //替换：a为替换的起点位置，b为删除数据的数量，c及c后面的所有参数为替换后的新数据arr.splice(a,0,c,...n); //添加：a为添加的起点位置，0为不删除数据，c及c后面的所有参数为添加的新数据arr.sort(); //排序：按照数据字符串的Unicode 编码大小把内容按照顺序进行排列，不能直接排数字。arr.sort(function(a,b)&#123; //用高阶函数排序数字 return a-b/b-a; //正序/反序&#125;)arr.sort(function(a,b)&#123; //乱序排列数字 return Math.random()-0.5; //随机得到正负值 &#125;)arr.reverse(); //倒序，将数组反向排列var newArr = arr.concat(arr1,arr2...); //将arr1、arr2...拼接在arr后面，结果为新数组arr.indexOf(); //同字符串的indexOf，找出参数在数组中从左向右第一次的出现的下标 练习： 1. 判断输入框内容是否都为数字(用Unicode) 12 2. 加密和解密：让一段字符串在两个p标签里显示加密后的乱码和还原回来的字符串 12 3. 找到字符串’同学们在新学期里有新学期的样子，并开始了新学期的学习’中每个’学期’的位置和出现的次数。 12 4. 使一段文字在点击按钮时变成20个字符+’……’，再次点击按钮后展开还原，按钮也要在”展开”和”收缩”来回切换 12 5. 设置几个颜色（红、黄、蓝、绿、黑），在输入框中输入文字，点击按钮后在p标签中生成背景颜色不同的文字 12 6. 做一个点击查找一段字符（将所需查找的字段显示为高亮）和替换一段字符（将被替换的字段显示为高亮）的效果 12 7. 每点击一次就将[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]的最后一位放到第一位，如：[&#39;5&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;] 12 8. 数组去重（去掉数组的重复数据）如：将var arr =[1,2,2,2,2,3,3,4,4,4,2,3] 变成[1,2,3,4] 12 9. 把数组[&#39;345px&#39;,&#39;23px&#39;,&#39;10px&#39;,&#39;1000px&#39;]按照数据数字的从大到小的顺序排列 12 10. 把一个字符串var str = &quot;abcdef&quot;变成倒序 12 11. 随机生成7个1~50之间不重复的整数，并存在一个数组中 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js计时器和动画]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E8%AE%A1%E6%97%B6%E5%99%A8%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[获取元素样式 元素.style.width获取的样式是元素的行间样式(不管该样式是否有效)，若样式时通过选择器写成内部或外链样式时就无法获取了 计算元素有效的样式的代码： 12getComputedStyle(元素).width; //标准浏览器元素.currentStyle.width; //IE8及以下浏览器 处理浏览器兼容后封装代码： 1234function getStyle(obj,attr)&#123; return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr]; &#125;getStyle(元素,'样式名'); //调用，获得我们需要元素的样式 注意的问题： 获取的样式是带有单位的(100px)，需配合parseInt或者parseFloat方法获得数字结果 不能获取像background这种复合样式，只能用backgroundColor等非复合样式分别获取 由于是计算的结果，获取的颜色格式不同(如red和rgb(255,0,0)都是红色)，因此结果不能用做判断，可以用做赋值 传参的字符串里面不能出现空格，否则变成未定义 未设置的样式不要获取，有的浏览器会将未设置的样式值设置为auto，导致结果出现错误 例~按钮控制div元素移动 ​ JS部分： 123456789var oDiv = document.getElementsByTagName("div")[0];var oBtn = document.getElementsByTagName("button")[0];function getStyle(obj,attr)&#123; return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr]; &#125;oBtn.onclick = function ()&#123; oDiv.style.left = parseFloat(getStyle(oDiv,"left"))+10+"px"; oDiv.style.top = parseFloat(getStyle(oDiv,"top"))+10+"px";&#125; ​ HTML部分： 12&lt;div&gt;&lt;/div&gt;&lt;button&gt;移动&lt;/button&gt; ​ CSS部分： 123456789div&#123; width: 150px; height: 150px; border-radius: 50%; background-color: red; position: absolute; left: 0; top: 100px;&#125; 计时器 循环计时器：每隔传入的毫秒时间执行一次传入的函数 对比循环：不同点——循环计时器带有时间概念，而循环的所有重复执行的代码是瞬间完成的，没有时间概念；相同点——它们都在重复执行代码 语法：setInterval(函数,毫秒);例如： 12345var i = 0;setInterval(function ()&#123; //这里可以是函数名(有名函数)，也可以是匿名函数 document.title = i; i++;&#125;,1000); 注意：计时器是我们学习的第三种函数调用的方法；计时器时间一般写20ms或以上，太短浏览器可能反应不过来，导致速度比预想的要慢 停止循环计时器的方法：clearInterval()，用法是先创建一个接受计时器返回值的变量timer，在需要停止计时器的地方使用clearInterval()并传入变量timer就可以了，例如： 12345678var i =0;var timer = setInterval(function ()&#123; //计时器的返回值就是一个序号 document.title = i; i++; if(i===10)&#123; clearInterval(timer); //停止对应序号的计时器 &#125;&#125;,1000); 注意：多次开启计时器时，若每次开启前没有关闭之前的计时器会导致我们timer里保存的是最后一个计时器的返回值，从而只能关闭最后一个计时器，解决方法就是每次调用时先关闭之前的计时器(尤其计时器是由用户控制的时候) 延时计时器：延时传入的毫秒时间执行一次传入的函数 语法：setTimeout(函数,毫秒); 循环计时器和延时计时器都要等一段时间后才执行第一次代码，若需要立即调用一次则需要在页面刷新后直接调用一次函数 对应的延时计时器的清除方法：clearTimeout(timer); 用clearTimeout()停止延时计时器后，若延时计时器的函数还未调用，那么函数便不会被执行了 延时计时器配合递归可以做出和循环计时器一样的效果，并且比循环计时器拥有更好的性能 面试题~ 管理和封装计时器 封装一个doMove函数，用来做动画效果 用计时器移动元素时需要注意： 判断终点位置时不能用==，若总长不能整除步长会停不下来；如果用&gt;=虽然会停下来，但不能直接赋值，该限制应该在赋值之前，否则在视觉上有个超过终点后的后退效果 每次开启计时器时应该注意先清除之前的计时器 timer定义成自定义属性(oDiv.timer)，并在定义时清除一下这个自定义属性，clearInterval可以清除null和未定义，这样做的好处是不靠任何外面的变量，为的是后面的封装 封装的过程我们要分清代码中哪些数据是变化的，并把他们变成参数 事件和计时器调用函数时函数名是不能加()的(因为函数名+()就变成返回值了)，如果需要传参必须将该事件调用改成调用匿名函数，然后在匿名函数里面直接调用该函数的办法 传入的正值和负值对用户来说并不友好，用户还要根据方向来判断需要传入值得正负，我们可以把代码改成判断当前位置和目标点位置来确定 我们在封装时的大量判断代码在方便用户的同时提高用户体验，而且也方便自己后来使用 回调函数：就是一个函数执行完毕后再执行的另外一个函数。在封装的函数内部回调函数不一定有，因此我们一般做一个判断，如果有回调则执行，没有回调则什么都不会发生 练习： 1. 一个img标签，每隔1.5秒自动切换一张图片，并且鼠标移入时让自动切换停止，鼠标离开继续切换（准备四张图片） ​ JS部分： 12345678910111213141516var oImg = document.getElementsByTagName("img")[0]; var arr = ["img/1.png","img/2.png","img/3.png","img/4.png"]; var i=0; var timer = setInterval(function()&#123; oImg.src = arr[i++]; i == arr.length &amp;&amp; (i=0); &#125;,1000) oImg.onmouseover = function ()&#123; clearInterval(timer); &#125; oImg.onmouseout = function ()&#123; timer = setInterval(function()&#123; oImg.src = arr[i++]; i == arr.length &amp;&amp; (i=0); &#125;,1000) &#125; ​ HTML部分： 1&lt;img src="img/1.png" alt="" width="390" height="480"&gt; 2. 页面刷新1.5秒后弹出一个广告，并在右上角加个关闭按钮。要求弹窗展示2秒后自动消失，若在那之前点击了关闭按钮则立即关闭弹窗并停止延时计时器 ​ JS部分： 1234567891011setTimeout(function()&#123; oDiv.style.display = "block"; var timer = setTimeout(hiddenDiv,2000); oSpan.onclick = function () &#123; hiddenDiv(); clearTimeout(timer); &#125;&#125;,1500)function hiddenDiv()&#123; oDiv.style.display = "none";&#125; ​ HTML部分： 123&lt;div&gt; &lt;span&gt;X&lt;/span&gt;&lt;/div&gt; ​ CSS部分： 123456789101112131415161718192021div&#123; width: 300px; height: 200px; background-color: gray; position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125;span&#123; position: absolute; top: 5px; right: 5px; width: 25px; height: 25px; border: 1px red solid; border-radius: 15px; text-align: center; line-height: 25px; cursor: pointer;&#125; 3. QQ显示详细内容效果(显示内容后延迟消失效果)，从展示内容上离开后0.6秒消失 ​ JS部分： 12345678910111213141516aDiv = document.getElementsByTagName("div");var timer = 0;function fn1()&#123; aDiv[0].style.display = "block";&#125;function fn2()&#123; aDiv[0].style.display = "none"; clearTimeout(timer);&#125;aDiv[1].onmouseover = aDiv[0].onmouseover = function ()&#123; clearTimeout(timer); fn1();&#125;aDiv[1].onmouseout = aDiv[0].onmouseout = function ()&#123; timer = setTimeout(fn2,600);&#125; ​ CSS部分： 1234567891011121314151617div:nth-child(1)&#123; width: 200px; height: 200px; background-color: red; position: absolute; top: 0; left: 0; display: none;&#125;div:nth-child(2)&#123; width: 200px; height: 550px; background-color: yellow; position: absolute; top: 0; left: 220px;&#125; ​ HTML部分： 12&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 4. 在页面上布局平铺20个50X50红色的方块，点击我们的浏览器的窗口时让每个方块每隔200毫秒以每30毫秒7像素的速度掉下来一个，直到所有的方块掉到500的位置 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js时间对象和倒计时]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[时间对象 获取当前时间(既计算机读到这句函数时)系统的时间对象 12var myTime = new Date();//objectDate() //直接调用也会返回一个当前时间的字符串(无论传什么参数) 注意：时间对象是对象类型，而获取的时间是数字类型： 12345678910var iYear = myTime.getFullYear(); //获取年var iMonth = myTime.getMonth()+1; //获取月，月份是0-11的数字，需要在结果上+1var iDate = myTime.getDate(); //获取日var iWeek = myTime.getDay(); //获取星期，星期是0-6的数字，需要转换一下显示方式才能用var weeks = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];var sWeek = weeks[iWeek];var iHours = myTime.getHours(); //获取时var iMin = myTime.getMinutes(); //获取分var iSec = myTime.getSeconds(); //获取秒var iMsec = myTime.getMilliseconds(); //获取毫秒 时间对象上还能获取的特殊值string类型，如： 123var sDate = myTime.toLocaleDateString(); //获取年月日(字符串)var sTime = myTime.toLocaleTimeString(); //获取时分秒(字符串)var sAllTime = myTime.toLocaleString(); //获取年月日时分秒(字符串) 但往往上面得到的未必是我们需要的格式，因此一般都是将前面获取的所有数字进行拼接成时间字符串： 1234tFormat(iYear) +'/'+tFormat(iMonth)+'/'+tFormat(iDate)+' '+sWeek+' '+tFormat(iHours)+':'+tFormat(iMin)+':'+tFormat(iSec);function tFormat(n)&#123; return n &lt; 10 ? "0"+n : ""+n; &#125; 注意：通常时间格式使用的数字应该是两位数，因此需要把所有的个位数前面补’0’，我们可以自己封装一个小于10前面加0的函数tFormat 时间戳：是1970日1月1日0时0分0秒到现在的时间的毫秒数，下面三个方法等价： 123new Date().getTime(); new Date().valueOf();Date.now(); //ES5的方法 用途：可以用来判断一段程序运行的时间差，或者每次需要得到一个不同的数字时使用 倒计时 用在团购，抢购等网站，原理是现在的时间点(一直在变)与终点(不会变)两个时间的差就是倒计时(毫秒) 如果在实例化时间对象时给其传参就可以设置一个时间对象，有 如下几种格式： 1234567var iNew = new Date(毫秒数); //将毫秒数的对应时间返回，可以是一个负数，表示1970年1月1日之前的时间。var iNew = new Date('2016-08-01');//假设用户处于格林尼治国际标准时的时区。ES6规定凡是没有指定时区时认为用户处于本地时区。var iNew = new Date(2016,8,1,9,48,12); //数字形式，这里的月也是当前月份-1var iNew = new Date('September 1,2016 9:48:12'); //字符串形式Date.parse('January 26, 2011 13:51:50'); //如果要把一个时间字符串转换成毫秒数需要用Date.parse方法 Date.parse('2011-10-10'); //如果Date.parse解析失败则返回NaNDate.parse('2011-10-10T14:48:00'); 另外一种方式是直接在当前时间对象上设置新时间(该类方法返回的是设置后时间的时间戳)，如： 123456789var iNow = new Date();iNow.setDate(15); //将时间设置为本月15日iNow.setDate(iNow.getDate()+5); //设置日期为当前日期后5天iNow.setFullYear() //设置当前年份(四位数字，月日是可选参数)iNow.setHours() //设置当前小时数(24小时制,0-23)iNow.setMilliseconds() //设置当前毫秒数iNow.setMinutes() //设置当前分钟数iNow.setMonth() //设置当前月份(注意从0开始:0-Jan,1-Feb...)iNow.setSeconds() //设置当前秒数 这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就表示下一年的4月；设置为-2，就表示上一年的11月。 计算时间差，无论用哪种方法设置了未来时间，用未来时间-当前时间就是两者时间差(毫秒)： 123456-- alert( myDate &gt; today ? "今天在2018年9月1日之前" : "今天在2018年9月1日之后" ); //两个时间对象比较大小 var t = (iNew - iNow)/1000; //计算差值，用math.floor向下取整 var iD = Math.floor(t/86400); //毫秒转天 var iH = Math.floor(t%86400/3600); //毫秒转时 var iM = Math.floor(t%3600/60); //毫秒转分 var iS = t%60; //毫秒转秒 练习： 1. 小明情人节给女朋友做了一段js，并定了饭店，可女朋友没有去，请问原因是什么： 1234var oTime = new Date();if (oTime.getMonth() === 2 &amp;&amp; oTime.getDate() === 14) &#123; alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');&#125; 2. 用任意方法设置一个未来时间：今天五天之后，6小时后 1234var oTime = new Date();oTime.setDate(oTime.getDate()+5);oTime.setHours(oTime.getHours()+6);console.log(oTime); 3. 用计时器把当前时间的时分秒每1秒钟在页面的p标签中展示一次时间格式(xx:xx:xx的格式)，做出一个时钟效果，第一秒页面也要展示一次时间 123456789101112var oP = document.getElementsByTagName("p")[0];clock();setInterval(clock,1000);function clock ()&#123; var iTime = new Date(); var iHours = iTime.getHours(); //获取时 var iMin = iTime.getMinutes(); //获取分 var iSec = iTime.getSeconds(); //获取秒 oP.innerHTML = add0(iHours) + ":" + add0(iMin) + ":" + add0(iSec);&#125;function add0(num)&#123; return num&lt;10 ? "0"+ num : "" + num;&#125; 4. 设置一个未来时间，做一个秒杀倒计时，而且显示的所有数字和“:”用图片显示 12 5. 倒计时：距离放假还有::* 123456789101112131415161718var oSpan = document.getElementsByTagName("span")[0]; var oTimeNew = new Date(); oTimeNew.setHours(16); oTimeNew.setMinutes(30); oTimeNew.setSeconds(0); clock(); var timer = setInterval(clock,1000); function clock()&#123; var t = (oTimeNew - new Date())/1000; var iH = Math.floor(t%86400/3600); //毫秒转时 var iM = Math.floor(t%3600/60); //毫秒转分 var iS = t%60; //毫秒转秒 --&gt; oSpan.innerHTML = add0(iH) + ":" + add0(iM) + ":" + add0(iS); t == 0 &amp;&amp; clearIntervaltimer(timer); &#125; function add0(num)&#123; return num&lt;10 ? "0"+ num : "" + num; &#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js特殊函数和运算符]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[自执行(立即执行/自调用)函数 自执行函数语法： 12(function ()&#123;…&#125;)();(function ()&#123;…&#125;()) 这两种自执行函数的写法，在函数体后面加括号就能立即调用，这个函数必须是函数表达式，不能是函数声明 自执行函数可以正常传参，第一个括号是形参的位置，第二个括号是实参的位置；它的内部也是域，变量是局部变量，很多框架里使用自执行函数来防止全局变量的污染；我们也可以用自执行函数将循环for中的i锁定在自执行函数内，我们之前则是使用自定义属性来实现类似的效果的 1234 var a = 10; (function (b)&#123; //var b = a = 10; alert(b); &#125;)(a); 数学函数 Math.floor()：向下取整(下舍去) Math.ceil()：向上取整(上进入) Math.round()：四舍五入 Math.abs()：取绝对值 Math.max()：比较(取大) Math.min()：比较(取小) Math.sin()： 正弦函数(参数为弧度) Math.cos()： 余弦函数(参数为弧度) Math.tan()： 正切函数(参数为弧度) Math.PI： 圆周率(无理数pi) Math.sqrt(x)： x的平方根(开方) Math.pow(x,y)： x的y次方(ES7中用x**y表示) Math.random()：0~1的一个随机数，下面是几个随机整数的公式： 123Math.round(Math.random()) //让结果在0和1随机出现Math.round(Math.random()*a) //让结果在0到a的整数中随机Math.round(Math.random()*(a-b)+b) //让结果在b到a的整数中随机 b大a小 Num.toPrecision(x)： 将Num固定为x位数字(小数多余部分会四舍五入，整数多余部分会用科学计数法后四舍五入) Num.toFixed(x)： 将Num的小数部分取x位有效数字(多余部分会四舍五入，不足部分会补0) 高阶函数和递归函数 函数其实都指向某个变量。函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数： 1234function add(x, y, f)&#123; return f(x) + f(y); &#125; //这里的f相当于函数表达式：var f = Math.absadd(-5, 6, Math.abs); //11 （取绝对值） 所谓的递归函数就是在函数体内调用本函数。使用递归函数一定要注意，处理不当就会进入死循环。递归函数只有在特定的情况下使用 ，比如阶乘问题： 12345678function recursion(num)&#123; if (num&lt;=1)&#123; return 1; &#125; else&#123; return num * recursion(num-1); &#125; &#125; 但我们把函数指针改变并修改原指针时会出错，原因是递归调用的时候原指针已改变了。解决办法是在函数内部调用当前函数用arguments.callee代替函数名，callee属性的初始值就是正被执行的 Function 对象。它是 arguments 对象的一个成员，表示对函数对象本身的引用。 但是访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。因此我们在使用递归的时候还是用函数名的写法，同时避免上面例子的写法就可以了 运算符 算术：+(加)、-(减)、*(乘)、/(除)、%(求余) 三元运算：a ? b : c既if/else特殊写法，等同于if ( a ){ b }else( c ) 赋值：=(将=右边的值赋给左边)、+=(将+=左右两边求和后赋给左边)、-=、*=、/=、%=(后面的如同+=) 判断：&lt;、&gt;、&lt;=、&gt;=、==、!=、===、!==，=== 和 !== 只有在相同类型下,才会比较其值，类型不同直接返回布尔值 逻辑：&amp;&amp;——逻辑”与”操作；||——逻辑”或”操作；!——取反操作 a&amp;&amp;b逻辑”与”定义：从左向右读到false就返回(后面数据不会继续判断)，如所有数据都是ture则返回最后一个(因此都为true时返回的是true) a||b逻辑”或”定义：从左向右读到true就返回(后面数据不会继续判断)，如所有数据都是false则返回最后一个(因此都为false返回的是false) 注意：虽然返回结果是根据布尔值决定的，但js的逻辑运算返回的是数据，而不是布尔值，这与其他编程语言不一样(如PHP返回的就永远是布尔值) 运算优先级：()可以让其内部表达式先执行，如算式或逻辑运算等 练习： 1. 封装一个函数，要求参数传入班级人数n，返回值为随机学号(该学号必须为整数且大于等于1，小于等于总人数n) 12345678function fn1(n)&#123; var b = []; for(var i=0;i&lt;n;i++)&#123; b[i] = Math.round(Math.random()*(1-n)+n); &#125; return b;&#125;console.log(fn1(10)); 2. 菲波那切数列：1、1、2、3、5、8、13、21，写一个函数，参数为数列的位数，弹出值？ 123456789function fibonacci(n)&#123;//var n; if(n==1||n==2)&#123; return 1; &#125; else&#123; return fibonacci(n-2)+fibonacci(n-1); &#125;&#125;console.log(fibonacci(8)); //21 3. 以下逻辑计算后，变量a，b，c的值分别为多少： 1234var a = '' || null || 3 || 4; //3var b = 4 &amp;&amp; 5 &amp;&amp; null &amp;&amp; '0'; //nullvar c = 5 &amp;&amp; false || 4 &amp;&amp; null; //nullvar d = 5 &amp;&amp; (false || 4) &amp;&amp; null; //null 4. 做一个按钮切换新闻的效果，每次显示5条(要求设置一个新闻数组，里面有18条新闻) 123456789101112131415161718192021222324var arr = ["新闻1","新闻2","新闻3","新闻4","新闻5","新闻6","新闻7","新闻8","新闻9","新闻10","新闻11","新闻12","新闻13","新闻14","新闻15","新闻16","新闻17","新闻18"];var oDiv = document.getElementsByTagName("div")[0];var oUl = document.getElementsByTagName("ul")[0];var str = "";var aBtn = oDiv.getElementsByTagName("button");for(var i=0;i&lt;Math.ceil(arr.length/5);i++)&#123; str += "&lt;button&gt;第" + (i+1) + "页&lt;/button&gt;";&#125;oDiv.innerHTML = str;for(var i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].index = i; aBtn[i].onclick = function ()&#123; fn1(this.index); &#125;&#125;function fn1(a)&#123; var str = ""; //创建li并且每次显示5条 for(var i=a*5;i&lt;=a*5+4&amp;&amp;i&lt;arr.length;i++)&#123; str += "&lt;li&gt;" + arr[i] + "&lt;/li&gt;"; &#125; oUl.innerHTML = str; &#125;fn1(0); 5. 分别使用三元运算、数学方法和逻辑运算3个方法完成下面问题：封装一个函数，要求参数n小于100时，返回值为n，参数大于等于100时，返回值为100(n为大于0的整数) 123456789function fn1(n)&#123; //三元运算 return n&lt;100 ? n : 100; //数学方法 return Math.min(n,100); //逻辑运算 return n&lt;100 &amp;&amp; n ||100; return n;&#125; 6. 用js创建22个li元素，背景颜色设置为var arr=[“red”,”black”,”blue”,”yellow”,”green”]中的颜色循环，然后为每个li元素再加上鼠标移入时背景变灰，移开时变回去的效果 ​ JS部分： 123456789101112131415161718var arr=["red","black","blue","yellow","green"];var oUl = document.getElementsByTagName("ul")[0];var aLi = oUl.getElementsByTagName("li");var str = "";for(var i=0;i&lt;22;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].index = i; aLi[i].style.backgroundColor = arr[i%5]; aLi[i].onmouseover = function ()&#123; this.style.backgroundColor = "grey"; &#125; aLi[i].onmouseout = function ()&#123; this.style.backgroundColor = arr[this.index%5]; &#125;&#125; ​ HTML部分： 1&lt;ul&gt;&lt;/ul&gt; ​ CSS部分： 1234567891011 ul&#123; margin: 0; padding: 0; list-style: none;&#125;li&#123; width: 100px; height: 100px; float: left; margin: 0 2px 2px 0;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取作用域的数据和闭包]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E8%8E%B7%E5%8F%96%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 虽然有作用域链让我们在低级域从高级域中拿值，但是两个函数(同级域)或在高级域从低级域拿值却做不到，如： 12345 function fn1()&#123; var a = 'abc'; &#125; //在全局里a找不到fn1();console.log(a); 我们可以用全局变量从低级域中拿值，通过传参到另一个函数内拿值 1234567var b =0;function fn1()&#123; var a = 'abc'; b = a; &#125;fn1();console.log(a); 除此之外还可以用闭包，要理解闭包，首先必须理解js特殊的变量作用域。js语言的特殊之处，就在于通过作用域链函数内部可以直接读取全局变量。另一方面，在函数外部无法读取函数内的局部变量。 用闭包如何从外部读取局部变量，我们可以在函数的内部，再定义一个函数： 12345678function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; f2(); // 999&#125;f1(); f2被包在函数f1内部，f1内的所有局部变量对f2都是可见的。反过来就不行，f2内的局部变量对f1就是不可见了。这就是js特有的”链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量了，如： 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1(); result(); 闭包的概念：上面代码中f2函数被声明在f1函数内(很多书中也管f2叫闭包，其实是一个意思)，就是闭包。 闭包的最大用处有两个： 可以读取函数内部的变量； 让这些变量的值始终保持在内存中，如： 123456789101112131415var nAdd;function f1()&#123; var n=999; nAdd=function()&#123; n+=1; &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); //n=999nAdd();result(); //n=1000 f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1和它的局部变量也始终在内存中，不会在调用结束后，被垃圾回收机制回收 使用闭包的注意点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除(将闭包内部的变量设置为null，让变量失去引用，会被系统自动回收)。 闭包会导致在父函数外部，能够改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Public Method)，把内部变量当作它的私有属性(private value)，一定要小心，不要随便改变父函数内部变量的值。(这些概念会在后面说明) 练习： 查看下面代码，说出结果： 1234567891011121314151617181920var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123;return this.name;&#125;;//this是window &#125;&#125;;alert(object.getNameFunc()()); //the window 直接调用var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; //this是object &#125;; &#125;&#125;;alert(object.getNameFunc()()); //My Object 对象调用]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数的返回值和arguments对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Carguments%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[函数的创建形式 函数声明：使用function关键字声明一个函数，再指定一个函数名。叫做函数声明： 1function fnName () &#123;…&#125;; 函数表达式：使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式： 1var fnName = function ()&#123;…&#125;; 匿名函数：使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式： 1function ()&#123;…&#125;; 匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等 函数声明和函数表达式的执行顺序： 12fnName();function fnName()&#123; ... &#125; 正常，因为预解析’提升’了函数声明的函数，函数可在函数声明之前调用 12fnName();var fnName=function ()&#123; ... &#125; 报错，变量fnName预解析时被初始化为undefined，还未保存对函数的引用，因此函数表达式的函数必须在函数表达式赋值之后调用 函数的返回值 函数内return关键字后面的值就是返回值，用函数名()就可以得到函数的返回值，如： 1234function fn1()&#123; return 100;&#125;alert(fn1()); //弹出100 return关键字后面的值可以是任何数据类型：字符串、数字、布尔值、函数、对象([]/{}/null)、未定义，用typeof(fn1());就可以判断返回值的类型 返回函数时，实际上就是返回了该函数的引用，再加上()就可以调用这个函数了(因此下面fn2()相当于返回值函数的函数名)，如： 123456function fn2()&#123; return function()&#123; alert(1); &#125;&#125;fn2()(); //前面fn2()是fn2的返回值，后面的()代表调用该返回值 注意：这种定义到另一个函数内部的函数并返回其实就是闭包 也可以给上面两个函数分别传参，如： 123456function fn2(a)&#123; return function(b)&#123; alert( a + b ); &#125;&#125;fn2(20)(10); //a和b应该分别对应什么 利用传参和返回值可以封装很多效果，如jq里面的$就是用这种方式来实现的，我们也可以这样累积出来一个js库，反复使用 返回值需要注意的事项： 只有函数代码块里才可以用return，如果一个函数没有return或return后无返回值，则会返回一个未定义 return返回值之后的任何代码都不会执行 arguments（实参的集合） 当函数没有设置形参时，但调用的时候却传了实参，那么实参依然会被传入函数，但是没有形参，于是被保存在了arguments(实参的集合，也是类数组的一种)里，可以对其使用.length、[]等 当函数的参数数量不确定的时候，就非常适合使用arguments arguments.length是函数实参的数量，而函数名的长度(fn1.length)则是形参的数量 arguments与形参同值：当你设置了形参，并改变了该形参的值，那么该形参对应的arguments的值也同时发生变化；反之你修改了arguments的值，那么该值对应的形参也会发生变化 1234567function fn1(a,b)&#123; a = 10; console.log(arguments[0]); //输出10 arguments[1] = 20; console.log(b); //输出20&#125;fn1(1,2); 练习： 1. 封装函数，数字参数n，每次调用时返回一个1到n的数组 12345678function fn1(n)&#123; var arr = []; for(var i=0;i&lt;n;i++)&#123; arr.push(i+1); &#125; return arr;&#125;console.log(fn1(6));//[1,2,3,4,5,6] 2. 封装函数，传两个数字参数a和b，每次调用时返回一个从小到大的数组 1234function fn1(a,b)&#123; return a&lt;b ? [a,b] : [b,a];&#125;console.log("按从小到大排序结果为：" + fn1(-3,-5));//返回[-5,-3] 3. 封装函数，要求：参数的数量任意，简单的加减法计算器，要求：最后一个参数为”+”或”-“，返回第一个参数与后面参数依次加法或者减法的结果 1234567891011121314151617function fn1(a)&#123; var iNum = arguments[1]; switch(a)&#123; case "+": for(var i=2;i&lt;arguments.length;i++)&#123; iNum += arguments[i]; &#125; break; case "-": for(var i=2;i&lt;arguments.length;i++)&#123; iNum -= arguments[i]; &#125; &#125; return iNum; &#125; console.log(fn1("+",3,4,5,6)); console.log(fn1("-",20,6,3));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数的参数和作用域]]></title>
    <url>%2F2019%2F07%2F26%2Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[函数的参数 函数在声明和调用时，有个小括号，这里就是放置参数的地方： 1234function fn1(a)&#123; //相当于在函数的内部 var a alert(a);&#125;; fn1(100); //函数调用的时候为a赋值 a = 100 注意：函数声明时的a叫做形参：形式上的参数，用一个变量代表值的参数，只会出现在函数声明的时候；函数调用里的100叫做实参，给函数实际传递的参数值，只会出现在函数被调用的时候 因为形参相当于变量，因而实参可以存任何数据类型：数字、字符串、布尔值、函数、对象、未定义等；参数可以有多个，参数之间用”,”分割，如： 1234fn1(100,"px"); function fn1(a,b)&#123; alert(a+b); &#125; 函数的封装：由顺序、选择和循环三种基本结构组成，功能相对独立的一个模块，如下，根据参数的类型函数会执行不同的操作 1234567891011121314var m = 100;//数字var n = "num";//字符串var c = function ()&#123;console.log(1);&#125;//函数function fn1(a)&#123; switch(typeof(a))&#123; case 'number': alert(a+20); break; case 'string': alert(a.charAt(2)); break; case 'function': a();//调用函数 default: console.log(a); &#125; &#125;fn1(m);//函数调用fn1(n);fn1(c); 函数的封装的注意事项： 尽量保证HTML代码结构一致(否则很难重用代码) 需要把核心程序实现，再用函数包裹起来 把每组中不同的值找出来，通过传参分别实现效果 运算符号是不能作为参数传递的，只能在函数内部通过判断的方式来分别执行 作用域 域：空间、范围、区域。如：js必须放在script里，css放在style里，它的作用就是(在一个范围内)读和写 浏览器有读js的解析器，当进入script标签后： 第1步–预解析：找到全局的var和function(变量提升)，先检查function函数名和内容并储存，当发现重名时，后面的函数覆盖前面的函数；再检查var的变量储存并初始化值undefind，但是发现重名时会跳过储存(不管重复的是变量名还是函数名) 第2步–逐行读代码：变量被赋值之前的值是初始化时的undefind，直到读到=、+、-、*、/、%、++、–、！等表达式才会获得新值，而读到函数声明时则什么都不会做，直到函数被调用才会执行其内容代码 看一个例子，并分别分析下面代码中的alert(a)都弹出什么： 12345678910111213alert(a); //1、第一次弹出a，再声明变量a 弹出function a()&#123; alert(4); &#125;var a = 1;alert(a); //2、第一次弹出a，再为a赋值 弹出1a = 1;alert(a); //3、多次弹出a，再中间多次声明变量和函数a var a=1;alert(a); //1function a()&#123; alert(2); &#125;alert(a); //1var a = 3;alert(a); //3function a()&#123; alert(4); &#125;alert(a); //3 注意：没有var的写法只存在于面试中，我们写的代码中不允许出现 在script标签里定义的变量是全局变量和函数，若写有两个script标签则是2个域，每个域的解析独立进行：上面script标签输出不了下面script声明的变量；下面script标签可以输出上面script声明的变量 另外一个函数的内部也是一个域，因此函数被调用时也会第一时间开始域解析，函数内部的变量是局部变量，该变量会在函数调用结束时销毁。注意：函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。 作用域链：在一个域内没有找到某变量时，会由里到外，自上到下去更高级的域中去寻找，继续分析下面代码： 12345678910111213141516var a=1; //1、函数内外都声明有a变量function fn1()&#123; alert(a); var a = 2; &#125;fn1();alert(a);var a=1; //2、全局声明a变量，函数未声明a变量function fn1()&#123; alert(a); a = 2; &#125;fn1();alert(a);var a=1; //3、全局声明a变量，函数有a形参function fn1(a)&#123; alert(a); a = 2; &#125; fn1();alert(a);var a=1; //4、全局声明a变量，函数未声明a变量，调用有a实参function fn1()&#123; alert(a); a = 2; &#125;fn1(a);alert(a); 注意：if(){}和for(){}的花括号不是域；匿名函数的{}里是一个域；当js出现错误的时候，如果不是代码写错了，那就是代码的解析机制想错了 练习： 1. 封装一个函数，3个参数（a , b , c），如果参数a的结果为”+”，则输出b和c的和；如果参数a的结果为”-“，则输出b和c的差 1234567function fn1(a,b,c)&#123; switch(a)&#123; case "+": console.log(b+c);break; case "-": console.log(b-c);break; &#125;&#125;fn1("+",5,10); 做一个根据图片数量生成对应数量按钮，并通过点击按钮控制图片的切换，用传参的方式封装函数，要求并在页面中设置两个图片切换，区别1图片数量不同，区别2切换的方式不同(一个hover效果，一个click效果)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-十一、使用Apache部署静态网站]]></title>
    <url>%2F2019%2F07%2F23%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%8D%81%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8Apache%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[十一、使用Apache部署静态网站 web网站服务又称为www服务（world wide web） web服务原理：是一种被动服务，只有接收了互联网中其他计算机发出的请求后才会响应，然后web服务器才会使用HTTP（超文本传输协议）或HTTPS（超文本安全传输协议）将指定文件传送到客户机的浏览器上解析后成为网页 常见的web服务程序 (1) IIS7：Internet information services 7，是Windows系统中默认web服务程序，第一款图形化的网站管理工具 (2) Apache：是一种跨平台的安全性广泛被认可的且拥有快速、可靠、简单的API扩展的web部署软件，是一种常用的web服务软件 (3) Nginx：是一款轻量级的网站服务软件，性能稳定、功能丰富，系统资源占用率低、内存占用少且并发能力强 网站组成 (1) 页面源程序：又称为web页，通过网页编写软件编写的网页源文件，HTML，css，脚本等 (2) 主机空间：用于存放网页源代码并能够将网页内容展示给用户 ​ A. 虚拟主机：在一台服务器中分出一定的磁盘空间供用户放置网站、存放数据等，仅提供基础的网站访问等简单功能，成本较低，节省维护时间，降低运维费用，适用于小型企业 ​ B. VPS：在一台服务器中虚拟出多个“逻辑计算机设备”，每一个用户面对的都是一台“独立”服务器，可以安装操作系统，部署功能服务软件，适用于小型企业 ​ C. 云服务器（ECS）：整合硬件、计算、存储、网络、服务等功能，能够弹性的进行计算服务，使用时同VPS，区别ECS是建立在一个大型计算机集群基础之上，每个服务器都有镜像，保证安全性，用户只需按量付费 ​ D. 独立服务器：租赁服务器，托管服务器，自行购买维护服务器 ​ (a) 塔式服务器 ​ (b) 机架式服务器：U：是一种表示机架式服务器外部尺寸的单位，是unit的缩略语，厚度以4.445cm为基本单位，1U就是4.445cm，2U则是1U的2倍为8.89cm (3) 域名及域名解析 安装Apache服务器程序 (1) 注意：Apache为服务名称，其软件名称为httpd (2) 过程： ​ A. 搭建DVD光盘yum仓库 ​ (a) mount /dev/sr0 /media ​ (若找不到媒体，在虚拟机右下角点击光盘图标单右后点击连接) ​ (b) cd /etc ​ mv yum.repos.d yum.repos.d.back ​ mkdir yum.repos.d ​ cd yum.repos.d ​ (c) vim DVD.repo 输入以下内容： ​ [DVD] ​ baseurl=file:///media ​ enabled=1 ​ gpgcheck=0 ​ (d) yum makecache ​ B. 安装httpd服务程序：yum install -y httpd ​ C. 启动httpd服务程序：systemctl start httpd ​ D. 开机启动httpd服务程序：systemctl enable httpd ​ E. 检测httpd安装是否成功：点击Linux浏览器，地址栏中输入127.0.0.1 httpd服务程序的配置 (1) 配置目录 ​ A. 服务目录：/etc/httpd ​ B. 配置文件：/etc/httpd/conf/httpd.conf ​ C. 网站数据：/var/www/html ​ D. 访问日志：/var/log/httpd/access.log ​ E. 错误日志：/var/log/httpd/error_log (2) 主配置文件分析 ​ A. 路径：/etc/httpd/conf/httpd.conf ​ B. 打开方式：vim /etc/httpd/conf/httpd.conf ​ C. 结构分析： ​ (a) 注释行：#开头，起到声明的作用 ​ (b) 全局配置：对所有网页程序都生效 ​ (c) 局部配置：以&lt;&gt;作为定界符，只在局部网页或功能下生效 ​ D. 主要参数： ​ (a) ServerRoot ：服务目录 ​ (b) ServerAdmin：管理员邮箱 ​ (c) User：运行服务的用户 ​ (d) Group：运行服务的工作组 ​ (e) ServerName：网站服务器的域名 ​ (f) DocumentRoot：网站数据目录 ​ (g) Listen：监听的IP地址与端口号（80） ​ (h) DirectoryIndex：默认的索引页页面 ​ (i) ErrorLog：错误日志文件 ​ (j) CustomLog：访问日志文件 ​ (k) Timeout：网页超时时间，默认为300秒 ​ (l) Include：需要加载的其他文件 (3) 部署个人网站 ​ A. 放置个人网页 ​ (a) 在/下建立目录：mkdir /web1 ​ (b) 在图形化界面中将Windows的web页复制粘贴到Linux的/web1目录中 ​ B. 修改http配置文件的网页默认存储目录 ​ (a) vim /etc/httpd/conf/httpd.conf ​ (b) 定位第119行，将DocumentRoot &quot;/var/www/html&quot;中的&quot;/var/www/html&quot;改为&quot;/web1&quot; ​ (c) 定位第124行&lt;Directory &quot;var/www&quot;&gt;中的&quot;var/www&quot;改为&quot;/web1&quot; ​ (d) 保存退出 ​ (e) 重启httpd服务：systemctl restart httpd ​ C. 关闭防火墙：systemctl stop filewalld ​ D. 关闭SELinux ​ (a) SELinux：Security-Enhanced Linux，美国国际安全局在Linux社区帮助下开发的一个“强制访问控制的安全子系统”，用于让系统中的各个服务进程都收到约束，即仅能访问到所需要的文件 ​ (b) 常用命令： ​ ◆ 查询当前SELinux状态：getenforce ​ ◆ 模式一：Enforcing ， 安全策略强制启用模式，将会拦截服务的不合法请求 ​ ◆ 模式二：Permissive ， 遇到服务越权访问只会发出警告而不强制拦截 ​ ◆ 模式三：Disabled ， 对于越权的行为不警告，也不拦截 ​ ◆ 关闭SELinux：setenforce 0 ​ E. 输入ip addr查看本机IP，通过IP地址在浏览器中查看网页 (4) 设置手动强制域名解析 ​ A. 在Windows中定位文件：C:\Windows\System32\drivers\etc\hosts ​ B. 点击hosts文件后单击右键以记事本打开 ​ C. 在最后一行添加一行记录： ​ (a) 格式：IP 域名 ​ (b) 例：192.168.122.1 www.ylx.com ​ (c) 保存退出 ​ D. 在Windows中打开浏览器输入上述域名也可访问网站 ​ E. 注意：以上方法仅限于实验，实际工作中需要购买DNS域名解析服务及域名]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-十、操作系统基础知识]]></title>
    <url>%2F2019%2F07%2F23%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%8D%81%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[十、操作系统基础知识 概念：管理计算机软硬件资源，提供系统设备接口及工作界面 (1) 管理者作用 ​ A. 管理硬件资源 ​ (a) 管理CPU运算时间 ​ (b) 管理内存的存储空间 ​ B. 提供使用方法 ​ (a) 工作界面：图形化界面（GUI）、命令行界面（CLI） ​ (b) 提供接口 ​ ◆ 软件接口：API ​ ◆ 硬件接口 操作系统功能 (1) 进程管理：管理CPU运行时间（轮转、同步、死锁等） (2) 内存管理：管理内存存储空间（申请、释放、扩展、安全等） (3) 设备管理：管理除了CPU、内存之外的所有设备（磁盘等） (4) 文件管理：文件系统（FAT32 NTFS） (5) 用户界面管理：提供shell界面及方式 (6) 网络管理：网络创建、地址规划、连接等 Linux系统架构 (1) 组成：硬件、内核、系统调用、应用程序（从外到内） (2) 图： (3) kernel结构： ​ A. 图： ​ ​ B. system call interface（SCI）：系统调用接口，由一系列的预先编写好的函数库构成，系统调用把应用程序的请求传给内核调用相应的内核函数完成所需的处理，将处理结果返回给应用程序 ​ C. PM ：进程管理，创建销毁进程，管理进程的执行 ​ D. MM ：内存管理，管理内存空间的申请、回收等功能，并完成地址映射转换 ​ E. VFS ：虚拟文件系统，位于应用程序与实际多种文件系统之间，为文件系统提供了一个通用的接口抽象，如图： ​ ​ ​ F. NS ：网络堆栈，遵循模TCP/IP本身的分层体系结构，提供和管理网络连接，提供对多种网络通信标准的访问并支持许多网络硬件 ​ G. DD ：硬件设备驱动，提供大量预制设备驱动程序，识别管理外部硬件设备 Linux系统的基本组成 (1) 组成：内核 + 根文件系统 (2) 内核：是Linux的整个核心，确切的说内核即是Linux，其他程序都是通过调度内核来实现其功能 (3) 根文件系统：根目录及文件系统 Linux系统启动流程 (1) 系统自检 ​ A. 作用：当按下开机键后，立刻加电，自检程序会检查硬件设备的状态是否正常，重点检查CPU及内存 ​ B. 自检失败：内存损坏、接触不良，键盘未安装，CPU异常 (2) 加载主引导记录 ​ A. 确定引导设备：硬盘、光盘、U盘、网络 ​ B. 从引导介质中加载引导程序 ​ C. 使用Bootloader（引导加载器）进行引导 (3) 加载内核 (4) 加载根文件系统 (5) 启动初始化进程及后续服务 ​ A. 内核文件加载以后，就开始运行第一个程序systemd，它的作用是初始化系统环境，由于systemd是第一个运行的程序，它的进程编号（pid）就是1，其他所有进程都从它衍生，都是它的子进程 ​ B. 配置文件：/usr/lib/systemd/system ​ /etc/systemd/system (6) 加载终端：6个终端 ​ A. 1个GUI，5个tty ​ B. 6个tty (7) 开始登录 ​ A. 图形化界面登录 ​ B. 命令行登录界面 ​ C. 远程登录 (8) 加载环境变量 (9) 显示命令提示符，等待用户输入命令 网络基本概念 (1) 概念：以资源共享为根本目的，遵循相同通信协议，以大量自治计算机组成的资源集合 (2) 组成： ​ A. 广域网（WAN）：直径大于50KM以上的远程网络 ​ B. 城域网（MAN）：使用双环型结构的作用于一个城市的网络集合 ​ C. 局域网（LAN）：直径小于5km以内的网络，易于创建、修改、扩展 (3) TCP/IP协议： ​ A. 网络模型：四层 ​ B. 结构： 应用层 4 传输层 3 互联层 2 物理层 1 ​ C. 作用： ​ (a) 应用层：创建网络连接，管理连接，相应用户的网络服务（软件） ​ (b) 传输层：使用TCP或UDP传输报文（传输方式） ​ (c) 互联层：使用IP地址进行路由转发，路由选择（传输设备） ​ (d) 物理层：使用二进制透明传输比特流（传输介质） (4) IP地址：（IDDR） ​ A. 作用：用于互联网上表示唯一的连接 ​ B. 注意： ​ (a) 一个IP地址只能表示一个主机位置 ​ (b) 一个主机可以拥有多个IP地址 ​ C. 组成： ​ (a) 32位二进制组成，点分十进制表示 ​ (b) 例：二进制形态： 1100 0000 1010 1000 0000 0001 0000 0001 ​ 点分十进制形态：192.168.1.1 ​ (c) IP地址=网络号+主机号，上例中192.168.1为网络号，主机号为1 ​ D. 分类： ​ (a) 原则：将IP的网络：主机号字段按照1:3、2:2、3:1的方式划分成以下五种类别的IP地址 ​ (b) 类别： 名称 第一字节范围 NET:HOST 主机数 应用 A类 1-126 1:3 16777214 大型网络 B类 128-191 2:2 65534 中型网络 C类 192-223 3:1 254 小型网络 D类 留 作 它 用 E类 留 作 它 用 ​ E. 实际LAN的IP地址规划 ​ (a) 常见Router的IP地址：192.168.1.1或192.168.0.1 ​ (b) IP地址处于同一网络互通原则：网络号必须相同 ​ (c) 实际主机IP地址范围：192.168.1.2–192.168.1.254 ​ (d) 习惯客户机升序设置IP，服务器倒序设置IP ​ (5) 子网掩码：（NETMASK） ​ A. 组成：32位二进制，点分十进制表示，由左向右为连续1，再是连续0，如：255.255.255.0拆分为二进制：1111 1111 1111 1111 1111 1111 0000 0000（1和0不能交叉） ​ B. 作用：子网掩码中数字1对应的IP地址数字表示网络号，数字0对应的IP地址数字表示主机号 ​ C. 网络地址： ​ (a) 组成：网络号+0 ​ (b) 例：192.168.1.0 10.0.0.0 ​ (c) 作用：表示该网络的名称，用于区分网络，IP地址的网络地址不同不能通信 ​ (d) 计算IP地址的网络地址：IP地址与子网掩码二进制状态下按位相与，如：192.168.10.1 &amp;255.255.255.0结果为192.168.10.0（1&amp;任意数=任意数本身） ​ D. ==标准子网掩码：== ​ (a) A类：255.0.0.0 /8 ​ (b) B类：255.255.0.0 /16 ​ (c) C类：255.255.255.0 /24（一个255是8个1，一共24个1） ​ E. ==子网掩码简略写法：== ​ (a) 格式：/数字 ​ (b) 数字：子网掩码中二进制状态下由左向右连续1的个数，共32位，剩余补0 ​ (c) 例：192.168.10.129/24 ​ ◆ IP地址：192.168.10.129 ​ ◆ 子网掩码：255.255.255.0 ​ (6) 网关地址（GATEWAY）：一般为路由器或服务器的地址 ​ (7) 域名解析： ​ A. 原因：计算机设备只识别IP地址，不识别域名网址，对于使用者由于域名网址便于使用和记忆则愿意使用域名网址 ​ B. 作用：在互联网中存在着一种既独立又协作的域名解析服务器来完成域名与IP的相互转换映射 ​ C. 分类： ​ (a) 正向解析：域名-&gt;IP ​ (b) 反向解析：IP-&gt;域名 ​ D. 常见的域名解析服务器地址： ​ (a) 默认：路由IP地址（192.168.1.1） ​ (b) 8.8.8.8 （Google公司） ​ (c) 114.114.114.114 （工信部） HTTP协议 (1) 超文本传输控制协议 (2) 作用：传输web页 (3) 端口：80 (4) 架构：客户机/服务器（C/S） (5) URL：统一资源定位符格式，用于表示网址 ​ A. 例：HTTP://www.baidu.com/index.html ​ B. 结构：协议名://域名/文件名]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-九、软件下载及安装]]></title>
    <url>%2F2019%2F07%2F22%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B9%9D%E3%80%81%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[九、软件下载及安装 安装方式 (1) 原码安装 ​ A. 原理：软件编写者或厂商编写放出的原始代码文本文件 ​ B. 方式：解压缩Tarball文件，并且安装前需要进行检测操作系统、设定编辑环境参数、编译、设置等工作再进行安装 ​ C. 特点：软件安装自由，可以制定相关功能，但操作量大，麻烦，对安装人员的技术要求较高 (2) RPM安装 ​ A. RPM ：Red Hat Package Manager （红帽软件管理器） ​ B. 原理：软件发布者在他自己的系统中编译好用户所需的软件，再进行发布交由用户使用，由于软件制作者使用的硬件和使用者是一样的，则省略的原码的相关步骤 ​ C. 特点：简化安装步骤，但必须设置好软件安装的依赖性 (3) YUM安装 ​ A. 原理：将RPM安装的软件及依赖软件的相关信息组成数据库存储在网络服务器中，用户安装软件时会首先查询该服务器的数据库，将安装软件及依赖软件一同打包下载 ​ B. 特点：软件安装简单，但无法自定义软件 RPM软件安装 (1) 过程 ​ A. 读取RPM包头中的数据，进行查询软件依赖性 ​ B. 依赖性若满足则安装软件 ​ C. 若不满足则安装失败 (2) 要求 ​ A. 软件编译打包的环境必须与用户使用的环境相同 ​ B. 软件安装依赖性必须满足 ​ C. 卸载软件时最底层软件不能先卸载，否则系统会出错 (3) RPM文件 ​ A. RPM文件：扩展名为*.rpm，已经编译可以直接安装，但不能修改其中参数，不能重新编译 ​ B. SRPM文件：扩展名为*.src.rpm，未编译的原码文件，不可以直接执行，但可以根据当前环境和需求进行参数修改 ​ C. RPM软件包的名称解释 ​ (a) 例：python-iniparse -0.4 -9 .el7.x86_64.rpm ​ (b) python-iniparse ：软件名称 ​ (c) -0.4 ：版本号 ​ (d) -9 ：编译次数 ​ (e) .el7.x86_64.rpm ：适用的平台 ​ (f) 注意： ​ ◆ x86_64 ：64位平台 ​ ◆ i386 ：32位平台 ​ ◆ noarch ：通用平台，64位及32位都可使用 (4) RPM软件安装命令 ​ A. 格式：rpm -参数 软件名称.rpm ​ B. 参数： ​ (a) -i ：安装软件 ​ (b) -v ：查看安装信息 ​ (c) -h ：显示安装进度 ​ (d) –nodeps ：发生安装依赖时，强制安装，但可能安装后的软件无法使用 ​ (e) –force ：安装时提示已安装，则覆盖安装 ​ (f) -q ：查询软件是否安装 ​ C. 例：手动安装gcc软件：（非常麻烦） ​ (a) 新建待安装软件包目录：mkdir ~/gcc ​ (b) 挂载光盘：mount /dev/sr0 /media ​ (c) 进入软件包目录：cd /media/Packages ​ (d) 拷贝7个依赖软件： 1234567cp mpfr-3.1.1-4.el7.x86_64.rpm ~/gcccp libmpc-1.0.1-3.el7.x86_64.rpm ~/gcccp kernel-headers-3.10.0-693.el7.x86_64.rpm ~/gcccp glibc-headers-2.17-196.el7.x86_64.rpm ~/gcccp glibc-devel-2.17-196.el7.x86_64.rpm ~/gcccp cpp-4.8.5-16.el7.x86_64.rpm ~/gcccp gcc-4.8.5-16.el7.x86_64.rpm ~/gcc ​ (e) cd ~/gcc ​ (f) 按下列顺序安装软件： 1234567rpm -ivh mpfr-3.1.1-4.el7.x86_64.rpmrpm -ivh libmpc-1.0.1-3.el7.x86_64.rpmrpm -ivh kernel-headers-3.10.0-693.el7.x86_64.rpmrpm -ivh glibc-headers-2.17-196.el7.x86_64.rpmrpm -ivh glibc-devel-2.17-196.el7.x86_64.rpmrpm -ivh cpp-4.8.5-16.el7.x86_64.rpmrpm -ivh gcc-4.8.5-16.el7.x86_64.rpm ​ (g) 检测gcc ：rpm -q gcc (5) RPM软件卸载 ​ A. 格式：rpm -e 软件名.rpm ​ B. 注意： ​ (a) 软件安装时有依赖性，卸载时依然有依赖性，应从最上层软件开始卸载，否则会出现问题 ​ (b) 若强行卸载则会破坏rpm的软件数据库，从而导致系统异常 ​ (c) 修复rpm数据库的方式：rpm --rebuilddb YUM软件安装 (1) YUM原理：Linux系统将软件编译好之后放到服务器中，并将该软件的依赖关系记录成表格也存储到服务器中，用户下载软件时会将该软件的信息下载到本地并与RPM数据库作比对，分析依赖软件的状态，一次性打包下载所有软件 (2) YUM仓库：记录软件依赖性等信息的数据库 (3) YUM常用命令： ​ A. 浏览： ​ (a) yum repolist all ：列出所有yum软件仓库 ​ (b) yum list all ：列出仓库中所有软件包 ​ (c) yum info 软件包名称 ：，列出软件包安装信息 ​ B. 安装： ​ (a) yum install 软件包名 ：安装软件包 ​ (b) yum install -y 软件包名 ：安装并确认 ​ ◆ yum install java ​ ◆ yum install -y python ​ C. 更新： ​ (a) yum update ：升级所有软件 ​ (b) yum update 软件包名 ：升级更新指定软件 ​ (c) 例：yum update kernel ​ yum update bash ​ D. 卸载：yum remove 软件包名 ​ E. *yum命令安装下载RPM包： ​ (a) 格式1：yum install 软件包名.rpm ​ (b) 格式2：yum installl URL/软件包名.rpm ​ 安装wps Linux版： ​ 网址：https://wdl1.cache.wps.cn/wps/download/ep/Linux2019/8722/wps-office-11.1.0.8722-1.x86_64.rpm ​ yum install https://wdl1.cache.wps.cn/wps/download/ep/Linux2019/8722/wps-office-11.1.0.8722-1.x86_64.rpm (4) YUM安装软件包组： ​ A. 命令格式： ​ (a) yum grouplist ：列出所有可以使用的包组 ​ (b) yum grouplist 包组名 ：列出软件包组的软件信息 ​ (c) yum groupinstall 包组名 ：安装软件包组 ​ (d) yum groupremove 包组名 ：卸载软件包组 ​ B. 意义：安装大型项目时，所需的软件很多，此时通过单个软件安装非常麻烦，如：GNOME x-WINDOWS等大型软件，可以通过软件包组进行安装 ​ C. 安装图形化界面 ​ (a) 查询：yum grouplist ​ (b) 安装：yum groupinstall GNOME Desktop ​ (c) 启动：startx (5) yum配置文件分析： ​ A. 路径：/etc/repos.d/CentOS-Base.repo ​ B. 分析： ​ (a) [base] ：表示yum软件库的名称，[]不能省略，内容任意，但不能相同 ​ (b) name ：描述软件库意义，可省略 ​ (c) mirrorlist= ：映射方式，可省略 ​ (d) baseurl = ：表示软件库的域名网址，非常重要！ ​ (e) enable=1 ：启用该库，enable=0 ：不启用 ​ (f) gpgcheck=1 ：检查软件的数字签名，gpgcheck=0 ：不检查 ​ (g) gpgkey= ：检查数字签名时所需的公钥文件位置，不检查数字签名时，可省略 ​ (h)注意：其他库如：升级库（update）、附加库（extras）意义同此库（base） ​ C. 利用本地光盘镜像搭建yum仓库：（断网可用） ​ (a) 挂载本地光盘：mount /dev/sr0 /media ​ (b) 清空yum缓存：yum clean all ​ (c) cd /etc ​ (d) 备份原有配置文件目录：mv yum.repos.d yum.repos.d.back ​ (e) 新建配置文件目录：mkdir yum.repos.d ​ (f) cd yum.repos.d ​ (g) 新建yum配置文件：vim DVD.repo 输入以下内容： ​ [DVD] ​ baseurl=file:///media ​ enabled=1 ​ gpgcheck=0 ​ 保存退出 ​ (h) 新建yum缓存：yum makecache ​ (i) 查看是否启用：yum repolist all ​ (j) 尝试下载安装软件：yum install tftp ​]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js布尔值和自定义属性]]></title>
    <url>%2F2019%2F07%2F21%2Fjs%E5%B8%83%E5%B0%94%E5%80%BC%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据类型转换 布尔值类型: Boolean(value)把值转换成Boolean型 Boolean方法和之前的Number方法和String方法进行数值类型转换时，都将创建一个新值，存放由原始值直接转换成的值。 在进行比较时，也会得到一个布尔值，如&gt;、&lt;、或都会让字符串和数字的比较结果正确显示，但两个字符串不行(因为字符串是没有固定大小的原始类型)，如：’10’&gt;9和’10’&gt;’9’，前者为true后者为false，字符串之间的比较是从左向右一位一位的比较unicode编码大小 !取反，布尔值的隐形转换方法，取反之前若转换布尔值为真，则取反后的结果一定是布尔值且为假 ==如果两边数值相同(即使不同类型，如：’2’和2(，就相等，在判断前将两边转换成了数字 ===会判断类型，类型不同即使数值相同也返回false 布尔值转换规则： 数据类型–数字：除了NaN和0都是真 数据类型–字符串：所有非空字符串都是真 数据类型–布尔值：true和false 数据类型–对象(函数)：true 数据类型–对象(element)：能找到的就是true，找不到的是false(找不到的就是null)； 数据类型–对象([]和{})：true 数据类型–对象(null) ：false 数据类型–未定义(undefined)：false 比较：比较会在判断前==将两边转换成数字==然后比较其值，但是有几种情况比较特殊 如果两边有null和undefined时，不会发生转换数字的，因此null和undefined只与自己和对方相等 由于字符串没有固定大小，因此转数字会变成NaN，所以它也不会发生数字类型转换，而是从左向右一位一位的比较unicode编码大小 由于对象转换数字也是NaN，因此如果两边都为对象的时候也不会发生数字类型转换，而是按照对象在内存中的地址比较，地址相同即相等，否则不等 数据类型转换的注意事项： 不要用new Number()/Boolean()/String()等构造函数实例化的方式去创建包装对象，因为这样创建出来的是object类型 判断Array（数组是数组）使用Array.isArray(arr) 判断null请使用myVar === null number对象(非变量(调用toString()报SyntaxError： 1234123.toString(); // 报SyntaxError//遇到这种情况，要特殊处理一下：123..toString(); // '123', 注意是两个点！(123).toString(); // '123' 自定义属性 人为给元素上定义本来不存在的属性就是自定义属性，自定义属性一般根据语义去取名，语法： 1元素.自定义属性 = 123; 注意：自定义属性的操作如同原本属性一样 可以为元素添加任意数量的自定义属性，它是js向html添加值的方式之一 使用范例：索引值 123for(var i=0;i&lt;n;i++)&#123; 元素[i].index = i; //为每一个对象建立"匹配"/"对应"关系&#125; 注意：后面循环几乎都会用到索引值 循环中的问题，如果在循环时绑定事件函数，循环是在页面刷新时执行的，而函数执行时循环已经结束，这时i的值已经变成最后一个数字，在函数内使用就是出现问题。 解决方法就是使用自定义属性，将i的值在循环时保存下来，在函数内部需要的时候使用该自定义属性 练习： 1. 如何让’10’&gt;’9’正确的比较出大小，试着用多种方法来实现 看下面代码说出结果： 12345console.log(2==true);console.log(null==0);console.log("123"=="0123");console.log([]==[]);console.log([]==![]); 2. 做3个按钮，起始value为0，每次点击时对应按钮的value值+1 3. 在上题的基础上增加一个数组[“A”,”B”,”C”,”D”]，要求每个按钮在点击时，让其value值显示为数组数据的循环(A-&gt;B-&gt;C-&gt;D-&gt;A循环) 4. 在点击按钮(3个)时用索引值把arr(3个)里的数据输入到p(3个)标签里 5. 写一个img标签并将其图片信息和图片数量等进行布局；按照图片数量动态生成按钮，并写个数组保存图片信息；设置active的样式为红色背景白色字体，第一个按钮的class=”active”，并在点击其他按钮时切换active；尽量使用函数去把代码合并，并在点击按钮时用索引值的一一对应来做当图片切换时同步切换图片信息和图片的数量]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转）Markdown语法]]></title>
    <url>%2F2019%2F07%2F20%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文转自：简书作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed一、标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十、流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ```]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型详解和数据类型转换]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据类型详解 未定义：undefined，如 var n ; 就是一种状态，通常指出错了，出现的情况： 当变量定义但未赋值时，该变量的值被格式化为undefined； 对一个没有声明的变量调用typeof时，返回值也是undefined； 当函数无明确返回值时，返回值也是undefiend 空对象：null，如 var n = null; 不存在的object，通常是人为设置的空 虽然null判断类型为对象，但是它不能添加自定义属性 表示尚未存在的对象，如果函数要返回对象，那么找不到该对象时，返回的值通常是null 字符串类型：string，如 var s =&quot;nihao&quot;; 由零或多个 16位 Unicode 字符组成的字符序列 string是唯一没有固定大小的原始类型，字符串的字面量声明可以由双引号””或单引号’’组成 length属性：输出字符串的长度，空格也算长度 charAt()方法：输出()里下标处的字符（在最新的js版本中支持使用数组的[]来获取下标处的字符，s[i]） 布尔值：boolean，如 var b = true; 只有true和false两个值。在if判断的条件和for循环的两个;之间都是布尔值，这些需要布尔值的地方会自动被转换 数字类型：number，如 var i = 100; 不区分整形和浮点，number可以表示32位的整数，也可以表示64位的浮点数。 对象类型：object（包括Array、Function、Date、Json等），如 var obj1 = {}; 对象（object）是js的基本数据类型之一。它是一种复合值：把多个值（原始值或者其他对象）聚合在一起，并通过名字（key）访问这些值。 对象也可看做是属性的无序集合，每个属性都是一个名/值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射 object可以像我们页面元素一样添加自定义属性，如：obj.abc = 123; 或 obj={&quot;abc&quot; : 123}; 我们之前获取元素通过点操作（obj .name）和通过中括号操作（obj[&quot;name&quot;]）同样适用于所有对象 当一个函数被一个对象所拥有，那么该函数也被称为方法，同时该函数被调用时内部的this指向会指向该对象 数据类型转换 如页面元素的block、inline这些类型，当我们需要相应的类型时就要进行数据类型转换 在JavaScript中，boolean值，数字和字符串的原始值都是伪对象，这意味着它们实际上具有属性和方法，如：”blue”.length; 转换字符串类型： 三种值类型（字符串、数组和布尔值）都具有toString方法，可以将自身转换为字符串，如Number的toString方法: 注意：null和undefined没有toString方法 12var iNum = 10;console.log(iNum.toString()); //输出字符串"10" String()强制类型转换与toString()方法的唯一不同之处在于，对null或undefined值强制类型转换可以生成字符串而不引发错误，如: 12var s1 = null.toString(); //错误var s2 = String(null); //得到"null" 与上面强制类型转换（即显形转换）对应的字符串的隐形转换+（字符串连字符） 123var s = "100"; alert(s + 100) ; //输出"100100"alert(null + "1"); //将数字1本身转换为字符串 注意：由于+是字符串连接符，因此我们要做数字相加时，必须保证加号两边的都是数字 转换数字类型： Number()方法，尽可能的将传入的值整体转换成数字。其转换规则为： 数据类型–字符串：””（空）和” “（空格）都会转换成0；数字字符串会转换成对应数字；非数字字符串转换成NaN（not a number），NaN != NaN 数据类型–布尔值：true和false会变成1和0 数据类型–空对象：null会被变成0 数据类型–对象(函数、json和其他对象)：NaN 数据类型–未定义：undefined（未定义）会变成NaN 数据类型–数组：如果为空转换成0；只有一个数据（字符串、null或undefined）时字符串会根据之前的规则一样去转，空、null和undefined会转换成0；有多个数据时转成NaN 使用方法如： 123456var s = "100";alert（Number（s）+100）; //输出结果为数字200console.log(Number(null)); //输出结果是0cnsole.log(Number(undefined)); //输出结果是NaNconsole.log(Number("100px"-1)); //输出结果为NaN Number不合适的地方：当一个字符串是var b = &quot;100px&quot;，会变成NaN，因此转换字符串时Number用的比较少，而一般用下面两个方法 parseInt()：将字符串转换成整数，转换规则为： 会从左到右依次判断每个字符，碰到非数字后会将前面的数字输出(会认识一些特殊符号，如+-空格) 若数据不是字符串会返回NaN 只会保留整数，小数点和其后面的部分会被舍去 最好写成parseInt(b,10)，后面代表10进制 123var i = "fff";/* 将16进制数转换为十进制数 */console.log(parseInt(i,16)); parseFloat()：与parseInt一样，但是会保留第1个小数点后面的数字 123456var i1 = "10";var i2 = "10.01";var i3 = "100px";//字符串转数字的强制类型转换console.log(parseInt(i3));console.log(parseFloat(i2)); 除上面的强制类型转换方法，+(正号)、-(负号)、-、*、/、%、++、–也会让数字字符串和数字字符串或数字的运算结果变成数字类型，既数字类型的隐形转换注意：+在两边有字符串时会变成字符串的隐性转换，但是作为正号或者两边没有字符串时，也是数字类型的隐形转换 12345var a = 10;var b = "10";/* 表示a加正c，也就是把字符串10转换为数字10 */console.log(a+ +c); //输出结果为数字20console("100px"-1); //输出结果为NaN，跟number方法一样 无论是哪种转换方法，转换数字失败就会返回NaN，NaN（not a number）它是转换数字类型转换失败的产物，但依然变成了number类型，它一旦出现代表你的代码进行了非法的操作 NaN转换布尔类型为false，它与它本身不相等（而其他所有类型与自己都相等） isNaN():is not a number，用来判断一个number类型是不是非数字，不是数字返回true，是数字则返回false。若判断的值不是number类型，会找Number判断，如果转换后的结果是NaN则返回true 练习： 1. 做一个input输入框和按钮，判断输入值是不是都是由数字字符组成的字符串，当判断的结果是数字时，再弹出是不是整数 ​ a. HTML部分： 12&lt;input type="text" id="btn1"&gt;&lt;input type="button" id="btn2" value="确定"&gt; ​ b. JS部分： 123456789101112131415161718var oBtn1 = document.getElementById("btn1");var oBtn2 = document.getElementById("btn2");oBtn2.onclick = function ()&#123; // if(parseFloat(oBtn1.value)== oBtn1.value) if(Number(oBtn1.value) == Number(oBtn1.value)) &#123; alert("是数字字符组成的字符串"); if(parseInt(oBtn1.value) == oBtn1.value)&#123; alert("是整数"); &#125; else&#123; alert("不是整数"); &#125; &#125; else&#123; alert("不是数字字符组成的字符串"); &#125;&#125; 2. 看下面题，说出结果： 1 + “23”; 结果：123 null * 0; 结果：0 true + “ “; 结果：true空格 true * “ “; 结果：0 undefined + 0; 结果：NaN 20 + -“20”; 结果：0 20 + +”20” 结果：40 3. 有一个数组arr = [ ‘100px’, ‘abc’-6, [], -98765, 34, -2, 0, ‘300’, , function(){alert(1);}, null, document, [], true, ‘200px’-30,’23.45元’, 5, Number(‘abc’), function(){ alert(3); }, ‘xyz’-90 ]; 要求： 1、找到arr里所有的数字：-98765, 34, -2, 0, 5 2、找到可以转成数字的：&apos;100px&apos;, -98765, 34, -2, 0, &apos;300&apos;, &apos;23.45元&apos;, 5 3、把转成数字以后，最大值判断出来：300 4、把 NaN 所在的位置找出来：1 14 17 19&lt;/font&gt;1234567891011121314151617181920212223242526272829303132333435363738394041var arr = [ '100px', 'abc'-6, [], -98765, 34, -2, 0, '300', , function()&#123;alert(1);&#125;, null, document, [], true, '200px'-30,'23.45元', 5, Number('abc'), function()&#123; alert(3); &#125;, 'xyz'-90 ];var arr1 = [];var arr2 = [];var arr3 = [];var find = [];for(var i=0;i&lt;arr.length;i++)&#123; // 找到arr里所有的数字 if((typeof(arr[i]) == "number") &amp;&amp; !isNaN(arr[i]))&#123; arr1.push(arr[i]); &#125; // 找到可以转成数字的 else if(!isNaN(parseFloat(arr[i])) )&#123; arr2.push(arr[i]); &#125; //把 NaN 所在的位置找出来 else if(isNaN(Number(arr[i])) &amp;&amp; (typeof(arr[i]) == "number"))&#123; find.push(i); &#125;&#125;for(var i in arr1)&#123; arr2.push(arr1[i]);&#125;//转成数字for(var i in arr2)&#123; arr3[i] = parseFloat(arr2[i]);&#125;// 把转成数字以后，最大值判断出来：300var max = arr3[0];for(var i=1;i&lt;arr3.length;i++)&#123; if(max&lt;arr3[i])&#123; max = arr3[i]; &#125;&#125;console.log(arr1);console.log(arr2);console.log(arr3);console.log(max);console.log(find);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js流程控制、JSON和this]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%81JSON%E5%92%8Cthis%2F</url>
    <content type="text"><![CDATA[流程控制语句 流程控制就是程序代码执行顺序：顺序结构：按照书写顺序来执行，是程序中最基本的流程结构；循环：[do ]while/for[ in]；判断：if/switch while的循环和for循环的写法区别： 1234567891011121314var i=0; //while方法while(i&lt;3)&#123; alert(i); i++;&#125; var i=0; //do while方法do&#123; //先执行do里的在判断，因此至少会执行一次 alert(i); i++;&#125;while(i&lt;3)for(var i=0;i&lt;3;i++)&#123; //for方法 alert(i);&#125; switch判断和if判断的写法区别： 123456789101112switch(str)&#123; //switch方法 case "js": break; case "html": break; default: alert(str);&#125;if(str=="js")&#123; //if方法&#125;else if(str=="html")&#123;&#125;else&#123; alert(str);&#125; 关键字：case (判断变量的值)；break(跳出，上面判断成功后不再继续判断后续)、 default(否则，上面判断都未通过时执行)；continue(跳过)例如： 123456for(var i=0;i&lt;6;i++)&#123; if(i==4)&#123; break; &#125; //当i为4的时候跳出该循环，若用continue则是跳过后续代码，继续循环 alert(i);&#125; JSON对象 JSON是JavaScript Object Notation的缩写：它被发明之前一直是用XML来传递数据，一种纯文本格式，本身不复杂，但加上各种规范以后变得非常复杂。 道格拉斯·克罗克福特(Douglas Crockford)在2002年发明了JSON这种超轻量级的数据交换格式。它基于ECMAScript的一个子集，采用完全独立的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、C#、Java、JavaScript、Perl、Python等)，这些特性使JSON成了理想的数据交换语言。易于阅读和编写，同时也易于机器解析和生成，并能提升网络传输速率。由于JSON非常简单，很快风靡Web世界。 json的语法：key==&gt;value 123456var json = &#123; "name" : "cromwell", "say" : function ()&#123; alert("hello"); &#125;&#125;; “:”前面是属性名，后面可以是任何数据格式(例子中是字符串和函数)，json.name可输出该属性的值，json.say()可调用该函数，非常方便。注意：定义的属性名称在严格模式下必须使用””，兼容性和安全性好；json[]调用数据的时候和对象的属性写法相同既： 12json["name"]; //获取json属性name的值json.name = "新值"; //可以用来改写json的name属性的值，赋值 用json可以包括数组，数组也可以包括json，如： 12var arr=[&#123;"name":"abc","age":20&#125;,&#123;"name":"bcd","age":30&#125;]; //数组嵌套jsonvar json = &#123;"a":[1,2,3],"b":[4,5,6,7]&#125;; //json嵌套数组 这时我们如果想拿到name的值”abc”就要写成arr[0].name了 for in循环：我们获取一下json的length发现json没有长度，因此无法使用for循环遍历json。for循环里使用数字i作为循环的变量对应下标，而for in循环则使用attr就是属性名称来对应json的属性名： 1234 for(var attr in json)&#123; alert(attr+":"+json[attr]) &#125;;//window和document就是两个带有很多属性的对象，我们可以输出一下看看 注意：数组用for和for in都可以遍历，用for in时属性名称就是下标；嵌套式的json和数组需要for in和for循环配合来遍历 this是什么？ 全局对象的this，是一个比较特殊的存在。全局环境中的this，指向window。 在函数(fn1)内部的this分成三种情况： 直接调用：fn1()，其内部的this会指向undefined。但是在默认非严格模式中，当this指向undefined时，它会被自动指向全局对象既window 事件调用：obj.事件=fn1，内部的this指向调用函数的该对象 调用某对象拥有的函数：obj.fn1()，那么该函数在调用时，内部的this指向该对象，该写法也称为函数表达式，写法如下： 123function fn1()&#123;&#125; //函数声明var fn1 = function ()&#123;&#125; //函数表达式obj.fn1 = function ()&#123;&#125; //函数表达式 练习： ​ 1. 把JSON嵌套式的数组和JSON遍历出来 ​ JS部分： 12345678910111213141516171819202122232425//数组嵌套json var arr = [&#123; "a" : 1, "b" : 2, "c" : 3 &#125;,&#123; "d" : 4, "e" : 5, &#125;];//json嵌套数组var obj = &#123; "arr1" : ["a","b","c"], "arr2" : ["d","e"]&#125;;//先遍历数组，再for(var i=0;i&lt;arr.length;i++)&#123; for(var attr in arr[i])&#123; console.log(arr[i][attr]); &#125;&#125;;for(var attr in obj)&#123; for(var i=0;i&lt;obj[attr].length;i++)&#123; console.log(attr+ ":" + obj[attr][i]); &#125; &#125;; ​ 2. 创建一个全局属性(var a = &quot;tw&quot;)，创建一个对象(obj)即其属性(obj.a = &quot;to&quot;)和方法(obj.saya = function(){console.log(this.a)})，说出调用该方法时this是谁 ​ JS部分： 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组和循环]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%95%B0%E7%BB%84%E5%92%8C%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[数组(Array) 声明一个数组的变量： 12var arr1 = []; //字面量写法ar arr2 = new Array(); //构造函数实例化写法 注意：第一种写法等号右边就可以认为是字面量，字面量就是可以通过该值来判断它的类型；构造函数会在后面详细说明 数组是数据仓库，可以放任意多个任意数据类型的数据，甚至是其他数组；数据之间用”,”分隔；数组也是对象的一种，属性length为数组数据的数量，如： 1var arr = ["第一个数据","第二个数据","第三个数据"]; //可以通过arr[下标]来获取对应位置的数据 注意：js中(包括数组)，在计数的时候都是从0开始，所以arr[0]==&gt;”第一个数据” 数组的添加和修改方法： 12arr.push("第四个数据"); //从数组最后添加新数据("第四个数据")arr[0] = "第零个数据"; 类数组(伪数组) 用标签名来获取元素： 1document.getElementsByTagName(""); 注意：该方法获得的不是一个元素，因此不能直接拿来操作，可以用数组的[下标]来拿到你想操作的对象 例~ 获取p元素： 1var oP = document.getElementsByTagName("p")[0]; //获取p元素 它不是数组，却和数组很像，是类数组(也叫伪数组)的一种，伪数组可以被转化成数组，语法： 1Array.prototype.slice.call() //把类数组放在括号里并用变量接收数组结果 该方法(document.getElementByTagName)与document.getElementById的区别： document.getElementById： 前面必须是document； 获取的只有一个元素(id在同一个页面中也是唯一的)； 无法选中动态创建的元素(如通过innerHTML生成的标签) document.getElementsByTagName 前面可以是另一个元素； ByTagName获取的可能是多个(无论是一个和多个都会变成类数组)，需要加上[]和数字或者遍历(既循环)来控制； ByTagName可以选中动态创建的元素 另外特殊标签选取：在页面中唯一的标签如body、title：可以用document.body和document.title获取到该元素。注意：虽然html也是唯一标签，但是必须通过document.documentElement才能获取 循环 当我们需要重复执行某些代码或连续执行的代码有数字在变化时，就可以使用循环，语法： 1for(;;)&#123;反复执行的代码块......&#125; 注意：()里用两个;将其分成3个部分，第一个部分是初始变量，第二个为判断条件(为真就会继续循环)，第三个为变量的变化 循环经常被用做给数组或类数组遍历，如 1234var aDiv = document.getElementsByTagName("div");for(var i=0;i&lt;aDiv.length;i++)&#123; aDiv[i]...... //aDiv的每个数据执行某代码&#125; 注意：不要漏写[]，否则就变成让数组或类数组执行某代码了 例~我们先用for循环和body.innerHTML属性为body添加100个按钮，并一点一点增加数量，你会发现下面写法会使电脑速度越来越慢 1document.body.innerHTML += "&lt;input type='button' value='按钮'/&gt;"; 原因就是循环去修改DOM树的做法在数量过多时太耗性能，可以先循环将要添加的字符串预先连接后保存到str变量里，再一次修改DOM树就可以了 12345var str = ""; //用字面量的写法创建一个空字符串for(var i=0;i&lt;100;i++)&#123; str += "&lt;input type='button' value='按钮'/&gt;"; //在循环中反复拼接字符串&#125;document.body.innerHTML =str; //最后一次性将字符串添加到body里 JavaScript的for循环如果要遍历一个嵌套的数组，需要用两次for循环来遍历数据，执行第一个for时变量需小于arr.length，而执行第二个for时变量则需要小于arr[i].length，最后输出arr[i][j]： 123456var arr = [[1,2,3],[4,5,6],[7,8,9]];for(var i=0;i&lt;arr.length;i++)&#123; //第一次遍历出的arr[i]也都是数组，因此开启第二个循环 for(var j=0;j&lt;arr[i].length;j++)&#123; //遍历arr[i]，将其中的数据都遍历出来 arr[i][j]...... &#125;&#125; 注意：多个并列的for循环可以用相同的变量i，但是循环的嵌套就必须要换变量名了(如上面的j) 附： 123Math.ceil(); //向上取整Math.floor(); //向下取整Math.round(); //四舍五入 练习： ​ 1. （循环的DOM操作）在页面的body里创建20个li元素，让他们呈现一个楼梯效果 ​ a.HTML部分： 1&lt;ul id="ul1"&gt;&lt;/ul&gt; ​ b. CSS部分： 1234567li&#123; width: 50px; height: 50px; list-style: none; background-color: green; position: absolute;&#125; ​ c.JS部分： 1234567891011121314var str = "";var oUl = document.getElementById("ul1");/* 获取所有的li元素 */var aLi = document.getElementsByTagName("li");/* 生成li元素 */for(var i=0;i&lt;20;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;/* 再用循环设置定位 */for(var i=0;i&lt;20;i++)&#123; aLi[i].style.left = i*50 + "px"; aLi[i].style.top =i*50 + "px"; &#125; ​ 2. 将上题的li元素减少为7个，且呈现V形 ​ JS部分： 12345678910111213141516var str = "";var oUl = document.getElementById("ul1");var aLi = document.getElementsByTagName("li");for(var i=0;i&lt;7;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;7;i++)&#123; aLi[i].style.left = i*50 + "px"; if(i&lt;4)&#123; aLi[i].style.top =i*50 + "px"; &#125; else&#123; aLi[i].style.top = aLi[6-i].style.top; &#125;&#125; ​ 3. 动态创建50个li，每行显示10个li，每两个li间距1像素 ​ a.HTML部分： 1&lt;ul id="ul1"&gt;&lt;/ul&gt; ​ b. CSS部分： 123456789li&#123; list-style: none; width: 50px; height: 50px; background-color: green; position: absolute; top: 0; left: 0;&#125; ​ c. JS部分： 12345678910111213var oUl = document.getElementById("ul1");var oLi = document.getElementsByTagName("li");var str = "";for(var i=0;i&lt;50;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;oLi.length;i++)&#123; /* 每一列的个位数相等，只需要取余获得个位数即可 */ oLi[i].style.left = i%10 * 51+ "px"; /* 每一行的十位数相等，只需要除运算获得十位数即可 */ oLi[i].style.top = Math.floor(i/10) * 51 +"px";&#125; 4. **var arr1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];var arr2 = [&quot;d&quot;,&quot;e&quot;]得到var arr = [&quot;ad&quot;,&quot;ae&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;cd&quot;,&quot;ce&quot;]**4. var arr1 = [“a”,”b”,”c”];var arr2 = [“a”,”e”]得到var arr = [“ad”,”ae”,”bd”,”be”,”cd”,”ce”]，要求不能有重复项 ​ JS部分： 1234567891011121314var arr1 = ["a","b","c"];var arr2 = ["d","e"];var arr = [];for(var i=0;i&lt;arr1.length;i++)&#123; for(var j=0;j&lt;arr2.length;j++)&#123; if(arr1[i] == arr2[j])&#123; continue; &#125; else&#123; arr.push(arr1[i]+arr2[j]); &#125; &#125;&#125;console.log(arr);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型和判断]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[关键字、保留字和ECMAScript标准 class也是页面元素的属性之一，我们可以通过赋予元素不同的class来改变样式，但js元素的class属性写法却与其他的属性不同： 12元素.class //报错元素.className //正确写法 关键字：js里用到的语法单词(如：function var) 保留字：js里保留的单词(如：class ) 不要使用关键字和保留字来给变量命名，但是可以和其他单词组合使用，比如classOne className可以用来解决兼容问题，例如没有style.float的这种写法，style.styleFloat是ie写法；style.cssFloat是其他浏览器写法，那么我们设置元素的浮动时就可以用给元素添加class或移除class的方法来做 当你需要解决兼容问题时，要么知道做如何解决兼容问题(如封装带有兼容问题的代码)，要么会使用其他的解决方案(如用className绕过该问题)，有时我们要做一个兼容性很好的代码往往比代码本身要麻烦的多 js里的所有语言规范就是ECMAScript标准，例如function[]{}不能这么写，这是已经定义好的，必须遵守的 数据类型 js的数据类型，像HTML的标签就有各种类型：block、inline、inline-block，数据类型的目的是对他们能够做更准确的操作 JavaScript中有5种原始数据类型——Undefined(未定义)、Null(空对象)、Boolean(布尔值)、Number(数字)、String(字符串)和特殊一个引用型类型——Object(对象)： Undefined(未定义)表示一个变量不含值(一般非人为因素) Null(空对象)通过设置NULL来清空变量(人为设置) 注意：undefined实际上的从null派生来的，它们在定义上是相等的 1alert(null==undefined) //true 注意：==在js中用来判断值相等，如果两边数据类型不同会在判断大小时会发生数据类型转换，但是undefined和null不会发生转换，判断结果依然为true Boolean(布尔值)只有true(真)和false(假)两个值 Number(数字)不分整数和浮点 自增/自减： 123456num += x; //相当于num = num + x;num -= x; //相当于num = num - x;num++; //先赋值再自增1num--; //先赋值再自减1++num; //先自增1再赋值--num; //先自增1再赋值 String(字符串)用双引号或单引号括起来的部分，“+”可以用来做字符串的拼接 1alert("hello"+"world"); object(对象类型)指向性数据类型(包括Array、Function、Date、Json以及页面中所有元素等)会在后面详细说明 用typeof可以判断数据类型，对变量调用typeof将返回下列值之一：string,number,Boolean,object,function,undefined，这些结果都是字符类型的 12var i = 100;alert(typeof(i)); //"number" 注意：对null调用typeof会返回object,null被认为是对象的占位符；而对象中的函数会返回function，这两种是特殊情况。 if判断 判断的语法： 123456789if(条件)&#123;代码块&#125; //当条件为true时执行代码块if(条件)&#123;代码块1&#125;else&#123;代码块2&#125; //当条件为true时执行代码块1，否则执行代码块2 if(条件1)&#123;代码块1&#125;else if(条件2)&#123;代码块2&#125;......else&#123;代码块n&#125; //当条件1为true时执行代码块1，否则条件2为true时执行代码块2,......否则执行代码块n 判断的注意事项： js获取元素的href和src属性得到不是相对路径而是绝对路径，因此不能用来做判断 通常颜色值也不能用来做判断，因为有很多颜色值的输出方式，如英文单词、rgb和16进制数 元素的内容innerHTML也不能用来做判断(在低版本浏览器上会有兼容性的问题) 当需要判断上面这些值时可以使用布尔值开关的方式解决问题，既每次执行的时候将一个布尔值变量取反(取反的符号为!，作用是将真假转换)，每次判断根据新的布尔值结果执行相应代码 判断时若使用的条件需要运算，我们常用以下的运算符：”==”(数值相等)；”===”(绝对相等—类型数值都相等)；”&gt;”，”&lt;”，”&gt;=”，”&lt;=”(大于，小于，大于等于，小于等于)等 练习： ​ 1. （用户控制时间调用函数特效）做两个input输入框和一个input按钮，通过分别向两个输入框输入样式名和样式的值的方法来改变一个div的样式 ​ a. HTML部分： 1234567891011&lt;div class="wrap"&gt; &lt;p&gt;请为下面的div设置样式：&lt;button id="btn1"&gt;点击设置&lt;/button&gt;&lt;/p&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;div id="div2"&gt; &lt;div class="ctrl"&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式" id="te1"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式值" id="te2"&gt;&lt;/div&gt; &lt;div&gt;&lt;button id="btn2"&gt;变化&lt;/button&gt;&lt;button id="btn3"&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100.wrap&#123; width: 735px; height: 420px; background-color: #efefef; margin: 0 auto; padding: 25px; box-sizing: border-box; position: relative; &#125; p&#123; margin: 0; font-size: 24px; font-weight: bold; &#125; #btn1&#123; border: none; padding: 0; width: 100px; height: 40px; font-size: 14px; color: white; background-color: red; &#125; #div1&#123; width: 100px; height: 100px; border: #393129 4px solid; background-color: white; &#125; #div2&#123; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); position: absolute; left: 0; top: 0; display: none; &#125; .ctrl&#123; position: absolute; right: 25px; bottom: 30px; width: 340px; height: 240px; box-sizing: border-box; border: 20px #9c949c solid; background-color: white; padding-top:15px; padding-bottom: 20px; &#125; .ctrl div&#123; text-align: center; font-size: 16px; margin-bottom: 5px; &#125; .ctrl div:nth-last-child(1)&#123; margin-top: 21px; &#125; .ctrl div button&#123; width: 36px; height: 32px; box-sizing: border-box; &#125; #color1&#123; background-color: red; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color2&#123; background-color: yellow; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color3&#123; background-color: blue; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #width1,#width2,#width3,#height1,#height2,#height3&#123; background-color: #efefef; border: 1px #c0c0c0 solid; color: #808080; font-size: 12px; margin-left: 5px; &#125; #btn2,#btn3&#123; width: 60px; height: 30px; background-color: #002952; color: white; &#125; ​ c. JS部分： 123456789101112131415var oBtn1 = document.getElementById("btn1");var oDiv2 = document.getElementById("div2");var oDiv1 = document.getElementById("div1");var oBtn2 = document.getElementById("btn2");var oBtn3 = document.getElementById("btn3");var oTe1 = document.getElementById("te1");var oTe2 = document.getElementById("te2");oBtn1.onclick = function ()&#123; oDiv2.style.display = "block";&#125;oBtn2.onclick = function ()&#123; var style = oTe1.value; var val = oTe2.value; oDiv1.style[style] = val;&#125; ​ 2. 做一个用两个按钮(加大、缩小)点击改变字体大小的效果，字体变换范围在12px-28px区间 ​ a.HTML部分： 12&lt;button id="btn1"&gt;变小&lt;/button&gt;&lt;button id="btn2"&gt;变大&lt;/button&gt;&lt;p id="p1"&gt;电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅&lt;/p&gt; ​ b. CSS部分： 123p&#123; font-size: 20px;&#125; ​ c. JS部分： 1234567891011121314var iFont = 20;var oBtn1 = document.getElementById("btn1");var oBtn2 = document.getElementById("btn2");var oP = document.getElementById("p1");oBtn1.onclick = function ()&#123; if(iFont&gt;12)&#123; oP.style.fontSize = --iFont + "px"; &#125;&#125;oBtn2.onclick = function ()&#123; if(iFont&lt;28)&#123; oP.style.fontSize = ++iFont + "px"; &#125;&#125; ​ 3.（表单验证）输入框input的验证，为空时弹出”输入框内容不能为空” ​ a. HTML部分： 123&lt;input type="text" id="te1"/&gt;&lt;input type="text" id="te2"/&gt;&lt;button id="btn1"&gt;弹出&lt;/button&gt; ​ b. JS部分： 1234567891011121314// 弹出第一个输入框的值 + "在" + 第二个输入框的值 // 如果第一个输入框内为空，则弹出 "输入内容不能为空" var oTe1 = document.getElementById("te1"); var oTe2 = document.getElementById("te2"); var oBtn1 = document.getElementById("btn1"); oBtn1.onclick = function ()&#123; // if(oTe1.value == "")&#123; // alert("输入内容不能为空"); // &#125;else&#123; // alert(oTe1.value + "在" + oTe2.value); // &#125; // oTe1.value == "" ? alert("输入内容不能为空") : alert(oTe1.value + "在" + oTe2.value); alert(oTe1.value == "" ? "输入内容不能为空" : oTe1.value + "在" + oTe2.value); &#125; ​ 4. 布尔值开关（取反）实现下拉框 ​ a. HTML部分： 12&lt;button id="btn1"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 120px; height: 40px; &#125; div&#123; width: 120px; height: 350px; background-color: red; display: none; &#125; ​ c. JS部分： 123456789101112var oDiv = document.getElementById("div1");var oBtn = document.getElementById("btn1");var bOn = true;oBtn.onclick = function ()&#123; // if(bOn)&#123; // oDiv.style.display = "block"; // &#125;else&#123; // oDiv.style.display = "none"; // &#125; oDiv.style.display = bOn ? "block" : "none"; bOn = !bOn;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件函数和属性操作]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js选择器和事件函数 js的事件：鼠标事件、键盘事件、系统事件、表单事件、自定义事件等，如下常见的鼠标事件 鼠标左键点击：onclick 鼠标移入：onmouseover 鼠标移出：onmouseout 鼠标左键落下：onmousedown 鼠标左键抬起：onmouseup 鼠标移动：onmousemove 获取元素的方法：通过ID名称来获取元素，其中.代表”的”： 1document.getElementById('link'); –&gt;document get element by id ‘link’(既在文档上通过id的值来获取元素)，获取的元素可以配合事件：元素.onmouseover=元素在鼠标移入该元素时做什么，由于做的事情应该是该事件触发时执行，那么这些代码我们不能直接使用，而是放在函数内部 函数(function)：由事件去命令它做一些事(执行代码块)，它不会主动执行： 函数是执行某一任务的JavaScript 语句，可被其他部分调用。 下面是声明一个有名函数的方法： 123function functionName()&#123; //function==&gt;关键字；functionName==&gt;是给函数取的名字 代码块...... //代码块==&gt;是完成某一任务的代码 &#125;; 我们把完成特定功能的代码块放到一个函数里，再调用这个函数，就省重复输入大量代码的麻烦。 有名函数执行方法：例如函数名为abc的函数 12abc(); //直接调用执行，当逐行执行代码执行到这步时执行代码元素.事件 = abc; //当事件发生时执行该函数 注意：事件调用函数后面没有括号，使用括号会出错，原因会在后面说明 匿名函数：没有名字的函数，使用方法： 123元素.事件 = function ()&#123; 代码块......&#125; 注意：由于匿名函数没有函数名，因此不能直接调用，一般是用在事件调用及后面的传参、闭包等地方 当很多地方需要反复使用一段代码的时候，我们应该声明一个有名函数；若只在一个事件使用的函数则可以使用匿名函数 onload是加载事件，可用在一个图片或者body等对象加载上。我们在开头的地方说过JS的代码可以放在head或body里，但是我们刚才用来获取元素的方法如果放在head里，输出的元素却找不到了。原因就是html文件是同步代码(顺序执行)，当读取到获取元素时，实际HTML中的元素并不存在，解决方法：1、将放在head里的script中的代码包在一个函数内，在&lt;/body&gt;前script里调用(不推荐)；2、将放在head里的script中的代码放在window的onload的事件里执行(推荐)；3、把script标签放在&lt;/body&gt;前，这样还可以提高用户体验(推荐) 属性操作 其实我们获取的页面中的元素就是对象(对象：就是带有属性和方法的特殊数据类型)，而元素也就是标签本身就是有属性的如：&lt;input id=&quot;btn1&quot; type=&quot;button&quot;/&gt; 属性名(id和type)，属性值(btn1和button)； 12元素.属性; //读：获取某元素属性的值 元素.属性 = "新值"; //写：替换某元素属性的值 注意：“读”的值都是字符串类型；“写”是替换操作，不是添加，因此原值会消失 元素的内容，语法： 12元素.innerHTML;元素.innerHTML = "新内容" 注意：内容包括子元素，所以“写”的时候可以用来加入新元素 元素的值，语法： 12元素.value;元素.value = "新内容" 元素的样式，语法: 12元素.style.样式 = "新值";元素.style.cssText= 'width:200px'; //注意该写法里面的值和css的写法相同 注意：这两种方法都会把样式加在元素的行间样式中，而获取样式时，获取的也是行间样式，它不会去计算当前样式，因此一般只用来“写”不用来“读”；另外js里不能出现”-“，因此第一个方法中background-color需写成backgroundColor，第二个由于写法和css相同，因此不用修改 “[]”的一种用法类似”.”，由于”.”后面的值不能变(如.style.width的width不能用变量)，因此在需要我们用变量的时候会用到”[]”： 12元素.style.width; //用"."的写法元素.style["width"]; //用"[]"的写法，"[]"里可以是变量 注意：”[]”里如果是属性，必须加双引号；如果是变量，不可以加双引号 练习： ​ 1.做一个下拉框效果，鼠标点击按钮时，在该元素下显示一个下拉框区域 ​ a. HTML部分： 12&lt;button id="btn"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 150px; height: 60px;&#125;div&#123; width: 150px; height: 400px; background-color: red; display: none;&#125; ​ c. JS部分： 12345var oBtn = document.getElementById("btn");var oDiv = document.getElementById("div1");oBtn.onclick = function ()&#123; oDiv.style.display = "block";&#125; ​ 2. 设置css和选择器 1.box&#123;width:150px; height:150px; background-color: red; &#125; 页面中设置一个textarea、button和div，在点击button时，将带有class(box)的div元素在页面的div里创建出来，即点击按钮时，将文本域中的值在div1的内容中展示出来 ​ a. HTML部分： 12&lt;textarea name="" id="te" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;button id="btn"&gt;按钮&lt;/button&gt; ​ b. CSS部分： 1.box&#123;width:150px; height:150px; background-color: red; &#125; ​ c. JS部分： 123456var oDiv = document.getElementById("div1");var oText = document.getElementById("te");var oBtn = document.getElementById("btn");oBtn.onclick = function ()&#123; oDiv.innerHTML = oText.value;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习要求和基本语法]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B1%82%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js的组成 尽管ECMAscript是一个重要的标准,但它并不是JavaScript的唯一的部分，当然，也不是唯一被标准化的部分。 实际上，一个完整的JavaScript实现是由一下3个不同的部分组成的。 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) DOM和BOM就是前文说到的浏览器大战而产生的拥有大量不兼容的地方 js是什么 简单来说，JavaScript是一种可以用来给网页增加交互性的编程语言。也常被称为”脚本语言”。 学习它有很多用途和好处： 所有主流浏览器都支持JavaScript 基本所有的网页都会用到JavaScript 可以让网页呈现各种动态效果 不需要安装环境(浏览器都支持)，有文本编辑器就可以编写JavaScript代码 js的学习要求 非必要条件：数学功底，英文功底，其他程序语言的基础 必要条件：HTML+CSS2基础好，尤其CSS2的样式使用要求灵活 主观条件：多去网上看，多思考别人的方法，多练习实现效果。如何布局，如何设置脚本 例如让一个元素移出我们的视线的方法，而我们往往必须想到在当前条件下哪种是最优的选择： 设置透明度opacity为0 用visibility或display隐藏元素 用position和偏移值定位出可视区 width \ height设置为0，并溢出隐藏 js引入html和输出 html中的js代码必须放在script标签里面，script标签可以放在页面中head和body标签中。 一行结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束； “hello world!”是一串字符串，“//”是单行注释 &lt;/script&gt;这里结束JavaScript，并告诉浏览器后面的代码是html代码了： 123&lt;script&gt; document.write(&quot;hello world!&quot;); //获得文档窗口并在其中写入&quot;Hello, world!&quot;&lt;/script&gt; 注意：每行结尾的分号可有可无，好的代码编写习惯是加入分号，这会增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。 我们需要让多个html页面共享一个脚本时就把脚本保存到外部文件中。外部文件扩展名是.js。使用时在&lt;script&gt; 标签的src属性中设置该文件的路径。如： 1&lt;script src="myScript.js"&gt;&lt;/script&gt; 注意：外部JavaScript文件中不能出现&lt;script&gt;标签(标签都是html语言) 输出数据方式除了document.write外还有下面两个方法： 12alert("hello world"); //弹出一个确认框，里面显示"hello world"console.log("hello world"); //在控制台打印"hello world" 注意：控制台里输出的字符串和其他数据的颜色不同。 js语法特征 注释与Java，C相同，支持单行注释 //；与多行注释/…/ 变量是用于存储信息的容器，JavaScript区分大小写，a和A是两个不同的变量 js的变量是弱类型的，定义变量只用var运算符，可以将它初始化为任意值，也可以随时改变变量所存数据的类型，可以用“,”将多个变量定义在一个var中，如： 12345var color = "red"; //声明了一个字符串类型变量，但不需要声明其类型color = 16; //弱类型语言，在这里将color的值从字符串改成了数字var num = 25; //等号"="叫做赋值操作，意思是将等号右侧的值赋给左侧var visible = true;var a = "5", b = 5; //一个var声明了2个变量 注意：由于js引擎会在出错时自动停止，因此我们可以将上面alert输出方法逐行放置，如果alert未执行，说明上面的代码有错误。初学者应养成随时写随时测试的习惯，以防做完一堆代码都是不能用的。 js变量的命名规则 没人天天叫毕加索的全名，js里也可以用一个名字储存数据，将事件加在名字上可以大大减少代码量 变量的命名规则：变量必须以字母开头；虽然变量也能以$和_符号开头(不过不推荐这么做)；变量名称也对大小写敏感(a和A是不同的变量)。 变量使用var关键字声明：var 名字 = ，后面可以是数字，字符串或者一个对象等等 好的代码编写习惯是总是用var声明变量的，并且始终存放相同类型的值，常用的命名规则： Camel标记法：首字母是小写的，接下来的单词都以大写字母开头。 Pascal标记法：首字母是大写的，接下来的单词都以大写字母开头。 匈牙利标记法：在以Pascal标记法命名的变量前附加一个小写字母说明该变量的类型。如比较常用的:i表示整数；s表示字符串；b代表boolean值；o代表对象；a代表数组或集合]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的概述和历史]]></title>
    <url>%2F2019%2F07%2F19%2Fjavascript%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[JavaScript作为赋予网页活力与交互性的主要手段之一，已成为web设计师和开发人员的必备技能。但它诞生时其实是个屌丝，没有想到发展到如今的地位 JavaScript是被人误解和误用最多的主流编程语言，很多人将它看作Java等面向对象语言的功能不全的小兄弟。随着越来越多的程序员转向浏览器/服务器模式开发，加上WEB2.0和Ajax的兴起，人们开始认识到，JavaScript绝非一种容易学习和掌握的技术，它具有面向对象，过程和函数型语言三类语言的特性，灵活性与强大功能完美结合，迄今为止，它的潜力远远没有正真释放出来。 上古时代的浏览器Netscape中，主要是些丑陋的静态文本和简单的图片， 和现在的页面相比，差的实在太远了。 当互联网刚开始兴起时，用户的数据需要全部在服务器端处理，这在网速非常慢的当时使用户的上网体验非常痛苦。Brendan Eich( JavaScript的发明人)有一回注册用户，由于忘了填写性别，等待了38秒后服务器告诉了他。他很崩溃：”这么简单的问题浏览器不会告诉我，还得把数据提交到几千公里外的服务器在那里检查才能发现问题吗！”。于是他向老板反馈问题，老板说： “我也早有此意，你来设计一个类似java的脚本吧”，老板对java非常感兴趣。Brendan Eich对java 毫无兴趣，但为了应付公司的任务，他花了10天设计出个脚本语言，由于设计时间太短，一些细节考虑得不够严谨。 如果他能预见到未来这种语言会成为互联网第一大语言，全世界有成千上万的学习者，他一定会多花一点时间吧。1995年Natscape公司决定在即将发行的Netcape Navigator2.0中加入一个称之为LiveScript的脚本语言，用于客户端数据验证。 后来NetScript与SUN公司联手完成LiveScript实现，就在Netcape Navigator2.0即将发布前，Netscape将其更名为JavaScript，目的是为了利用Java这个因特网当时的时髦词汇，Netscape的赌注最终得到了回报，JavaScript从此变成了因特网的必备组件。Brendan Eich最初遇到的问题简直就是小菜一碟了， 做个简单的表单验证，就解决问题了。 除此以外JavaScript 还可以操作DOM树。有了这棵树，它可以定位到DOM树中任意一个节点， 然后对这个节点进行操作，例如隐藏节点、显示节点、改变颜色、获得文本的值，改变文本的值，添加一个响应点击事件的函数等等，几乎为所欲为。这些操作可以立刻展示出效果来，你完全不用刷新网页。这些操作完全是内部进行的，html源码并不会改变，所以有时候你打开html源码，会发现这些源码和你在浏览器中看的效果并不一致，那就是JavaScript在背后改变了这个DOM树了。 JavaScript还能控制浏览器，比如打开窗口，在一个窗口内前进、后退，获得浏览器的名称，版本等等。为啥要获得浏览器的名称和版本呢？因为JavaScript1.0的成功，Netscape在它的3.0版本中发布了1.1版，恰巧那个时候，微软决定进军浏览器，发布了IE3.0并搭载了一个JavaScript的克隆版，叫做Jscript(这个命名是为了避免与NetScape潜在的许可纠纷)，微软步入Web浏览器领域的这重要一步虽然令其声名狼藉，但也成为了JavaScript语言发展过程中的重要一步。 在Netscape 和IE 进行浏览器之战的期间，他们都争相在自己的浏览器中支持Javascript，并且为了锁定程序员，还开发了很多自己浏览器的独特功能，有些功能只能在IE用，有些只能在Netscape 用，所以必须的判断是什么浏览器，这样才能特殊处理。不管怎么说，这些功能让浏览器中的网页变的更加动态了，更加有趣好玩了。 在微软进入后，有3个不同的JavaScript版本同时存在：JavaScript，Jscript以及ScriptEase，当时JavaScript并没有一个标准来统一其语法或特性。因此在1997年，JavaScript1.1作为一个草案提交给欧洲计算机制造商协会(ECMA)，第39技术委员会(TC39)被委派来”标准化一个通用、跨平台、中利于厂商的脚本语言的语法和语义” 。 由来自Netscape，Sun，微软、Borland和其他一些对脚本编程感兴趣的公司的程序员组成的TC39锻炼出了ECMA-262，该标准定义了叫做ECMAScript的全新的脚本语言，从此Web浏览器就开始努力将ECMAScript作为JavaScript实现的基础。 互联网的发展超出了所有人的预料，JavaScript被应用在几乎每一个网站上，但它只能在浏览器中运行，没法像java 那样访问网络，也就没有办法调用服务器端的接口来获取数据。用户只能通过GET或者POST向服务器发送请求，这时候服务器返回的数据是整个页面，而不是页面中的一个片段，也就是说整个页面都得刷新一遍，哪怕是页面中只有一个文字的改变。 1998年，IE5中引入一个新的功能：XMLHttpRequest，这个新功能将允许JavaScript直接向服务器发出接口调用。这个过程就是访问一下服务器端处理登陆的接口，IE5先干别的事儿，JavaScript得到服务器端的返回数据以后，用下IE5的这个函数。这其实就是异步调用，如果服务器处理和网络速度都足够快的话，用户就会发现：咦，我没有刷新整个页面，竟然已经登录了啊。IE都没有料到，这个功能带来了一场革命：这种方式可以使得网页局部刷新，让用户浏览网页的体验极佳，尤其是Google 地图，Gmail 等应用让互联网应用火了起来。其他浏览器也迅速跟进，实现了类似功能，各种各样交互性极佳的网站如雨后春笋般出现。之后桌面应用慢慢的都被搬到了互联网上。上面的那种处理方式称为AJAX即”Asynchronous Javascript And XML”(异步的JavaScript和XML)，异步问题解决了，但是XML真正的数据很少，标签反而占了大头，把数据都给淹没了。 Javascript的语法，里边有个叫对象的东西, 它有一个花括号，在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义，属性由逗号分隔。这种结构完全可以表达上面的xml内容。而且还支持数组，这样表达多个对象也不在话下。更重要的是，如果采用这种结构， Javascript根本不用什么XML解析器去解析了，它就是Javascript语言的一部分。直接拿来用即可。这种简洁的格式叫做JSON, 并且和服务器约定，都用JSON来传输数据。 HTML结构层，CSS样式层，而Javascript (加上AJAX, JSON)行为层。前端编程三个部分形成了。ExtJS, prototype, JQuery这些框架把前端编程推向另外一个高峰。甚至出现了AngularJS ，实现了SPA(单一页面应用程序)。但Javascript依然只能在浏览器和网页上。这也是为什么总有的人将Javascript被贬为雕虫小技，对它不屑一顾。但在Javascript发明十几年以后，又一位大牛Ryan Dahl于2009年把Javascript放到了服务器端，这就是node.js。越来越多使用node.js的网站证明， javascript的确可以在服务器端立足，并且有一个巨大的优势：前端和后端都用javascript！]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端CSS3选择器和常用样式]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFCSS3%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSS3基础 说明：CSS3完全向后兼容，浏览器永远支持CSS2，CSS3就是CSS2的扩展版，W3C的CSS3规范虽然仍在开发，但许多新的CSS3属性已在现代浏览器中使用。主要包含：选择器、盒模型、背景和边框、文字特效、2D/3D转换、动画、多列等 CSS3属性选择器​ 以&lt;input type=&quot;text&quot;&gt;为例 input[type] ：只使用属性名，但没有确定任何属性值 input[type=&quot;value&quot;] ：指定属性名，并指定了该属性的属性值 input[type~=&quot;value&quot;] ：指定属性名，并且具有属性值，此属性值是一个以空格隔开的词列表，词列表中包含了一个value词 input[type^=&quot;value&quot;] ：指定了属性名，并且拥有属性值，属性值是以value开头的 input[type$=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type*=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type|=&quot;value&quot;] ：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn） CSS3伪类 （常用）E:nth-child(n) ：表示E父元素的第n个子节点，且类型为E 特殊值：odd(匹配奇数行)等价于2n+1 even(匹配偶数行)等价于2n(下面的其他选择器同理) （常用）E:nth-of-type(n) ：表示E父元素的第n个E子节点 E:nth-last-child(n) ：表示E父元素的第n个子节点，从后向前算，且类型为E E:nth-last-of-type(n) ：表示E父元素的第n个E子节点，从后向前算 E:first-child ：表示E父元素中的第一个子节点，且类型为E，等价于E:nth-child(1) E:last-child ：表示E父元素中的最后一个子节点，且类型为E，等价于E:nth-last-child(1) E:first-of-type ：表示E父元素中的第一个E子节点，等价于E:nth-of-type(1) E:last-of-type ：表示E父元素中的最后一个E子节点，等价于E:nth-last-of-type(1) E:empty ：表示E元素没有子节点。注意：包含文本节点 E:only-child ：表示E父元素中只有一个子节点。注意：不包含文本节点 E:only-of-type ：表示E父元素中只有一个子节点，且这个唯一的子节点的类型必须是E。注意：不包含文本节点 E:target ：表示当前的URL片段的元素类型(id被a的href链接并被点击，也就是锚点——访问的a标签的链接为某元素的id)，这个元素必须是E E:disabled ：表示不可点击(获取焦点)表单控件 E:enabled ：表示可点击(获取焦点)的表单控件 E:checked ：表示已选中的checkbox或radio E:not(s) ：表示E选中的元素中的s不被匹配(s是标签名) E~F ：表示E元素毗邻的所有F元素(之后的所有同级元素，类似于nextAll())，下一个F元素则要用”+” 举几个例子~ 锚点和激活锚点（第12条）： ​ 题目：设置3个div盒子(150*150,红)，设置3个a标签，div盒子和a标签内容分别为div1,div2,div3 ​ 要求：1. 激活锚点：当点击a标签的内容时，跳转到对应的div盒子所在位置； ​ 2. 当div元素的锚点被激活时，背景颜色变为蓝色 ​ 提示：激活锚点：a标签的href里是#div（也就是div元素的id值） a. HTML部分： 123456&lt;a href="#div1"&gt;div1&lt;/a&gt;&lt;a href="#div2"&gt;div2&lt;/a&gt;&lt;a href="#div3"&gt;div3&lt;/a&gt;&lt;div id="div1"&gt;div1&lt;/div&gt;&lt;div id="div2"&gt;div2&lt;/div&gt;&lt;div id="div3"&gt;div3&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122232425262728293031323334/* 为了展示跳转效果，特意给body设置高度 */body&#123; height: 4000px;&#125;/* 设置div盒子的样式 */div&#123; width: 150px; height: 150px; background-color: red; position: absolute; font-size: 50px; color: white;&#125;/* 分别定位每个div盒子的位置（也是为了展示跳转效果） */div:nth-of-type(1)&#123; left: 0; top: 500px;&#125;div:nth-of-type(2)&#123; left: 0; top: 1500px;&#125;div:nth-of-type(3)&#123; left: 0; top: 1800px;&#125;di:nth-of-type(4)&#123; left: 0; top: 2000px;&#125;/* 当div元素的锚点被激活时，背景颜色变为蓝色 */div:target&#123; background-color: blue;&#125; 表单伪类（第13条）：设置一个不可点击的表单控件 a. HTML部分： 1&lt;input type="text" disabled&gt; ​ b. CSS部分： 123input:disabled&#123; border: 1px blue solid;&#125; CSS3伪元素 E::first-line ：表示E元素中的第一行 E::first-letter ：表示E元素中的第一个字符 E::selection ：表示E元素在用户选中文字时(moz) 举个例子~ ​ 题目：设计一个p标签，文字随意 ​ 要求：第一个字大小为30px，第一行文字颜色为蓝色，当用户选中文字时选中的背景颜色变为绿色且被选文字颜色为橘色 ​ a. HTML部分： 123&lt;p&gt; 语文老师说：“如果你越来越冷漠，你以为你成长了，但其实没有。长大应该是变得温柔，对全世界都温柔。”&lt;/p&gt; ​ b. CSS部分： 123456789101112131415161718/* 设置p标签的样式 */p&#123; width: 300px; border: 1px #000 solid;&#125;/* 设置第一个字的大小 */p::first-letter&#123; font-size: 30px;&#125;/* 设置第一行文字的颜色 */p::first-line&#123; color: blue;&#125;/* 当用户选中文字时的样式变化 */p::selection&#123; background-color: green; color: orange;&#125; 练习1： 做一个商品列表（12个），要求4行一列，每两个商品(100*100)之间需要有间距(10px)，但是商品与边界之间无间距 a. HTML部分： 123456789101112131415&lt;!-- 设置12个li --&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ​ b. CSS部分： 123456789101112131415161718ul&#123; /* 引入common.css后，宽度要加上2px的边框 */ width: 432px; border: 1px #000 solid; /* 清浮动 */ overflow: hidden;&#125;li&#123; background-color: red; width: 100%; height: 100px; float: left; margin: 0 10px 10px 0;&#125;/* 商品与边界之间无间距 */li:nth-of-type(4n)&#123; margin-right: 0;&#125; 模拟单选和多选框 a. HTML部分： 123&lt;!-- 加span标签 --&gt;&lt;label&gt;&lt;input type="radio" name="sex"&gt;&lt;span&gt;&lt;/span&gt; 男&lt;/label&gt;&lt;label&gt;&lt;input type="radio"&gt;&lt;span&gt;&lt;/span&gt; 女&lt;/label&gt; ​ b. CSS部分： 123456789101112131415161718192021/* 这样设置没作用 *//* input[type="radio"]&#123; width: 50px; height: 50px; border: 1px red solid; &#125; */span&#123; display: inline-block; width: 10px; height: 10px; border: 1px red solid; vertical-align: middle;&#125;input[type="radio"]&#123; position: absolute; left: -9999px;&#125;/* 下一个同级元素span：+span */input[type="radio"]:checked+span&#123; background-color: red;&#125; CSS3新文本样式 文本阴影：text-shadow:x y blur color, … （x/y 横向偏移/纵向偏移 blur 模糊距离 color 阴影颜色）文本阴影如果加很多层，会很卡，如：text-shadow:2px 2px 4px black 注意：有多个阴影的先渲染后面的，再渲染前面的 叠加： 1text-shadow: 2px 2px 0px red, 2px 2px 4px green; 层叠： 1234color:red; font-size:100px; font-weight:bold; text-shadow:2px 2px 0px white, 4px 4px 0px red; 光晕： 123color:white; font-size:100px;text-shadow:0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de, 0 0 100px #ff00de, 0 0 150px #ff00de; 火焰： 12345text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-family:Verdana, Geneva, sans-serif; font-size:100px; font-weight:bold; color:white; 盒模型阴影：box-shadow:[inset] x y blur [spread] color ​ （ [inset]：投影方式(默认为外投影，inset为内投影)​ x、y：水平和垂直方向的阴影偏移​ blur：模糊半径​ [spread]：扩展阴影半径(先扩展原有形状，再开始画阴影)​ color：颜色 ） 举例~ ​ a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 1234567div&#123; width: 150px; height: 150px; background-color: red; margin: 150px auto; box-shadow: 10px 10px 2px 20px rgba(0,0,0,0.7);&#125; 定义文字排列方式(全兼容)：directionrtl ：从右向左排列；ltr ：从左向右排列注意：要配合unicode-bidi:bidi-override; 一块使用 1234/* 文字从左向右排列 */.ltr p&#123;direction:ltr;unicode-bidi:bidi-override;&#125;/* 文字从右向左排列 */.rtl p&#123;direction:rtl;unicode-bidi:bidi-override;&#125; 定义省略文本的处理方式：text-overflow clip ：无省略号 ellipsis ：省略号 注意：要配合overflow:hidden和white-space:nowrap一块使用 多列：将文本内容设计成像报纸一样的多列布局，集合样式：column column-width：指定列的宽度 column-count：要分的列数 column-gap：列之间的距离 column-rule：栏目间隔线由column-rule-style(hidden：定义隐藏规则/dotted：定义点状规则/dashed：定义虚线规则/solid：定义实线规则/double：定义双线规则)、column-rule-width和column-rule-color的集合成 calc()函数：用于动态计算长度值 ​ 注意：运算符前后都需要保留一个空格 ​ 例如：width: calc(100% - 10px) (父元素宽度-10px) 任何长度值都可以使用calc()函数进行计算 calc()函数支持 “+”, “-“, “*”, “/“ 运算calc()函数使用标准的数学运算优先级规则 练习2： 阴影：给一个P标签做一个火焰效果 a. HTML部分： 1&lt;p&gt;最美的时光&lt;/p&gt; ​ b. CSS部分： 1234567p&#123; font-weight: bold; text-align: center; text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-size:100px; font-weight:bold; color:white;&#125; 做《静夜思》的文字布局（从右向左，从上到下） a. HTML部分： 1&lt;p&gt;床前明月光疑是地上霜举头望明月低头思故乡&lt;/p&gt; ​ b. CSS部分： 123456789p&#123; font-size: 20px; width: 100px; /* 一共有4列 */ column-count: 4; /* 从右向左排列 */ direction: rtl; unicode-bidi: bidi-override;&#125; CSS3新样式 变形：包含旋转函数、倾斜函数、缩放函数、位移函数 旋转函数： 12transform:rotate() /* 旋转度数(deg) */transform-origin:x y /* 旋转基点 */ 倾斜函数： 123transform:skew() /* 斜切度数(deg) */transform:skewX() /* 水平方向倾斜 */transform:skewY() /* 垂直方向倾斜 */ 缩放函数： 123transform:scale() /* 缩放取值(正数、负数和小数) */transform:scaleX() /* 水平方向缩放 */transform:scaleY() /* 垂直方向缩放 */ 位移函数： 123transform:translate() /* 位移取值(像素值) */transform:translateX() /* 水平方向位移 */transform:translateY() /* 垂直方向位移 */ ​ 2. 过渡：transition集合样式(css3的动画的一种) 12345678transition-property：要运动的样式(all || [attr] || none)transition-duration：规定完成过渡效果需要多少秒或毫秒transition-delay：定义动画延迟多久开始transition-timing-function：运动速度曲线。 ease：(逐渐变慢)默认值；linear：(匀速)； ease-in：(加速)；ease-out：(减速)； ease-in-out：(先加速后减速)； cubic-bezier 贝塞尔曲线( x1, y1, x2, y2 )，可以百度一下贝赛尔曲线的图 圆角：border-radius 集合样式：border-top-left-radius/border-top-right-radius/border-bottom-right-radius/border-bottom-left-radius，也就是从左上角开始顺时针数 即，1-4个数字 / 1-4个数字：/前面是水平方向圆角，后面是垂直方向圆角，不加/指的两个方向圆角相同，如：border-radius: 10px/5px; 参数：各种长度单位都可以：px，%，…，%有时很方便，但宽高不一致时不太好参数个数1：四个方向都一样，border-radius: 一样参数个数2：对角，border-radius: 左上&amp;右下 右上&amp;左下参数个数3：斜对角，border-radius: 左上 右上&amp;左下 右下参数个数4：全部，顺时针，border-radius: 左上 右上 右下 左 边框图片：border-image(集合样式) 引入图片url ：border-image-source 切割图片(从外向内，可以是不带单位的数字或百分比)：border-image-slice 边框宽度(展示边框图片区域)：border-image-width 边框图像区域超出边框的量：border-image-outset 图片的排列：border-image-repeat 图片的排列方式：round 四舍五入，repeat 重复，stretch 拉伸 集合样式：border-image:url() s s s s/w w w w/o o o o repeat 练习3： 做一个可旋转的风车，用圆角做风车的叶片 a. HTML部分： 123456&lt;div class="wrap"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122.wrap&#123; width: 600px; height: 600px; overflow: hidden; margin: 0 auto; transition: 10s all linear;&#125;.wrap&gt;div&#123; width: 300px; height: 300px; background-color: red; float: left;&#125;.wrap&gt;div:nth-child(1),.wrap&gt;div:nth-child(4)&#123; border-radius: 0 90%;&#125;.wrap&gt;div:nth-child(2),.wrap&gt;div:nth-child(3)&#123; border-radius: 90% 0;&#125;.wrap:hover&#123; transform: rotate(1800deg);&#125; 用过渡做按钮1：做一个搜索按钮，在鼠标移入时慢慢出现一个=&gt;符号 a. HTML部分： 1&lt;div class="parent"&gt;搜索&lt;/div&gt; ​ b. CSS部分： 1234567891011121314151617181920.parent&#123; width: 120px; height: 40px; border: 1px #000 solid; text-align: center; line-height: 40px; font-size: 22px; border-radius: 20px;&#125;.parent::after&#123; display: inline-block; content: "=&gt;"; width: 0; opacity: 0; transition: all 0.3s linear;&#125;.parent:hover::after&#123; width: 25px; opacity: 1;&#125; 用过渡做按钮2：做一个立体按钮，在击中时显示下压效果 a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112div&#123; width: 80px; height: 35px; background-color: greenyellow; box-shadow: 0 8px 0 rgba(0,0,0,0.4); border-radius: 17px; transition: all 0.3s linear;&#125; div:active&#123; box-shadow: 0 1px 0 rgba(0,0,0,0.4); transform: translateY(7px);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端BFC和三栏式布局、SEO和服务器、HTTP]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFBFC%E5%92%8C%E4%B8%89%E6%A0%8F%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81SEO%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81HTTP%2F</url>
    <content type="text"><![CDATA[BFC(Block fomatting context) “块级格式化上下文”。是一个独立的渲染区域，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Box是CSS布局的对象和基本单位，一个页面是由很多个Box组成的。元素的类型和display属性，决定了这个Box的类型。 不同类型的Box，会参与不同的Formatting Context(一个决定如何渲染文档的容器)，因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且会参与 block fomatting context；(简称BFC) inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且会参与 inline formatting context；(简称IFC) Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会变成BFC区域 根元素 float属性不为none position属性值为absolute或fixed display属性为inline-block, table-cell, table-caption, flex, inline-flex overflow属性不为visible BFC的用法： 自适应两栏布局：左栏定宽左浮动，右栏不定宽overflow:hidden;(设置成BFC) 清除内部浮动：父元素设置overflow:hidden;(设置成BFC)，既之前我们用来清除浮动的方法之一 防止垂直 margin 重叠：其中一个元素外套一个div并设置overflow:hidden;(设置成BFC) 三栏式布局 三栏式布局是一种，两边盒子固定宽度，中间盒子自适应的布局 圣杯布局和双飞翼布局 父元素包含左中右三个盒子，分别左浮动，中间元素宽度100%(必须为第一个渲染) 用margin-left的负值将两边盒子拉上去和中间盒子同行(左边-100%，右边-右盒子宽度) 给父元素上清除浮动 父元素用左右padding为左右盒子留位置并用相对定位将左右元素移动到正确的位置上(圣杯) 给中间元素设置子元素，并给其左右margin为左右盒子留位置(双飞翼) 转义和框架标签 HTML的转义字符，网上可以找到转义字符的表(http://tool.oschina.net/commons?type=2) 通过&amp;XXXX的格式生成一个转义字符 原因是有部分字符无法直接在html里直接生成，如：空格 、&amp;符号、大于号&gt;、小于号&lt;、©符号等 做个练习~ 在页面中生成下面的句子： ​ 在页面里输入一个&lt;br /&gt;就可以实现换行了 ​ 在页面里输入&amp;nbsp;就可以实现空格&nbsp;效果了 ​ 在页面里输入&amp;copy;就可以实现&copy;符号了 123&lt;p&gt;在页面里输入&amp;lt;br /&amp;gt;就可以实现换行了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;nbsp;就可以实现空格效果了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;copy;就可以实现©符号了&lt;/p&gt; iframe：框架标签(在当前页面显示多个网页) scrolling：是否有滚动条，值为yes(有)/no(无)，默认为auto(需要的时候出现) frameBorder：是否有边框，值为正整数，默认为1，值为0时无边框 align：对齐方式 src：嵌套页面地址 width/height：嵌套页面区域的宽高 name：配合a的target属性值等于iframe的name，可以让a在超链接的跳转打开页面时在iframe区域打开 优点：解决加载缓慢的第三方内容图标和广告等的加载问题；iframe无刷新文件上传；iframe跨域通信 缺点：iframe会阻塞主页面的onload事件；无法被一些搜索引擎索引到；页面会增加服务器的http请求；会产生很多页面，不容易管理。 雪碧图和引入样式表 sprites(雪碧图)原理 首先把网页中一些背景图片整合到一张图片文件中(png格式) 用”background-image”引入图片；”background- repeat”禁止平铺；”background-position”精确定位背景 优点：减少网页的http请求次数，并防止切换图片出现的闪白；减少图片的字节数，解决图片命名上的困扰(对一张集合的图片上命名就可以了，不用对每一个小图片进行命名)；更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变 缺点：在宽屏，高分辨率的屏幕下的自适应页面，雪碧图如果不够宽，容易出现背景断裂；在开发的时候，需要通过photoshop或其他工具测量计算每一个背景单元的精确位置在维护的时候比较麻烦，如果页面背景有少许改动，一般就要修改整张合并的图片 @import：引入css样式表 1@import url(CSS文件路径地址); //语法 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 SEO 搜索引擎工作原理： 搜索引擎网站的数据库存储着海量的关键词，每个关键词对应着很多网址，收集这些数据的程序称之为“搜索引擎蜘蛛”或“网络爬虫”。 “爬虫”每天在互联网上分析提炼，找到对用户有用关键词便存入数据库；垃圾或重复信息就舍弃。 用户输入关键词时，搜索引擎就能检索出与关键字相关的网址。关键词又对应多个网址，就出现了排序的问题，与关键词最吻合的网址就会排在前面。 并不是所有语言“爬虫”都能看懂。flash和js它便看不懂，即使关键字再贴切也没用。而网站内容是它的语言(SEO)，它便能看懂。 SEO简介 Search English Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 SEO就是为了提升我们的网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。 白帽SEO起到改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。 黑帽SEO利用和放大搜索引擎政策缺陷来获取更多用户的访问量，大多是欺骗搜索引擎，这是搜索引擎公司是不支持与鼓励的。 白帽SEO怎么做：对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；网站内容优化：内容与关键字的对应，增加关键字的密度；在网站上合理设置Robot.txt文件(保障网络安全与网站隐私，里面规定了哪些不予许“爬虫”搜索)；生成针对搜索引擎友好的网站地图；增加外部链接，到各个网站上宣传； 前端SEO：通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“爬虫”看懂。 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。建立的网站结构层次越少，越容易被“爬虫”抓取； 控制首页链接数量：链接太少会使“爬虫”缺乏往下爬的“桥”，影响收录数量；链接太多，影响用户体验，降低了网站首页权重，效果也不好。尽量让“爬虫”最多跳转3次，就能到达网站内的任何一个内页。 导航优化，尽量采用文字，如果用图片代码一定要添加“alt”和“title”属性(图片未能正常显示时用户也能看到提示)。另外每个网页上应该加上面包屑导航(如新闻&gt;某新闻) 网站的结构：头部——logo及主导航，以及用户的信息；页面主体——一边面包屑导航及正文；一边放热门文章及相关文章，这些相关链接增强了页面相关性，也增强页面的权重；页面底部——版权信息和友情链接；分页写法——“首页 1 2 3 4 5 下拉框”，这样“爬虫”能直接跳转，下拉框直接选择页面；而“首页 下一页 尾页”的写法，当分页数量特别多时，“爬虫”需要经过很多次往下爬，才能抓取，超时容易放弃。 控制页面的大小，减少http请求，提高网站的加载速度。页面最好不要超过100k，太大页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“爬虫”也会离开。 网页代码优化：除了精简代码外还要有以下设置 meta keywords标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌；meta description标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 title标签，强调重点，把重要的关键词放在前面且不要重复出现，每个页面的title标题中不要设置相同的内容；body的标签：代码语义化，适当的位置使用适当的标签。让阅读源码者和“爬虫”都一目了然。比如：h1-h6 是用于标题类的，nav标签是用来设置页面主导航的等。 a标签：页内链接要加 “title” 属性说明，让访客和 “爬虫” 知道。外部链接，则需要加上 el=”nofollow” 属性, 告诉 “爬虫” 不要爬，否则它就不会再回来了；br标签：只用于文本内容的换行；img应使用 “alt” 和”title”属性加以说明 正文标题要用h1标签：“爬虫”认为它最重要，副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签；表格标签用caption strong和em标签：需要强调时使用。strong在搜索引擎中会得到高度重视，它突出关键词表现重要的内容，em强调效果仅次于strong。b和i标签: 只是显示效果，在SEO中不会起任何效果。 文本缩进不要使用特殊符号，应使用CSS进行设置；版权符号不要使用特殊符号，可以直接使用输入法中的版权符号©；对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。搜索引擎会过滤掉display:none中的内容。 巧妙布局，将重要内容的代码放在前面，前面的内容被认为是最重要的，优先让“爬虫”读取，进行内容关键词抓取。 少使用iframe框架,因为“爬虫”一般不会读取其中的内容；重要内容不要用JS输出，因为“爬虫”不认识；js代码如果是操作DOM操作，应尽量放在body结束标签之前，html所有标签之后。 Server-Browser技术 WEB的三要素：直接打开的html文件并没有经过WEB的三要素，正式项目时需要安装环境 Server(服务器) Client(客户端)/Browser(浏览器) HTTP(传输通信)/HTTPS(加密传输) 客户端技术：HTML/CSS/JS和图片等，储存于服务器，供客户端申请下载，在服务器看来他们只是二进制的字符，服务器不会对这些内容做任何处理 服务器端技术：JSP/PHP/ASP.NET，储存于服务器，供客户端进行请求，但返回客户端之前，其中的代码会在服务器端获得执行，得到的结果是纯的静态数据，发送给客户端。 服务器(Server)：是网络环境中的高性能计算机，它侦听网络上的其他客户机提交的服务请求，并提供相应的服务，如”域名解析”、”文件下载”、”网页浏览”、”邮件收发”等等。 要求：高可用性、高速运算、高带宽、高可靠性、强大的数据吞吐能力。 Client-Server模型(C/S模型)：如QQ客户端 Brouser-Server模型(B/S模型)：如谷歌浏览器 随着H5和前端的发展，B/S会部分取代C/S，因为只需要在服务器端更新就可以立即使用最新版 硬件服务器：按大小可以分为工作站、小型机、中型机、大型机、超级计算机。 软件服务器：不论是超级计算机、小型服务器、还是PC机，为了向客户端提供服务，必须安装能够监听特定端口，并接受客户端请求的应用程序–服务器应用程序。根据能投提供的服务的不同，服务器应用程序包括： DNS服务器：把域名解析为计算机的IP地址 Web服务器：提供Web页面服务 数据库服务器：提供数据的永久储存和高效查询 FTP服务器：文件上传和下载服务 SMTP/POP3服务器：邮件收发服务 SSH服务器：远程登录服务 Samba服务器：文件和打印机共享服务 如何访问服务器：客户端访问网络上的一台服务器，必须提供如下信息——访问协议：类似两个人通话必须先确定所说的语言；主机地址：服务器的域名或IP地址；端口号：一台计算机上可能提供多种服务，不同服务使用不同端口；除此之外，有的服务还可能需要客户端提供用户名/密码、资源路径，请求参数等。 配置服务器环境 AMP–集成了Apache, PHP5, 和MySQL 浏览器服务器文件localhost/文件.txt，这种方式和用路径在浏览器上打开的方式是不同的，前者是在服务器上 很多东西必须在服务器上运行，如cookie和ajax等 超文本传输协议(HTTP，HyperText Transfer Protocol) HTTP协议是互联网应用最为广泛的一种网络协议。设计它的最初目的是为了提供一种发布和接收HTML页面的方法。 只要上网就要用到它，比如我们登录百度页面就要使用HTTP请求百度页面的数据，同时要遵守HTTP协议的语法和规则。 HTTP是两台电脑(服务器和客户端)之间的通讯，客户端发起请求(通常是用域名)，服务器响应请求(发送页面数据)。 下面是客户端和服务器在发起HTTP协议时的详细过程： 第一步，先建立服务器和客户端的TCP的握手。 第二步，客户端向服务器发出文本数据，如：POST //发送请求的方法；index.html //请求的页面；HTTP/1.1 //HTTP的版本 还有请求的报头和它的值如：HOST: www.baidu.com //域名；Connection: //服务器发送数据后的链接状态；User_agent: Mozilla/4.0 //浏览器；Accept-language: zh-CN //语言 以及报体(get请求不需要报体)，如：Name=unknow&amp;age=22 //内容 第三步，服务器响应结果：HTTP/1.1 //HTTP的版本；200 ok //状态码和文本描述 以及响应的报头和它的值如：Server: Apache-Coyote/1.1 //域名；Last-Modified: Thu， 24 Nov 2011 12::22:00 GMT //最后修改时间；Content_Type: text/html;charset=GB18030 //使用的字符集；Content-Language: zh-CN//语言；Content-Length: 23980 //内容大小；Date: Fri, 25 Nov 2011 07:22:02 GMT //时间 最后空一行之后是它的报体(html页面)：…… HTTP详解：https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html 上传一个网站 我们需要一个网上的服务器(需要花钱租用，比如西部数码、阿里云、腾讯云等等) 准备一个网站项目，并用FTP软件将它上传到该服务器上 在FTP软件的快速连接里输入服务器的地址，并通过用户名和密码连接到服务器上，然后上传你的项目 准备一个自己的域名，并将其绑在我们的服务器上，这样在互联网上打开该域名就会自动打开项目中的index.html了 个人网站也是需要备案的，这里是个人网站详细的备案过程]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-八、VIM程序编辑器]]></title>
    <url>%2F2019%2F07%2F18%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AB%E3%80%81VIM%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[八、VIM程序编辑器 作用：是一种打开文本文件的程序，可以编辑改文件已达到配置服务的功能 分类： (1) vi ：任意版本的Linux自带的程序编辑器 (2) vim ：是vi程序编辑器的加强版，通过附加一系列功能（如：字体、字体颜色、扩展接口等）帮助运维人员更好的配置服务 注意：vim若在最小化镜像安装系统时不会安装，可以使用：yum install -y vim 命令进行安装 打开文件方法： (1) 格式：vim 格式名 (2) 若文件已存在直接打开，若不存在会新建文件后打开 vim 的三种模式： (1) 命令模式：又称为只读模式，在该模式可以进行光标移动，查看等动作 (2) 插入模式：编辑模式，插入、删除等内容 (3) 末行模式：保存、退出、设置编辑环境 (4) 模式切换： ​ A. 命令模式点击“i”键进入插入模式，插入模式点击“ESC”键返回到命令模式，命令模式下单击shirt : 进入末行模式，末行模式点击ESC键返回命令模式 ​ B. 图： 命令模式： (1) 常用功能键： ​ A. yy ：复制本行 ​ B. 5yy ：复制5行 ​ C. p ：粘贴 ​ D. dd ：删除当前行 ​ E. 3dd ：删除3行 ​ F. /字符串：由上到下搜索字符串 ​ G. ?字符串：由下向上搜索字符串 ​ H. n ：显示搜索定位到下一个字符串 ​ I. N：显示搜索定位到下一个字符串 ​ J. u ：撤销上一步动作 (2) 配置主机名： ​ A. 主机名：Linux主机在网络上显示的名称，应“见名知意” ​ B. 配置文件：/etc/hostname ​ C. 显示主机名命令：hostname ​ D. 编辑主机名： ​ (a) vim /etc/hostname ​ (b) 删除旧主机名后插入新主机名 ​ (c) 保存退出 ​ (d) reboot重启 (3) 配置网卡的静态IP地址： ​ A. vim /etc/sysconfig/network-scriipts/ifcfg-ens33 ​ B. 点击 i 键 ​ C.BOOTPROTO=static ：网卡类型为静态IP，动态IP为dhcp ​ D. 在最后一行插入以下内容： ​ IPADDR=192.168.10.200 （IP地址） ​ NETMASK=255.255.255.0 （子网掩码） ​ GATEWAY=192.168.10.1 （网关地址） ​ DNS1=8.8.8.8 （域名解析服务器地址） ​ E. 保存退出 ​ F. 重启网卡：service network restart ​ G. 查看网卡：ip addr 末行模式： (1) 功能命令 ​ A. 进入方法：shirt : ​ B. w ：保存 ​ C. q ：退出 ​ D. q! ：强制退出，不保存 ​ E. wq! ：强制保存退出 ​ F. set nu ：增加行号 ​ G. set nonu ：取消行号 ​ H. 数字：跳转到指定数字行 (2) 注意：大部分配置文件都需要root权限，否则无法保存 vim异常处理： (1) 制作异常环境： ​ A. cp /etc/fstab /root ​ B. vim /root/fstab ​ C. 点击dd删除某行 ​ D. 点击ctrl z ，强制终止进程 ​ E. vim /root/fstab 会有警告信息 (2) 处理流程： ​ A. 点击 R 进行恢复 ​ B. 点击shirt: 正常保存退出 ​ C. ls -a root 查看同名的隐藏缓存文件 ​ D. rm -f /root/.fstab.swp 删除同名缓存文件 ​ E. vim /root/fstab 正常打开 (3) 原理： ​ A. 原因1：可能有其他人或程序同时在编辑该文件 ​ B. 原因2：上一个vim环境中，可能因为某些不知名原因导致vim中断(crashed) shell脚本简介： (1) 本质：是一种纯文本的批处理文件 (2) 意义： ​ A. 自动化管理：批处理方式执行，降低维护工作量及难度 ​ B. 记录和管理系统工作：服务启动等功能 ​ C. 简单的入侵检测：通过编写脚本自动检测系统日志 ​ D. 简单数据处理：数据计算及分析 (3) 创建简单的脚本 ​ A. 方法：vim 脚本文件 ​ B. 脚本扩展名：.sh ​ C. 脚本执行过程： ​ (a) 由上到下、由左到右分析执行 ​ (b) 以行为单位进行执行，空行跳过 ​ (c) 命令过长时使用\enter进行换行编写 ​ (d) 以#开头的为注释命令，其只起到增加理解的功能，不执行 ​ D. 内容分析： ​ (a) 注释：# !/bin/bash ：表示该脚本使用的shell名称，不能省略 ​ # 脚本类别 ​ # 脚本功能简述 ​ # History ​ # 脚本编辑日期 作者 版本号等 ​ (b) 命令语句 (4) 执行脚本： ​ A. 方法1：bash 脚本名.sh ​ B. 方法2：chmod a+x 脚本名.sh ​ （增加权限如：chmod a+x /root/hello.sh） ​ ./脚本名.sh, (5) 注意：shell scripts在系统管理及自动化执行上作用很大，但是在数据处理应用上能力有限（如：bash的运算式只识别整数的运算），且运算的速度较慢CPU占用率较大，会造成主机资源负载较高 (6) 黑客帝国屏保代码： 123456789101112#!/bin/bash#program# install cmatrix#history# 2019-7-22 14:29 andy Version 1.0wget http://archive.ubuntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orig.tar.gztar xvf cmatrix_1.2a.orig.tar.gzcd cmatrix-1.2ayum install -y gccyum install -y ncurses-devel./configure &amp;&amp; make &amp;&amp; make installecho &quot;Program installation complete !&quot;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 七、RAID 与 LVM]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%83%E3%80%81RAID-%E4%B8%8E-LVM%2F</url>
    <content type="text"><![CDATA[七、RAID 与 LVM RAID (1) RAID : Redundant Array of Independent Disks，磁盘冗余阵列 (2) RAID意义：通过增肌多个硬盘，形成独立的硬盘组，将数据划分成多份，分散存储，以提高硬盘读写效率 (3) RAID本质：防止硬盘物理损坏及增加存储设备吞吐量 (4) 分类： ​ A. RAID0 ​ (a) 意义：原理：把至少2块硬盘通过硬件或软件方式串联，组成一个大的卷组，并将数据依次写入到各个硬盘中 ​ (b) 优点：数据同步传输，读取/写入分开，性能大大提升 ​ (c) 缺点：若任意一块硬盘故障会导致整个系统的数据损坏，无备份冗余能力、错误修复能力 ​ (d) 总结：使用率100%，至少2块硬盘才能使用，优点是快，提升磁盘的读写速度，缺点是不安全 ​ (e) 结构图： ​ ​ B. RAID1： ​ (a) 产生原因：若生产环境对硬盘的读写速度没有较大要求，但希望增加数据安全性时可使用RAID1 ​ (b) 原理：将至少2块硬盘并联起来，写入数据时，同时写入，多个硬盘内容相同 ​ (c) 本质：多个硬盘的镜像备份 ​ (d) 优点：备份冗余数据，安全性大大提升 ​ (e) 缺点： 硬盘利用率下降 ​ (f) 总结：本质是镜像，使用两块磁盘，一式两份的方式，支持容错，冗余，数据安全不丢失，缺点是速度不快，使用率50%，成本较大 ​ (g) 结构图： ​ ​ C. RAID5: ​ (a) 产生原因：兼顾“读写速度”、“数据安全”、“成本”的一种折中方式 ​ (b) 原理：需至少3块硬盘，将数据分块存储到不同硬盘中，硬盘中必须存储其他一个硬盘的parity（奇偶校验信息） ​ (c) 优点：兼顾性能，通过“奇偶校验”替代“镜像备份” ​ (d) 缺点：硬盘数据安全性较低 ​ (e) 总结：使用率(n-1)/n*容量，磁盘坏了会立即补上，数据会恢复 ​ (f) 结构图： ​ ​ D.RAID10：（主流） ​ (a) 原理：至少需要4块硬盘，先制作两两的RAID1阵列，以保证安全性，在两两制作RAID0，以提高读写速度 ​ (b) 本质：RAID1+RAID0的组合 ​ (c) 优点：兼具速度和安全性 ​ (d) 缺点：成本较高 ​ (e) 结构图： ​ (5) mdadm命令： ​ A. 过程： ​ (a) 关机添加4个新硬盘 ​ (b) mdadm命令建立RAID10 ​ (c) 格式化 ​ (d) 建立挂载目录 ​ (e) 挂载 ​ (f) 开机挂载 ​ (g) 查看信息 ​ B. mdadm命令格式： ​ mdadm -参数 &lt;RAID 设备名&gt; [模式] [成员设备名称] ​ C. 作用：建立或管理RAID ​ D. 参数： ​ (a) -a ：检测设备名称 ​ (b) -C ：创建RAID ​ (c) -v ：显示过程 ​ (d) -l ：指定RAID级别 ​ (e) -n ：指定硬盘数量 ​ (f) -f ：模拟设备损坏 ​ (g) -D ：查看详细信息 ​ (h) -r ：移除设备 ​ (i) -Q ：查看摘要 ​ (j) -S ：停止RAID磁盘阵列 ​ E. 例：添加4块硬盘，创建RAID10 ​ (a) 创建RAID10： mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde ​ -Cv ：创建RAID并显示过程 ​ -a yes ：检测创建设备名 ​ -n 4 ：4块硬盘参与建立 ​ -l 10 ：RAID级别为10 ​ (b) 格式化：mkfs.xfs /dev/md0 ​ (c) 建立挂载目录：mkdir /mnt/raiddev ​ (d) 挂载：mount /dev/md0 /mnt/raiddev ​ (e) 开机挂载设置：vim /etc/fstab ​ 增加行： /dev/md0 /mnt/raiddev xfs defaults 0 0 ​ (f) 开机挂载检测：mount -a ​ (g) 查看RAID10信息：mdadm -D /dev/md0 ​ F. 模拟硬盘损坏的处理流程 ​ (a) 模拟损坏：mdadm /dev/md0 -f /dev/sdb ​ (b) 查看信息：mdadm -D /dev/md0 ​ (c) 关机，添加新硬盘 ​ (d) 卸载RAID：umount /dev/md0 ​ (e) RAID补上新硬盘：mdadm /dev/md0 -a /dev/sdf ​ (f) 重启：reboot ​ (g) 查看信息：mdadm -D /dev/md0 ​ (h) 注意：添加新硬盘时必须先卸载 ​ G. 停止RAID ​ (a) 注意：在实际工作中，停止RAID前必须备份其中数据，否则数据会全部丢失 ​ (b) 过程： ​ ◆ 卸载设备：umount /dev/md0 ​ ◆ 删除开机挂载配置文件中RAID的记录 ​ ◆ 停止RAID：mdadm -S /dev/md ​ H. RAID 10备份盘功能 ​ (a) 产生原因：在RAID1中，某块硬盘损坏，在手工修复成功前另一块硬盘也同时损坏，则整个数据会全部丢失 ​ (b) 原理：在RAID10中再添加一块硬盘，作为备份盘，一旦某硬盘损坏，会自动修复 ​ (c) RAID共需5块硬盘（4个数据盘，1个备份盘） ​ (d) 方法： ​ ◆ 新建RAID10+备份盘：mdadm -Cv /dev/md1 -a yes -n 4 -l 10 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf ​ （-x 1 ：表示备份盘，1块硬盘） ​ （一般最后一块硬盘/dev/sdf 为备份盘，习惯放置在最后） ​ ◆ 查看信息摘要：mdadm -D /dev/md1 ​ ◆ 模拟某硬盘损坏：mdadm /dev/md1 -f /dev/sdb ​ ◆ 重启系统：reboot ​ ◆ 再次查看信息摘要：mdadm -D /dev/md1 ，备份盘/dev/sdf已替换故障硬盘 LVM（逻辑卷管理器） (1) 产生原因：由于硬盘分区并设置为RAID后，对其空间调整并不容易，此时用户随着实际的需求变化而动态调整硬盘分区大小时受到限制，无灵活性 (2) LVM作用：允许用户动态调整磁盘空间大小 (3) 原理：LVM是在磁盘分区与文件系统之间添加逻辑层，以提供一个抽象的卷组，使管理者可以忽略底层磁盘布局，从而实现对分区的灵活动态调整 (4) 分析： ​ A. 图： ​ ​ B. 物理卷（PV, Physical Volume）：整个硬盘或分区 ​ C. 卷组（VG, Volume Group）：由一个或多个物理卷（PV）组成的整体 ​ D. 逻辑卷（LV, Logical Volume）：从卷组（VG）切割出的空间，用于创建文件系统，大小由PE的个数决定 ​ E. 基本单元（PE, Physical Extent）：默认为4MB的基本块 (5) 基本命令： ​ (6) 硬盘支持LVM的流程： ​ A. 将新硬盘支持物理卷技术 ​ B. 创建卷组，将新硬盘加入卷组 ​ C. 根据需求切割出指定容量的逻辑卷 ​ D. 格式化逻辑卷 ​ E. 创建挂载目录 ​ F. 添加开机挂载信息 ​ G. 挂载测试 ​ H. 重启系统 (7) 例：在虚拟机中添加2块新硬盘，创建物理卷及卷组，划分出150MB空间的逻辑卷并格式化挂载使用 ​ A. 新建物理卷：pvcreate /dev/sdb /dev/sdc ​ B. 新建卷组：vgcreate /dev/vg1 /dev/sdb /dev/sdc ​ C. 查看卷组信息：vgdisplay /dev/vg1 ​ D. 切割150MB逻辑卷：lvcreate -n lv1 -L 150MB /dev/vg1 ​ (a) -n ：新建逻辑卷 ​ (b) -L：逻辑卷的容量，单位为数据量（K M G） ​ E. 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ F. 格式化逻辑卷：mkfs.xfs /dev/vg1/lv1 ​ G. 建立挂载点：mkdir /mnt/lvdev ​ H. 编辑开机挂载文件：vim /etc/fstab 增加下列记录： ​ /dev/vg1/lv1 /mnt/lvdev xfs defaults 0 0 ​ I. 挂载测试：mount -a (8) 例：添加2块新硬盘，建立卷组，划分出200MB空间的逻辑卷并格式化挂载使用 ​ A. pvcreate /dev/sdd /dev/sde ​ B. vgcreate /dev/vg2 /dev/sdd /dev/sde ​ C. vgdisplay /dev/vg2 ​ D. lvcreate -n lv2 -l 50 /dev/vg2 ​ (a) lv2的路径：/dev/vg2/lv2 ​ (b) -l ：表示以PE物理卷基本存储单位4MB为单位划分，给出4MB的倍数，50表示PE个数（50*4MB） ​ E. lvdisplay /dev/vg2/lv2 ​ F. mkfs.xfs /dev/vg2/lv2 ​ G. mkdir /mnt/lvdev2 ​ H. vim /etc/fstab 增加下列记录： ​ /dev/vg2/lv2 /mnt/lvdev2 xfs defaults 0 0 ​ I. mount -a (9) 逻辑卷扩容 ​ A. 作用：根据实际需要扩大逻辑卷的存储容量 ​ B. 过程： ​ (a) 卸载逻辑卷 ​ (b) 扩容逻辑卷 ​ (c) 再次格式化 ​ (d) 挂载 ​ (e) 查看信息 ​ C. 例1：对上例lv1逻辑卷扩容到495MB ​ (a) 卸载：umount /dev/vg1/lv1 ​ (b) 查看卷组容量是否足够：vgdisplay /dev/vg1 ​ (c) 扩容：lvextend -L 495MB /dev/vg1/lv1 ​ (d) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (e) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (f) 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：对上例lv2逻辑卷扩容到800MB ​ (a) umount /dev/vg2/lv2 ​ (b) vgdisplay /dev/vg2 ​ (c) lvextend -l 200 /dev/vg2/lv2 ​ (d) mkfs.xfs -f /dev/vg2/lv2 ​ (e) mount -a ​ (f) lvdisplay /dev/vg2/lv2 ​ E. 注意 ​ (a) 扩容或缩容之前必须先卸载设备 ​ (b) 扩容后的逻辑卷必须格式化，否则挂载后显示逻辑卷容量不变 (10) 逻辑卷缩容 ​ A. 注意 ​ (a) 逻辑卷缩容相对扩容来说会有数据丢失的风险，则缩容之前应备份数据 ​ (b) 对逻辑卷缩容之前应对逻辑卷进行数据完整性检查，以保证数据正确性、完整性 ​ (c) 逻辑卷缩容之前必须卸载设备 ​ B. 过程 ​ (a) 查看逻辑卷使用量及剩余量 ​ (b) 卸载设备 ​ (c) 逻辑卷数据完整性检查 ​ (d) 缩容逻辑卷 ​ (e) 格式化逻辑卷 ​ (f) 挂载逻辑卷 ​ (g) 查看逻辑卷信息 ​ C. 例：将上列lv1逻辑卷缩容到320MB ​ (a) 查看lv使用量：df -h /dev/vg1/lv1 ​ (b) 卸载设备：umount /dev/vg1/lv1 ​ (c) 对lv进行完整性检查：xfs_repair -n /dev/vg1/lv1 ​ (d) 缩容：lvreduce -L 320MB /dev/vg1/lv1 ，输入y确认 ​ (e) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (f) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (g) 查看lv信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：将上例lv2逻辑卷缩容到440MB ​ (a) df -h /dev/vg2/lv2 ​ (b) umount /dev/vg2/lv2 ​ (c) xfs_repair -n /dev/vg2/lv2 ​ (d) lvreduce -l 110 /dev/vg2/lv2 ，输入y确认 ​ (e) mkfs.xfs -f /dev/vg2/lv2 ​ (f) mount -a ​ (g) lvdisplay /dev/vg2/lv2 (11) 删除LVM ​ A. 删除顺序：逻辑卷-&gt;卷组-&gt;物理卷 ​ B. 注意： ​ (a) 删除时，上述顺序不能反向 ​ (b) 删除时，需要输入“y”来确认操作 ​ (c) 删除时，备份卷一同被删除 ​ (d) 删除之前必须先备份数据 ​ C. 过程 ​ (a) 卸载设备 ​ (b) 删除开机挂载记录信息 ​ (c) 删除逻辑卷 ​ (d) 删除卷组 ​ (e) 删除物理卷（去掉硬盘的物理卷技术支持） ​ (f) 查看卷信息是否还存在 ​ D. 例1：删除上例 lv1、 vg1 及物理卷技术 ​ (a) 卸载设备：umount /dev/vg1/lv1 ​ (b) 删除lv1开机挂载记录：vim /etc/fstab 删除其记录项 ​ (c) 删除逻辑卷：lvremove /dev/vg1/lv1 ，输入y确认 ​ (d) 删除卷组：vgremove /dev/vg1 ​ (e) 删除物理卷：pvremove /dev/sdb /dev/sdc ​ (f) 查看信息：lvdisplay vgdisplay pvdisplay （分别执行） ​ E. 例2：删除上例 lv2、vg2及物理卷技术 ​ (a) umount /dev/vg2/lv2 ​ (b) vim /etc/fstab ​ (c) lvremove /dev/vg2/lv2 ，输入y确定 ​ (d) vgremove /dev/vg2 ​ (e) premove /dev/sdd /dev/sde (12) 逻辑卷快照功能 ​ A. 作用：类似于虚拟机软件的“快照”，可以通过快照还原点进行还原，起到备份功能 ​ B. 注意： ​ (a) 快照卷的容量必须等于逻辑卷的容量 ​ (b) 快照卷只能恢复一次，恢复后会自动删除 ​ C. 过程： ​ (a) 查看卷组剩余容量是否足够 ​ (b) 查看被制作快照的逻辑卷容量 ​ (c) 制作快照卷 ​ (d) 查看快照卷 ​ (e) 测试恢复快照卷 ​ D. 例：创建 lv 逻辑卷，制作快照卷 ​ (a) 创建物理卷：pvcreate /dev/sdb ​ (b) 创建卷组：vgcreate /dev/vg ​ (c) 创建逻辑卷：lvcreate -n /dev/vg/lv -L 200MB /dev/vg ​ (d) 格式化：mkfs.xfs /dev/vg/lv ​ (e) 建立挂载点：mkdir /mnt/lvdev ​ (f) 挂载：mount /dev/vg/lv /mnt/lvdev ​ (g) 添加点文件：touch t1.txt ​ (h) 制作 lv 的快照卷：lvcreate -L 200MB -s -n SNAP /dev/vg/lv ​ (i) 进入逻辑卷：cd /mnt/lvdev ​ (j) 新建大文件：dd if=/dev/zero of=loop count=1 bs=10M ​ (k) 浏览文件：ls ​ (l) 退出挂载点：cd / ​ (m) 卸载设备：umount /mnt/lvdev ​ (n) 快照卷恢复：lvconvert –merge /dev/vg/SNAP ​ (o) 挂载设备：mount /dev/vg/lv /mnt/lvdev ​ (p) 进入逻辑卷查看文件是否存在：cd /mnt/lvdev ​ ls]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 六、磁盘管理]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AD%E3%80%81%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[六、磁盘管理 磁盘基础知识 (1) 概念：使用一片或多片带有磁性的铝合金制的盘片构成的外部存储介质 (2) 物理结构 ​ A. 盘体 ​ B. 磁头 ​ C. 马达驱动 ​ D. 缓存 ​ E. SATA3接口 ​ F. 电路板 (3) 逻辑结构 ​ A. 磁道：同心圆 ​ B. 扇区 ​ C. 柱面 (4) 硬盘参数 ​ A. 容量：1-4TB ​ B. 转速：7200转/分 5400RPM ​ C. 缓存：64MB-256MB ​ D. 接口：SATA3 / SCSI (5) 分区 ​ A. 主分区：系统启动区 ​ B. 扩展分区 ​ C. 逻辑分区：基于扩展分区继续划分 分区模式 (1) MBR（主引导记录区模式） ​ A. 组成 ​ (a) MBR位于磁盘第0磁道第0柱面第1扇区 ​ (b) MBR总容量：446B ​ (c) 磁盘分区表（DPT）：64B ​ (d) 最后有2B（55 AA）为分区结束标志 ​ (e) MBR所占扇区为512B ​ B. 作用：MBR包含硬盘一系列参数和一段引导程序，引导程序是检查分区表是否正确并且在系统硬件完成自检后引导具有激活标志的分区上的操作系统（C盘），并将控制权交给启动程序 ​ C. MBR分区原则 ​ (a) 主分区+扩展分区最多4个 ​ (b) 扩展分区最多1个 ​ (c) 扩展分区基础上再次划分逻辑分区 ​ (d) 扩展分区不能格式化 ​ (e) 一般会划分3个主分区+1个扩展分区 ​ (f) 主分区（P） 扩展分区（E） 逻辑分区（L） ​ (g) 推荐剩余一些自由空间以方便分区空间扩容 (2) GPT ​ A. 产生原因 ​ (a) MBR分区格式最大支持2.2TB硬盘 ​ (b) 没有备份机制，若分区表损坏则会丢失整个硬盘内容 ​ (c) MBR存储空间较小，只有446B，无法存储叫多功能数据 ​ B. 方法 ​ (a) 使用LBA（逻辑地址区块）的结构存储分区信息 ​ (b) 共可分为68个LBA块，前34个LBA存储分区信息，后43个LBA块存储备份信息 ​ C. GPT分区格式不再区分主分区及扩展分区，共可分128个主分区 ​ D. GPT分区格式与MDR分区格式不兼容，不能混合使用 文件系统 (1) 意义：若空白硬盘相当于一张白纸，分区就是对其进行“裁切”，对分区进行方格划分就是对其进行建立文件系统，即格式化 (2) 常见文件系统格式：ext2 ext3 ext4 xfs msdos (3) ext2文件系统 ​ A. 组成： ​ (a) super block （超级块） ​ (b) inode （索引块） ​ (c) block （数据块） ​ B. 超级块：又称为硬盘地图，记录文件系统的整体信息，如：inode/block块的总量、使用量、空间块量、文件系统格式等相关信息 ​ C. inode块：记录文件属性，一个文件占用一个inode块，并且记录文件数据所在的block块的地址，默认为128B ​ D. block ：存储文件数据，大小为1KB 2KB 4KB，大文件会占用多个数据块 ​ E. 装入方式：将文件的数据块链式的不连续的装入硬盘中 ​ F. ext2文件系统支持 Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB ​ (4) Centos7系统默认文件系统为xfs ​ (5) df命令： ​ A. 格式：df 参数 目录/文件名 ​ B. 作用：列出文件系统的磁盘使用量 ​ C. 参数： ​ (a) -a ：列出所有文件系统 ​ (b) -h ：以容量理解的方式列出信息（GB MB KB） ​ D. 常见：df -ah ​ (6) du命令： ​ A. 格式：du -参数 文件或目录名 ​ B. 作用：查看文件或目录占用硬盘容量 ​ C. 参数： ​ (a) -a ：列出所有文件与目录信息 ​ (b) -h ：以容易理解的方式列出信息（GB MB KB） ​ (c) -s ：列出总量 ​ D. 注意：df命令检测速度较快 硬件设备命名原则 (1) 硬盘 ​ A. 以sd开头后跟a-p表示16块硬盘编号，即sd[a-p] ​ B. 在MBR分区格式中由于主分区+扩展分区最多4个，则编号为1-4，第一个逻辑分区从5开始编号，即使主分区编号未使用，逻辑分区也不能使用 ​ C. 硬盘名称格式：sd[a-p]数字 ​ D. 例：sda1 第一块硬盘的第1个主分区 ​ sdb5 第二块硬盘的第1个逻辑分区 ​ E. 例：PPELL ​ (a) P:sda1 ​ (b) P:sda2 ​ (c) E:sda3 ​ (d) L:sda5 ​ (e) L:sda6 ​ F. 模式： ​ (a) PE ​ (b) PPE ​ (c) PPPE ​ (d) PPPP (2) 光驱：/dev/sr0 (3) 鼠标：/dev/mouse (4) 打印机：/dev/lp[1-15] 添加新硬盘 (1) 方法：关闭系统-&gt;编辑虚拟机设置-&gt;添加-&gt;硬盘-&gt;磁盘类型：SCSI（推荐）-&gt;创建新的虚拟磁盘-&gt;磁盘大小：20GB，存储为单个文件-&gt;默认名称-&gt;完成 (2) 注意：添加的新硬盘必须在关机情况下进行，必须保证新硬盘文件名不能重名 硬盘分区 (1) 检测硬盘分区的类型 ​ A. 格式：parted 设备名 print ​ B. 例：parted /dev/sda print ​ C. 查看Prtition Table:msdos，分区表类型，若为msdos说明使用的为MBR分区格式，就不能使用GPT分区格式命令进行继续分区，否则已有数据会丢失 (2) fdisk分区 ​ A. 规划：规划分区个数、容量、类型 ​ B. 注意：fdisk为MBR分区格式命令 ​ C. 分区功能 ​ (a) n：新建分区 ​ (b) p：查看分区列表 ​ (c) d：删除分区 ​ (d) w：保存分区并退出 ​ (e) m：查看帮助 ​ (f) l ：查看可分区的类型 ​ D. 过程： ​ (a) 分析： ​ ◆ 目标：dev/sdc ​ ◆ 个数：3个分区 ​ ◆ 类型：2P 1E 1L ​ ◆ 容量：5G 5G 剩余 ​ (b)fdisk /dev/sdc ​ ◆ command ：输入分区命令为n（新建） ​ ◆ partition type ：分区类型，p（主分区），e（扩展分区），l（逻辑分区） ​ ◆ partition number ：分区编号，回车默认 ​ ◆ First Sector ：起始扇区编号，回车默认 ​ ◆ last sector ：终止扇区编号，输入：+5G，回车 ​ ◆ 剩余同上 ​ ◆ 输入p查看分区列表，输入w保存同步磁盘并退出 ​ E. 删除分区 ​ (a) 分区向导中输入d ​ (b) 正向新建分区，反向删除分区 ​ F. 注意：若无法查看分区结果列表，则表示分区信息还未写入内核（常见情况），输入“partprobe”命令进行手动将分区信息同步到内核，再不行就重启 ​ (2) lsblk命令 ​ A. 格式：lsblk -参数 /dev/sd? ​ B. 作用：查看磁盘分区信息 ​ (3) blkid命令 ​ A. 格式：blkid -参数 /dev/sd? ​ B. 作用：查看磁盘ID信息 ​ C. 常用：blkid ​ (4) gdisk分区 ​ A. 注意：对于同一硬盘，fdisk和gdisk不能混用 ​ B. 格式：gdisk /dev/sd? ​ C. 过程： ​ (a) gdisk /dev/sdd ​ (b) partition table scan ：扫描分区类型是否已存在 ​ (c) Command(? for help) ：新建（n） 删除（d） 查看列表（p） 保存（w） ​ (d) partirion number(1-128, default 1)：设置分区编号，回车即可 ​ (e) First sector：设置起始扇区值，默认，回车即可 ​ (f) Last sector：设置终止扇区值，输入分区容量，如：+5G ​ (g) Hex code or GUID(L to show code,Enter = 8300) ：设置分区文件系统的ID，回车即可 格式化 (1) 意义：对分区或其他设备建立文件系统 (2) 查看分区命令及类型：输入mkfs后2次tab键 (3) mkfs.xfs命令： ​ A. 格式：mkfs.xfs -参数 设备名 ​ B. 作用：对磁盘分区或文件进行xfs类型格式化 ​ C. 参数： ​ (a) -f ：强制格式化，已有文件系统需要使用此参数 ​ (b) -b ：后跟上block容量，范围512B-64KB，注意，Linux限制为4KB ​ D. 例：对/dev/sdc 进行xfs格式化 ​ mkfs.xfs /dev/sdc1 ​ mkfs.xfs /dev/sdc2 (4) mkfs.ext4命令： ​ A. 格式：mkfs.ext4 -参数 设备名 ​ B. 参数：-b ：设定block大小，如：1KB 2KB 3KB 4KB 挂载 (1) 意义：建立文件目录，通过设置该目录与分区的关系，以进入分区 (2) 挂载点：进入分区的目录称为挂载点 (3) 挂载前的注意事项 ​ A. 单一文件系统不应该被重复挂载在不同的挂载点（目录）中 ​ B. 单一目录不应该重复挂载多个文件系统 ​ C. 作为挂载点的目录，应为空目录，否则原有数据会隐藏 (4) mount目录 ​ A. 格式：mount -参数 设备名 挂载点目录 ​ B. 作用：将分区挂载挂载到指定文件目录上 ​ C. 参数： ​ (a) -a ：按照挂载配置文件/etc/fstab对未挂载的设备全部进行挂载 ​ (b) -t ：指定文件系统，不常用，一般系统会自动判断文件系统类型 ​ D. 例：建立挂载目录，挂载/dev/sdc的分区 ​ mkdir /mnt/m1 /mnt/m2 /mnt/m5 /mnt/m6 ​ mount /dev/sdc1 /mnt/m1 ​ mount /dev/sdc2 /mnt/m2 ​ mount /dev/sdc5 /mnt/m5 ​ mount /dev/sdc6 /mnt/m6 ​ E. 挂载光盘 ​ (a) 光盘名称：/dev/sr0 或 /dev/cdrom ​ (b) 方法：mount /dev//sr0 /media ​ (c) 注意：光盘为只读属性，只能以只读方式挂载 卸载 (1) mount命令： ​ A. 格式：umount -参数 设备名称或挂载点目录名 ​ B. 作用：卸载设备 ​ C. 参数： ​ (a) -f ：强制卸载 ​ (b) -l ：立刻卸载文件系统，比-f还强 ​ (c) -n ：不更新/etc/mtab情况下卸载 ​ D. 例：卸载/dev/sdc ​ umount /dev/sdc1 ​ umount /dev/sdc1 ​ umount /mnt/m5 ​ umount /mnt/m6 ​ E. 注意：卸载时应cd离开挂载点目录，否则文件系统忙，无法卸载 开机挂载 (1) 产生原因：手动挂载后系统重启会自动卸载，应设置开机挂载使其永久生效 (2) 配置文件：/etc/fstab (3) 配置文件分析 ​ A. 共6列 ​ B. 内容： ​ 设备名 挂载点目录 文件系统 defaults 0 0 ​ /dev/sdc1 /mnt/m1 xfs defaults 0 0 ​ C. defaults ：文件系统参数为默认 ​ D. 0 ：是否备份 ​ E. 0 ：开机是否用fsck进行扇区检查，但xfs文件系统不支持则为0 (4) fstab配置完毕后使用：mount -a 完成检测 再重启 (5) 使用lsblk命令查看是否开机挂载成功 (6) 注意： ​ A. 根目录/ 是必须挂载的，而且一定要先于其他mount point被挂载 ​ B. 其他mount point必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则（FHS） ​ C. 配置完毕后必须使用mount -a检测，否则系统启动失败 挂载大文件 (1) 产生原因：由于无自由分区空间，需要添加新分区时，可以对某个已存在的分区的剩余空间制作一个大文件，对其进行格式化挂载当做一个新的分区使用，从而实现不添加新的硬件而增加新分区 (2) 步骤：制作大文件-&gt;格式化-&gt;开机挂载 (3) 方法：例：对/dev/sdc6的剩余空间制作3G大文件进行挂载 ​ A. cd /mnt/m6 ​ B. df /mnt/m6 ​ C. dd if=dev/zero of=/mnt/m6/loopdisk bs=1G count=3 ​ （制作3G的大文件） ​ D. start /mnt/m6/loopdisk （查看文件属性） ​ E. mkfs.xfs -f loopdisk （格式化） ​ F. mkdir /mnt/loopdev （建立大文件挂载点目录） ​ G. mount -o loop /mnt/m6/loopdisk /mnt/loopdev ​ （挂载大文件，需要加 -o loop 参数） ​ H. 开机挂载设置 ​ (a) vim /etc/fstab ​ (b) 插入如下内容： ​ /mnt/m6/loopdisk /mnt/loopdev xfs defaults 0 0 ​ (c) 保存退出 ​ (d) mount -a （进行检测） ​ (e) reboot （重启） 增加swap交换分区 (1) 过程 ​ A. 成新划分一个分区 ​ B. 格式化分区 ​ C. 启用新的swap ​ D. 查看系统信息 ​ E. 开机挂载 (2) 例：对/dev/sdb 新建2G分区空间，对其格式化并生效为swap 空间 ​ A. fdisk /dev/sdb ​ B. mkswap /dev/sdb6 ​ C. swapon /dev/sdb6 ​ D. free -h ​ E. vim /etc/fstab ，输入以下内容： ​ /dev/sdb6 swap swap defaults 0 0 ​ F. mount -a ​ G. reboot （重启） ​ H. free -h （检测） 13.制作大文件生成swap ​ (1) 过程 ​ A. 查看分区 ​ B. 制作大文件 ​ C. 格式化 ​ D. 开机挂载 ​ E. 查看swap信息 ​ (2) 方法 ​ A. cd /mnt/m5 ​ B. dd if=/dev/zero of=swaploop bs=512MB count=1 ​ C. mkswap /mnt/m5/swaploop （格式化为虚拟内存） ​ D. swapon /mnt/m5/swaploop （生效） ​ E. vim /etc/fstab ，插入如下内容： ​ /mnt/m5/swaploop swap swap defaults 0 0 ​ F. mount -a ​ G. reboot]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 五、用户账户及权限]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%94%E3%80%81%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[三、用户账户及权限 用户账户及身份 (1) UUID值 ​ A. 作用：User Identification，系统为每一个账户都分配了一个 唯一的编号（身份证号），具有唯一性，账户的权限来源 于 UUID值 ​ B. 分类： ​ (a) 超级管理员root：0 ​ (b) 系统用户UUID：1-999，系统为每一个服务都分配一个账户，防止某个服务程序出现漏洞，从而被黑客提权至整个服务器，每个服务程序都由一个账户负责，控制破坏范围 ​ (c) 普通账户：从1000开始，由root创建，用于日常维护 ​ C. 特点： ​ (a) UUID值不能相同 ​ (b) 系统账户即使某些UUID值未使用，也不能分配给普通账户 ​ D. id命令： ​ (a) 作用：查看账户的UUID值 ​ (b) 格式：UUID 账户名 (2) 账户及工作组的创建 ​ A. 意义：为了方便管理数据，引入了系统-&gt;工作组-&gt;账户-&gt;权限的概念，相当于企业-&gt;部门-&gt;员工-&gt;权限 ​ B. useradd命令： ​ (a) 作用：创建账户 ​ (b) 格式：useradd -参数 账户名 ​ (c) 参数： ​ ◆ -d ：指定用户的家目录（默认为：/home/用户名称） ​ ◆ -e ：账户到期时间，格式为：YYYY-MM-DD ​ ◆ -u ：指定该用户账户的UID值 ​ ◆ -g ：指定一个初始的用户基本组（必须已存在） ​ ◆ -G ：指定一个或多个扩展用户组 ​ (d) 例： ​ useradd test3 -e 2019-7-15 -u 3000 -g test ​ （设置test3账户，到期时间为2019-7-15，指定该账户UID值为3000，指定用户基本组为test） ​ C. userdel命令： ​ (a) 作用：删除账户 ​ (b) 格式：userdel -参数 账户名 ​ (c) 参数 ​ ◆ -f ：强制删除 ​ ◆ -r ：同时删除账户及用户家目录 ​ D. groupadd命令： ​ (a) 作用：创建工作组 ​ (b) 格式：group -参数 工作组名称 ​ (c) 参数：-g ，指定工作组的gid编号 ​ E. groupdel命令： ​ (a) 作用：删除工作组 ​ (b) 格式：groupdel 工作组名 ​ (c) 注意：工作组中包含有账户时，不能删除，可以通过删除账户一并删除工作组 (3) 账户及工作组的修改 ​ A. usermod命令： ​ (a) 作用：修改账户信息参数 ​ (b) 格式：usermod -参数 账户名 ​ (c) 参数： ​ ◆ -u ：修改用户uid ​ ◆ –g ：变更用户组 ​ B. passwd命令： ​ (a) 作用：给账户设置密码 ​ (b) 格式：passwd -参数 账户名 ​ (c) 参数： ​ ◆ -l ：锁定用户，禁止登录 ​ ◆ -u ：解除锁定，允许用户登录 ​ ◆ -d ：允许用户可以用空格密码登录系统 ​ ◆ -e ：强制用户在下次登录时修改密码 文件权限及归属 （1）文件权限 ​ A. 可读：r ​ B. 可写：w ​ C. 可执行：x （2）目录权限 ​ A. 可读：r ，可以查看目录中的文件列表 ​ B. 可写：w ，可对目录中的文件进行操作 ​ C. 可执行：x ，可打开目录 （3）文件归属 ​ A. 所有者 ​ B. 所属组 ​ C. 其他用户 （4）文件权限数字化 ​ A. 数字组成：r（4） w（2） x（1） ​ B. 表示类别 ​ (a) rwx：完整权，7 ​ (b) rw- : 6 ​ (c) r-x : 5 ​ (d) r– : 4 ​ (e) -wx : 3 ​ (f) -w- : 2 ​ (g) –x ：1 ​ (h) — ： 0 ​ C. 例： ​ 764：rwxrw-r– 642: rw-r—w- 153 : –xr-x-wx ​ rwxrw-r– : 764 rw–w–wx : 623 rw-r–r– : 644 （5）执行ls -l （ll）显示信息意义 ​ 如：-rw-r–r–. 1 root root 1950 6 jun 13 01:00 initial-setup-ks.cfg ​ A. -rw-r–r–. ：普通文件（-） 权限（rw-r–r–） 开启SELinux(.) ​ B. 1 : 文件字节数 ​ C. root root： 所属账户 所属工作组 ​ D. 1950 ：文件占用容量 ​ E. 6 jun 13 01:00 ：文件修改时间 ​ F. initial-setup-ks.cfg：文件名 （6）chmod命令： ​ A. 作用：修改文件权限信息 ​ B. 格式：chmod 参数 权限 文件或目录名 ​ C. 例： chmod 777 h1.cfg （7）chown命令： ​ A. 作用：修改文件所属账户及工作组 ​ B. 格式：chown 参数 所有者：所属组 文件或目录名 ​ C. 例： chown mk1:mk1 h2.cfg 文件隐藏属性 （1）文件隐藏权限：文件拥有一般权限还拥有隐藏权限，当文件权限足够但无法删除时，考虑是否有隐藏权限 （2）chattr命令： ​ A. 作用：查看设置文件的隐藏权限 ​ B. 格式：chattr -参数 文件名 ​ C. 参数： ​ ◆ i: 无法修改文件（目录中不能新建和删除） ​ ◆ a: 仅允许追加内容，不可以覆盖、删除 ​ ◆ s: 文件变更后同步到硬盘 ​ ◆ S: 从硬盘中彻底删除，不可恢复（0填充文件所在存储区） （3）lsattr命令： ​ A. 作用：查看文件的隐藏权限属性 ​ B. 格式：lsattr -参数 文件名 ​ C. 例： ​ touch h3.cfg ​ chattr +a h3.cfg （+a 增加a隐藏权限） ​ rm -f h3.cfg （无法删除） ​ lsattr h3.cfg ​ chattr -a h3.cfg （-a 去掉a隐藏权限） ​ rm -f h3.cfg 账户切换 (1) 切换原则 ​ A. Root账户可任意切换到其他普通账户，不需要密码 ​ B. 普通账户切换到root账户必须输入密码 ​ C. 账户切换并不是注销，只是同时登录 (2) su命令： ​ A. 格式：su -参数 账户名 ​ B. 作用： 切换账户 ​ C. 常用： su - 账户名，减号表示创建新的环境变量信息 ​ D. 注意：尽量减少使用su命令，因为可能暴露root密码 (3) sudo命令： ​ A. 作用：临时赋予普通账户权限，完成原本root完成的任务 ​ B. 格式：sudo -参数 命令名称 ​ C 参数： ​ ◆ -h: 列出帮助信息 ​ ◆ -l : 列出当前用户可执行命令 ​ ◆ -u (用户名UID值)：使用指定的用户身份执行命令 ​ ◆ -k: 清空密码的有效时间，下次执行sudo时需要再次密码验证 ​ D. sudo功能总结 ​ ◆ 限制用户执行指定的命令 ​ ◆ 记录用户执行的每一条命令 ​ ◆ 验证密码后5分钟内不需再次输入密码 ​ ◆ Sudo必须通过编译配置文件才能使用：visudo ​ E. 赋予普通账户临时权限 ​ ◆ useradd fox 新建账户 ​ ◆ passwd fox 设置密码 ​ ◆ su - fox 切换账户 ​ ◆ cd /root ​ ◆ su - root ​ ◆ visudo ​ ◆ 点击shfit + : 后输入set nu 查看行号 ​ ◆ 定位第98行 ​ ◆ 点击i键添加 fox ALL=(ALL) ALL ​ （谁可以使用 允许使用的主机=（以谁的身份） 可以执行的命令列表） ​ ◆ 点击shfit +: 输入wq保存退出 ​ ◆ su - fox ​ ◆ sudo cd /root ​ ◆ 输入fox账户密码 ​ ◆ sudo cat /etc/passwd 完美执行]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 四、文件系统命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[四、文件系统命令 FHS (1) FHS：Linux文件系统层次化标准 (2) 拓扑：倒置树型，一切数据从/根目录开始 (3) 常见一级目录作用 ​ A. root：管理员的家目录 ​ B. etc：配置文件目录 ​ C. dev：设备文件目录 ​ D. mnt：挂载设备的默认目录 ​ E. media：挂载光盘镜像的默认目录 ​ F. bin：常用命令的程序存储目录 ​ G. tmp：临时目录或共享目录 ​ H. var：日志文件存储默认目录 ​ I. boot：系统启动文件目录 (4) 注意： ​ A. FHS不具有强制性约束，但应遵循次行业规则，否则存储混乱 ​ B. 所有目录注意区分大小写（默认小写） 增、删、改命令 (1) touch命令： ​ A. 作用：新建文件 ​ B. 格式：touch -参数 文件名 ​ C. 例： 新建文本文档：touch -t1.txt ​ touch k1.txt k2.sh k3.cfg ​ D. 注意：vim 文件名 ，此文件若不存在则会新建 (2) mkdir命令： ​ A. 作用：新建目录 ​ B. 格式：mkdir -参数 目录名称 ​ C. 参数 ​ (a) -p ：创建递归目录（多级目录），用ls命令查看 ​ (b) -m ：为新建目录增加权限 ​ (c) 练习：用上面的命令建一个目录，安装tree小工具：yum install tree -y ，然后cd /test检查树型目录的正确性 ​ (d) rpm -q gcc查看gcc是不是安装成功 (3) 利用touch命令创建c源文件编译并执行 ​ touch test.c ​ vim test.c ​ 点击i键输入代码, ​ Include &lt;stdio.h&gt; ​ Int main(void) ​ { ​ Int i,j; ​ For(i=1;i&lt;10;i++) ​ Printf(“%d\t”,i); ​ Printf(“\n”); ​ For(int i=1;i&lt;66;i++) ​ Printf(“-”); ​ } ​ 点击ESC键 ​ 点击shift+:后输入wq保存并退出 ​ 编译: gcc test.c（即源文件名） ​ 看结果：../a.out (4) rm命令： ​ A. 格式：rm -参数 文件名 ​ B. 作用：删除文件或目录 ​ C. 参数： ​ (a) -r ：删除目录 ​ (b) -f ：删除不确认，即强制删除 ​ (c) 例：cd ~ （回到家目录） ​ 输入ls查看 ​ 输入y确认删除 ​ 输入ls查看 ​ rm -f t1.txt t2.cfg（删除） (5) cp命令： ​ A. 作用：拷贝文件或目录 ​ B. 格式：cp -参数 源文件 目标文件 ​ C. 参数： ​ (a) -p ：保留源文件的原始属性 ​ (b) -r ：递归拷贝 ​ (c) -i ：目标文件已存在，提示是否覆盖 ​ (d) 例：cp /root/m1.txt /home （/root等价于~） (6) mv命令： ​ A. 作用：移动文件或改名 ​ B. 格式：mv -参数 源文件或目录 目标文件或目录 ​ C. 例：mv m2.txt t1/m1.txt 表示将m2移到t1中并改名为m1 ​ D. 结论： ​ (a) 若源类型和目标类型都是文件或目录，则为重命名 ​ (b) 若源类型为文件，目标类型为目录，则为剪切移动 ​ E. 例：创建一个myDocument目录和一个Document文件，将Document文件移动到myDocument目录下，最后修改myDucument目录为test ​ mkdir myDocument （创建目录） touch Document （创建文件） mv Document myDocument （移动）​ cd myDocument （进入到myDocument目录下） ​ ls （查看） ​ mv Document test （改名） ​ ls (7) dd命令： ​ A. 格式：dd if=/dev/zero of=新文件名 bs=块大小 count=块个数 ​ B. 作用：制作生成指定容量，内容为全数字0的大文件 ​ C. 例： cd / ​ dd if=/dev/zero of=kong.txt bs=50MB count=2 ​ stat kong.txt （相当于属性，有容量了） ​ 再来一个：dd if=/dev/zero of=loop.cfg bs=1G count=5 ​ D. /dev/zero ：是一个特殊的设备文件，可以输出无穷个数字0，其本身又不占空间，用于制作大文件来覆盖旧文件，防止恶意恢复，也可以制作大文件来作为分区使用 ​ E. 例：dd if=/dev/zero of=kong.txt bs=10MB count=5 ​ （制作50MB的大文件） ​ 做完后删除：rm -f kong.txt 文件属性查看命令 (1) file命令： ​ A. 格式：file -参数 文件名 ​ B. 作用：查看文件类别 ​ C. 类型： ​ (a) empty ：空文件 ​ (b) ASCLL text ：ASCLL码文件（文本） ​ (c) directory ：目录文件 ​ (d) block special ：块设备文件（高速设备） ​ (e) character special ：字符设备文件（低速设备） ​ (f) symbolic link ：链接文件（快捷方式） ​ (g) socket ：接口文件 (2) cat命令： ​ A. 格式：cat -参数 文件名 ​ B. 作用：输出文件内容到设备上（默认为显示器） ​ C. 参数： ​ (a) -b ：文件中所否非空行增加行号，从1开始编号 ​ (b) -n ：文件中所有行增加行号 ​ (c) 例： touch k1.txt ​ echo “hello” &gt; k1.txt ​ cat k1.txt ​ touch k2.txt ​ echo “world” &gt; k2.txt ​ cat k2.txt ​ touch k3.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ cat k3.txt ​ D. 特殊功能： ​ (a) 文件内容合并： ​ touch k1.txt k2.txt k3.txt ​ echo “hello” &gt; k1.txt ​ eEcho “world” &gt; k2.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ （查看两个文件内容输出到新文件中） ​ cat k3.txt ​ (b) 倒序查看内容：tac 文件名 ​ E. 注意：由于无翻页功能，适用于内容较少的文本文件查看 (3) more命令： ​ A. 格式： more 文件名 ​ B. 作用：可翻页查看文件内容 ​ C. 方法： ​ (a) 空格：翻页查看 ​ (b) 回车：每行查看 ​ (c) q ：退出 (4) less命令： ​ A. 同more命令 ​ B. 点击j键下一行，k键上一行 (5) head命令： ​ A. 格式：head -参数 文件名 ​ B. 作用：查看文件的前几行内容 ​ C. 参数：-n 行数 ​ D. 例：head -n 5 /etc/passwd （前5行） (6) tail命令： ​ A. 格式：tail -参数 文件名 ​ B. 作用：查看文件后几行或持续刷新内容 ​ C. 例：head -n 5 /etc/passwd （后5行） ​ head -f /etc/passwd （动态刷新内容） (7) wc命令： ​ A. 格式：wc -参数 文件名 ​ B. 作用：统计文件的单词书、行数、容量 (8) stat命令： ​ A. 格式：stat -参数 文件名 ​ B. 作用：查看文件属性 ​ C. 属性： ​ (a) access ：最近访问时间 ​ (b) modify ：最近更改时间 ​ (c) change ：最近改动时间 文件查询命令： (1) find命令： ​ A. 作用：按照文件名、类型、属性等参数检索文件 ​ B. 格式：find 查找路径 查找条件 操作 ​ C. 查找路径：一般为绝对路径 ​ D. 查找条件： ​ (a) -name 文件名 ：按照文件名检索 ​ (b) -user 账户名 ：按照拥有者检索 ​ (c) -group 工作组 ：按照工作组归属检索 ​ (d) –type b/d/c/l ：按照文件类型检索 ​ (e) –size +50k （-50k）:按照大于（小于）50k容量检索 ​ (f) -newer f1 ! f2 ：匹配比文件f1新却比f2旧的文件 ​ (g) 通配符： ​ ◆ * ：任意内容、任意个数 ​ ◆ ? ：任意内容、1个字符 ​ (h) 并且： -a 或： -o 不是（取反）： -not ​ E. 例：find / -name host ​ find /etc -name a. （a开头文件） ​ find / -name ?b. （第二个字母为b的文件） ​ find / -name *.cfg （检索所有的日志文件） ​ find / -user YLX（普通账户YLX的所有文件，如 果不知道就cat /etc/passwd） ​ find /dev -type b （检索块设备文件） ​ find ~ -size -10k （检索小于10k的文件） ​ find / -type b | wc （统计块设备文件个数） ​ find / -name *.c &gt; f.txt （检索c类型文件并 备份到f文件中） ​ 自己查：ip地址 IP ​ 子网掩码 NETMASK ​ 网关地址 GATEWAY ​ 域名解析 DNS （正向/反向） ​ 超文本传输控制协议 （HTTP/HTTPS） (2) grep命令： ​ A. 格式：grep -参数 查找条件 文件名 ​ B. 作用：在文件中按照条件检索内容 ​ C. 参数 ​ (a) -n ：显示符合要求的行的行号 ​ (b) -v ：显示不符合要求的行 ​ (c) -i ：忽略字母的大小写 ​ (d) -c ：显示符合要求的行数 ​ (e) -A数字 ：如-A2表示显示符合要求的行及下面2行 ​ (f) -B数字 ：如-B5表示显示符合要求的行及上面5行 ​ (g) -C数字 ：如-C3表示显示符合要求的行及上下各3行 D. 例： ​ (a) grep -n “root” /etc/passwd 检索包含root ​ (b) Grep -n “/sbin/nologin” /etc/passwd ​ （不允许登陆的账户信息） ​ (c) grep -nv “/sbin/nologin” /etc/passwd ​ （允许登录的账户信息） ​ (d) grep -nA3 “ftp” /etc/passed ​ （检索包含ftp的行及下面3行） ​ (e) Grep -n “halt” /etc/passwd &gt; grep1.txt ​ （使用文件保存检索结果） E.正则表达式 ​ (a) 作用：用于按照指定条件过滤大量文本，是一种表示条 件的规则和方法 ​ (b) 正则与通配符的区别 ​ ◆ 通配符：按照文件名进行检索，一般多数命令都支持 ​ ◆ 正则：在文本中过滤字符串，一般多数语言、脚本等 程序都支持 ​ (c)按照 [ ] 字符集进行过滤 ​ ◆ [ab] ：表示检索包含a或者包含b的信息，括号中 多个内容只表示一个信息 ​ grep -n [dD] /etc/passwd 过滤包含d或D ​ grep -n [oo] /etc/passwd 过滤包含o ​ ◆ [^] ：表示反色显示不包含条件的内容 ​ grep -n [^r] /etc/passwd 反色显示不包含r的字 符串 ​ grep -n [^r]oo /etc/passwd 过滤不以r开头且包 含oo的行 ​ ◆ [0-9] ：表示过滤包含数字的内容 ​ grep -n [0-9] /etc/passwd 过滤包含数字的内容 ​ -grep -n [^7-9] /etc/passwd 反色显示不包含7-9 的内容 ​ ◆ [a-z] [A-Z] [a-zA-Z] ：表示过滤小写字母、大写字 母、字母 ​ grep -n [A-Z] /etc/passwd 过滤包含大写字母的内 容 ​ ◆ 注意：字符集：[] [^] [-] 区别 ​ (d) 过滤行首或行尾 ​ ◆ ^ ：过滤行首以谁开头的内容 ​ grep -n ^n /etc/passwd 过滤行首以n开头的内容 ​ grep -n ^[A-Z] /etc/passwd 过滤行首以大写字母 开头的内容 ​ ◆ $ ：过滤行尾以谁结尾的内容 ​ grep -n $”]” /etc/sos.conf ​ （注意：[]表示字符集，若想表示中括号的作用，必须使用””进行转义） ​ grep -n $”[0-9] /etc/sos.conf” 以数字结尾的内容 ​ ◆ 检索空白行：grep -n ^$ /etc/sos.conf (e) 正则表达式的通配符 ​ ◆ 一个任意字符： . ​ ◆ 重复前面0个或多个任意字符： * ​ ◆ 例： ​ grep -n r..t /etc/passwd 检索以r开头t结尾中 间有两个任意字符的字符串 ​ grep -n o* /etc/passwd 检索不包含或包含o 的内容 ​ grep -n oo* /etc/passwd 检索至少包含o的内 容 ​ grep -n ooo* /etc/passwd 检索至少包含oo的 内容 ​ ◆ 注意： .*表示所有内容 (f) 转义字符及区间字符 ​ ◆ \ ：转义字符，即去掉其后字符附加功能，恢复到 本身功能 ​ grep -n ]$ /etc/sos.conf ​ ◆ 区间字符：{n1,n2}，表示重复n1到n2次前面字 符，n1&lt;n2 ，n2可以省略，{n1}表示大于等于n1次 ​ （注意：{}必须使用\进行转义） ​ grep -n o”{2}” /etc/passwd 检索至少包含两个o 的内容 (3) tr命令： ​ A. 作用：替换文本文件中的字符 ​ B. 格式：tr 原始字符 结果字符 ​ C. 例：cat /etc/passwd | tr [a-z] [A-Z] ​ （显示passwd内容并将其小写字母改为大写） ​ cat /etc/sos.conf | tr # % ​ （#和%需要转义） ​ D. 注意：tr命令一般不直接使用，即不推荐直接更改文件内 容，应显示文件内容并更改 打包压缩命令 (1) 作用：打包、压缩、解压缩文件 (2) 常用格式： ​ A. .tar ：由tar打包程序打包的文件（无压缩功能） ​ B. .tar.gz ：先由tar打包，再由gzip压缩 (3) 格式：tar -参数 压缩文件名 被打包压缩的文件 (4) 参数： ​ A. 打包压缩： ​ (a) -c ：压缩 ​ (b) -z ：使用gzip进行压缩 ​ (c) -v ：显示过程 ​ (d) -f ：目标文件名 ​ (e) 常用：-czvf ​ B. 解压缩 ​ (a) -x ：解压缩 ​ (b) 常用：-xzvf (5) 例：打包压缩/root目录后解压缩（备份） ​ A. cd ~ ​ B. tar -czvf t1.tar.gz /root ​ C. cd / ​ D. mkdir t2 ​ E. cd t2 ​ F. tar -xzvf /root/t1.tar.gz ​ G. ls (6) 注意： ​ A. 压缩文件使用“红色”表示 ​ B. -c与-x不能同时使用 管道符与重定向命令 (1) 输入输出重定向 ​ A. 作用：将默认的输入输出端进行改变 ​ B. 符号： ​ (a) &gt; ：输出重定向，将输出内容重定向到文件 ​ (b) &gt;&gt; ：输出重定向，追加输出 ​ C. 重定向保存错误提示： ​ (a) 格式：命令 2&gt;文件名 ​ (b) 例：ls -l temp 2&gt;err.txt (2) 管道符 ​ A. 格式：命令1 | 命令2 | 命令3…… ​ B. 作用：将前一个命令的结果作为后一个命令的数据源 ​ C. 例：统计包含root的行数 ​ grep “root” /etc/passwd | wc 常见的环境变量 (1) 环境变量 ​ A. 作用：表示bash命令解释器的命令程序存储路径 ​ B. 显示：echo $PATH ​ C. 命令程序：/usr/bin ​ (2) 常见变量 ​ A. HOME：用户的家目录 ​ B. SHELL：SHELL程序目录 ​ C. HISTSIZE：历史命令记录条数 ​ D. PATH：执行文件的默认路径 ​ E. MAIL：邮箱文件存储路径 ​ (3) 注意：使用$运算符显示变量的值 常见Linux文件类型 (1) 普通文件： ​ A. 文本文件：存储ASCLL ​ B. 二进制文件 ​ C. 注意：代号为-，白色 (2) 目录： ​ A. 作用：相当于Windows中的“文件夹” ​ B. 注意：代号为d，蓝色 (3) 链接文件： ​ A. 作用：相当于Windows的“快捷方式”，是一种指向式文件 ​ B. 注意：代号l，绿色 (4) 设备文件： ​ A. 作用：Linux中一切数据皆文件，设备也是一种文件，可编辑 ​ B. 注意：代号（b c 等），黄色]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 三、常用Linux命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令提示符的意义 （1）[root@localhost ~] ​ A. root:表示当前登录账户名称 ​ B. @：表示分隔符 ​ C. localhost：表示主机名 ​ D. ：表示此位置是当前工作路径，相当于/root （2）#：表示以root账户登录，$：表示以普通用户登录 常见命令 （1）命令书写格式：命令名称 + 空格 + 参数 + 空格 + 目标 （2）参数： ​ A.长格式（全称）：–参数 ​ B.短格式：-参数 ​ C.例：man –help ​ man -h （3）目录查看命令 A.格式：pwd B.作用：查看当前工作目录的绝对路径（4）目录切换命令： A.格式：cd 路径 B.作用：切换工作目录 C.路径：​ (a) 绝对路径：从/开始向下遍历 ​ (b) 相对路径：从当前工作目录开始向下遍历（不包含当前工作目录） ​ D.特殊路径 (a) cd / ：切换根目录 (b) cd .. ：返回上级目录 (c) cd ~ ：切换root家目录 (d) cd /root：同上 (e) cd /home/普通账户名 ：切换普通账户的家目录（5）目录浏览命令： A.格式：ls -参数 B.作用：查看目录中的内容 C.参数：​ (a) -a ：查看隐藏文件（以点开头的为隐藏文件） ​ (b) -l ：查看目录中的详细信息 ​ (c) -d ：查看当前目录 D.注意：​ (a) 翻页查看：ls | more ​ (b) 查看目录内的详细信息（等同于ll命令）：ls -l ​ (c) 查看当前目录的详细信息：ls -dl E. ls命令查看的颜色意义：​ (a) 白色：表示普通文件 ​ (b) 蓝色：表示目录 ​ (c) 红色：压缩文件 ​ (d) 黄色：设备文件 ​ (e) 绿色：链接文件 ​ 演示： cd /dev ​ cd / ​ Ls （6）date命令： ​ A. 格式：date [选项] [“+显示时间格式”] ​ B. 注意：按照指定格式显示日期时间 ​ C. 参数： ​ (a) -s ：设定系统的日期时间 ​ (b) -d ：显示指定描述的日期时间（几天前/后） ​ D. 日期格式： ​ (a) %Y ：显示完整的年份 ​ (b) %m ：显示月份 ​ (c) %d ：显示日（1-31） ​ (d) %a ：星期几 ​ (e) %j ：一年中的第几天（1-366） ​ (f) 例：显示年月日：date “+%Y-%m-%d” ​ date “+%j” （数字越大，文件越新） ​ date “+%Y-%m-%d %a” ​ E. 时间格式： ​ (a) %H ：小时（00-23） ​ (b) %M ：分钟（00-59） ​ (c) %S ：秒（00-60） ​ (d) %t ：相当于tab键（4个空格） ​ (e) 例：date “+%H:%M:%S” ​ date “+%Y-%m-%d%t%H:%M:%S” ​ F. 其它： ​ (a) %p ：显示本地AM或PM（上午或下午） ​ (b) %Z ：显示时区 ​ (c) %j ：一般用于备份文件或日志文件，增加此参数，数字越大，文件越新 ​ G. date -s “2020-9-5 18:35:40” 设置系统新的日期时间 ​ H. date -d “+2 day” “+Y-%m-%d” 设置系统的日期为2天后 （减号为几天以前） （7）cal命令： ​ A. 格式： cal -参数 ​ B. 作用：显示日历 ​ C. 例： ​ (a) cal 显示本月 ​ (b) cal -2019 显示全年的日历 （8）echo命令： ​ A. 格式：echo -参数 ​ B. 作用：将字符串输出到屏幕或文件中，显示变量的值 ​ C. 例：echo “HELLO” ​ echo “hello” &gt; 文件名 （9）history命令： ​ A. 格式：history -参数 ​ B. 作用：显示命令历史记录 ​ C. 配置文件：/etc/profile ​ D. 默认记录1000条历史命令 ​ E. 修改历史命令记录条数： ​ (a) vim /etc/profile ​ (b) HISTSIZE=1000 将1000改为指定数字 ​ (c) reboot 重启 ​ F. 清空历史命令记录：history -c 系统检测命令 （1）ps命令： ​ A.格式：ps -参数 ​ B.作用：显示进程的参数 ​ C.参数： ​ (a) -a：显示所有进程 ​ (b) -u：用户及其他详细信息 ​ (c) -x：显示没有控制终端的进程 ​ D.常用：ps -au ​ E.注意：只要关注%CPU（cpu占用率）及%MEM（内存使用率） （2）top命令： ​ A.作用：动态检测系统的活动与负载，相当于强化版的“任务管理器” ​ B.top命令显示的表头解释： ​ (a) 第一行： ​ ◆ 系统时间 ​ ◆ 运行时间 ​ ◆ 登录的终端数 ​ ◆ 系统负载：1分、5分、15分钟平均值（三个值越小，系统负载越低） ​ (c) 第二行：进程总数、运行进程数、睡眠数、停止数、僵死数 ​ (d) 第三行： ​ ◆ 用户资源占用百分比 ​ ◆ 系统内核占用资源百分比 ​ ◆ 改变过优先级的进程资源百分比 ​ ◆ 空闲的资源百分比等 ​ (e) 第四行： ​ ◆ 物理内存总量 ​ ◆ 内存使用量 ​ ◆ 内存空闲量 ​ ◆ 作为内核缓存的内存量 ​ (f) 第五行： ​ ◆ 虚拟内存量 ​ ◆ 虚拟内存使用量 ​ ◆ 虚拟内存空闲量 ​ ◆ 已被提前加载的内存量 ​ D. 点击q键退出 （3）ifconfig命令： ​ A.作用：查看本机网卡信息 ​ B.信息： ​ (a) ens32为本机物理网卡 ​ (b) inet：本机IP ​ (c) netmask：本机子网掩码 ​ (d) RX：发送数据包个数 ​ (e) TX：接收数据包个数 （4）uname命令： ​ A.格式：uname -a ​ B.作用：显示系统的版本信息 （5）free命令： ​ A.格式：free -h ​ B.作用：显示内存及虚拟内存的容量、剩余量等信息 （6）who命令： ​ A.作用：显示系统登录信息 ​ B.信息： ​ (a) 账户 ​ (b) 方式 ​ ◆ :0 表示图形化界面 ​ ◆ tty2 命令行界面 ​ ◆ pts/0 远程登录界面 ​ (c） 日期时间 （7）last命令：显示系统登录或退出的详细信息，是强化版的who]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 二、Linux的安装与部署]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%8C%E3%80%81Linux%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[二、Linux的安装与部署 VMware虚拟机的安装 (1) .增强型键盘驱动需要打勾 (2) .虚拟机的新建及设置 ​ A. 稍后安装操作系统 ​ B. 选择客户机系统：centos7 64 位，其目的是匹配系统，选择更适合的VMware tools 工具包 ​ C. 命名虚拟机 ​ (a).虚拟机名称：默认 ​ (b).放在非C盘路径，与其他虚拟机名称要有区别 ​ D. 磁盘容量 ​ (a).大小：20GB，动态分配，使用多少分配多少，最大为20GB ​ (b).将虚拟磁盘文件存储为单个文件：存储速度快，不易于迁移 ​ (c).将虚拟磁盘存储为多个文件：存储速度相对较慢，利于虚拟机迁移 ​ E. 自定义硬件 ​ (a).内存：1：4关系，1G虚拟机内存对应4G物理内存 ​ (b).CPU：1颗，4核 ​ (c).新CD/DVD：点击“选择ISO镜像文件”选项，点击“浏览”，设置下载的镜像文件路径 ​ (d).网络适配器： ​ ◆ 桥接模式：将物理机网卡当作桥梁，建立虚拟机与互联网的连接关系，适用于不频繁变动的网络 ​ ◆ NAT模式：（NAT：网络地址转换器）将物理当作路由器，通过“路由器”建立网络连接，适用于经常变换网络环境的情况下使用（VMnet 8） ​ ◆ 仅主机模式：仅当前虚拟机与物理机连接，无法连接互联网（VMnet 1） ​ (e).移除不必要的设备：USB、声卡、打印机设备 (3).虚拟机的功能配置 ​ A.虚拟机移除 ​ (a).虚拟机左侧“库”侧边栏中选中虚拟机文件，单右，移除 ​ (b).定位虚拟机在Windows中的存储位置，选中文件夹删除 ​ B.快照制作 ​ (a).作用：将系统状态参数等信息冻结保存为镜像，以便于系统崩溃后进行恢复 ​ (b).方法：虚拟机菜单-&gt;快照-&gt;拍摄快照（注意左下角进度比率） ​ C.虚拟网络编辑器 ​ (a).作用：显示及配置网卡的地址参数 ​ (b).方法：编辑菜单-&gt;虚拟网络编辑器 ​ (c).注意：右下侧是否有黄色感叹号三角，若有说明虚拟机没有以管理员权限打开 Linux系统部署 无法获取 vmci 驱动程序版本句柄无效解决办法：打开本地路径，找到以VMX结尾的文件，进入查找界面，在文本框输入 vmci0.present 点击查找下一个，查找到 vmci0.present=&quot;TRUE&quot; 代码，将true更改为false点击保存即可 （1）软件选择：带有GUI的服务器 （2）安装位置（分区）： ​ A. 我要配置分区-&gt;完成-&gt;点击“+”添加分区-&gt;设置挂载点及期望容量-&gt;完成-&gt;接受更改 ​ B. 分区原则（最少三个分区）： ​ (a) . /boot：系统启动分区，400MB ​ (b) swap：交换分区（虚拟内存），4GB ​ (c) /：根分区，剩余容量（不填） （3）关闭KDUMP（内存崩溃保护机制）以节省内存 ​ A. 设置root高级管理员密码，设置普通账户名（大写）及密码 ​ B. 初次进入系统的设置 ​ a.登录：点击“未列出”-&gt;root-&gt;密码:123456 ​ b.系统自带的六个终端 ​ ◆ 方法：ctrl+alt+F1~F6 ​ ◆ F1对应图形化界面 ​ ◆ F2~F6对应5个命令行界面 ​ c.清屏 ​ ◆ ctrl+l ​ ◆ 命令：clear ​ d.查看本机IP地址：ip addr（查看ens33） ​ e.配置网卡： ​ (a)cd /etc/sysconfig/network-scripts ​ (b)vim ifcfg-ens32 ​ (c)点击键盘i键，进入编辑状态，定位ONBOOT=no，将no删除编为yes ​ (d)点击esc键 ​ (e)点击shift+: ​ (f)输入wq后保存退出 ​ (g)重启网卡：service network restart ​ (h)检测：ping [www.baidu.com](http://www.baidu.com) ​ (i) ctrl+c 终止ping操作 ​ f.快照制作：虚拟机-&gt;快照-&gt;拍摄快照-&gt;命名（见名知意） （4）远程登录putty的使用： ​ A. Hosts name（or IP address）：输入Linux的IP地址 ​ B. Saved sessions：输入新名称后点击save ​ C. 点击open ​ D. Login as：输入root ​ E. 输入密码 ​ F. 字体、字号调整：定位标题栏-&gt;单击右键-&gt;change settings-&gt;Appearance-&gt;点击右键“change”按钮-&gt;设置 “粗体”，18号-&gt;确定-&gt;Apply 系统YUM源的配置 （1）yum配置文件目录：cd /etc/yum.repos.d （配置文件扩展名为.repo） （2）替换yum源： ​ A. 删除自带yum配置文件： cd /etc ​ rm -rf yum.repos.d （删除目录） ​ mkdir yum.repos.d （新建同名目录） ​ cd yum.repos.d （进入目录） ​ B. 下载网易yum配置文件：http://mirrors.163.com/.help/CentOS7-Base-163.repo cd /etc/yum.repos.d wget &lt;http://mirrors.163.com/.help/CentOS7-Base-163.repo&gt;（3） 建立新的yum缓存 ​ yum clean all （清理旧yum缓存） ​ yum makecache （新建缓存） （4）更新系统yum update kernel （5）更新所有软件：yum update 第二种方法（不用yum）,cmatrix实例的安装： （1) wget &lt;http://archive.ubunntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orug.tar.gz&gt; (下载软件) （2）Tar xvf cmatrix_1.2a.orig.tar.gz (解压缩) （3）cd cmatrix-1.2a (进入解压缩后的目录) （4） yum install ncurses-devel(安装依赖软件) （5）yum install gcc -y ( 安装依赖软件) （6）./configure &amp;&amp; make &amp;&amp; make install (编译安装) （7）任意目录下输入：cmatrix （按Q退出） 修改root账户密码 （1）重启：reboot （2）内核选择界面点击上下键，使其停留在该界面 （3）点击键盘 e 键 （4）定位Linux16所在行，找到ro后删除，同位置添加 ​ rw init=/sysroot/bin/bash （5）点击ctrl+x （6）输入： hroot /sysroot （7）输入：passwd （8）输入2次新密码 （9）输入 touch /.authorelabel （10）点击键盘ctrl+d （11）输入reboot重启 关机重启 （1）重启：reboot 或shutdown -i now （2）关机 : shutdown now 或 halt 14.常用的快捷键 ​ （1）清屏 ctrl+l ​ （2）终止命令 ctrl+c ​ （3）单词补全 tab ​ （4）调出历史命令 : 键盘上下键 ​ （5）终止进程：ctrl+z]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 一、Linux环境简介]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%80%E3%80%81Linux%E7%8E%AF%E5%A2%83%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、Linux环境简介 说明： VMware 14密钥 ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 ZC5XK-A6EOM-080XQ-04ZZG-YF08D 网易开源镜像（http://mirrors.163.com） 阿里开源镜像（https://opsx.alibaba.com/mirror） 熟练掌握常见命令（80个左右） 熟练掌握软件包安装 （初级阶段） 熟练掌握系统结构和运行原理 熟练搭建各种常见服务器 熟悉网络安全并能配置服务器安全策略 （中级阶段） 熟悉掌握Linux下磁盘存储管理、用户权限管理、内存管理、文件系统管理、进程管理等 熟悉掌握系统故障排查方法并进行调优 Linux系统的构成 (1) .Linux本质是一个内核（kernel） (2) .Linux发行套件：将kernel与辅助软件、工具软件、文件系统等组成一个大型软件包，从而形成Linux发行套件 Linux发行版本介绍 (1) .RHEL：红帽企业版，具有完整的Linux功能，企业首选 (2) .Centos：社区企业操作系统，是RHEL免费版，学习首选 (3) .Ubuntu：乌班图，是Linux桌面版操作系统 Linux发行套件的版本构成 (1) .DVD版本：以标准DVD容量（4.8G）进行发行的商业版本，具有基本组件（常用） (2) .Everything版本：完整版，具有全部功能组件，10G容量 (3) .Minimal版本：最小化安装版（920MB），具有操作系统最小功能 (4) .Netinstall版本：网络安装版，批量化LAN安装 (5) .X86_64：使用平台为64系统]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端form表单]]></title>
    <url>%2F2019%2F07%2F14%2FWEB%E5%89%8D%E7%AB%AFform%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[input属性 name：名字，类似id，可以用js取值和分类，后台用的较多 value：表单提交项的值(不同类型的input，value的作用也不尽相同) placeholder(文本类)：文本输入提示(css3新增属性，用来提示文本输入) checked(选择类)：页面加载时默认选定的 input 元素 readonly(文本类)：只读的文本输入元素 disabled：规定禁用的 input 元素 type：input的种类 文本类：text——文本框；password——密码 选择类：radio——单选；checkbox——复选 按钮类：submit/image——提交/图片提交；reset——重置；button——按钮 特殊类：file——上传 有点懵…不要着急，让我一个个举例~ 文本类 1234567&lt;!-- 后台数据库通过name值找到value（值） --&gt;&lt;!-- 可输入的文本框 --&gt;&lt;input type="text" value="我是值" name="user" /&gt;&lt;!-- 密码文本框 --&gt;&lt;input type="password" placeholder="密码" name="password" /&gt;&lt;!-- 只读不可输入的文本框 --&gt;&lt;input type="text" value="我是只读的" readonly /&gt; 选择类 单选框 123&lt;!-- 设置name="sex"使单选框生效，不能多选 checked表示默认选项 --&gt;&lt;input type="radio" name="sex" checked /&gt;男&lt;input type="radio" name="sex" /&gt;女 多选框 123&lt;input type="checkbox" name="hobby" /&gt;足球&lt;input type="checkbox" name="hobby" /&gt;篮球&lt;input type="checkbox" name="hobby" /&gt;羽毛球 按钮类 123456&lt;!-- 提交按钮 --&gt;&lt;input type="submit" /&gt;&lt;!-- 按钮 --&gt;&lt;input type="button" value="→" disabled /&gt;&lt;!-- 重置 --&gt;&lt;input type="reset" /&gt; 特殊类 12 &lt;!-- 上传文件 --&gt;&lt;input type="file" /&gt; 表单元素的专用伪类选择器：focus—-获得焦点举个简单的例子，比如这里有一个按钮：&lt;input type=&quot;button&quot; value=&quot;按钮&quot; class=&quot;button&quot; /&gt;，那么如何获取焦点呢？很简单，就是在css样式里设置： 12345input:focus&#123; /* 这里的样式自定义 */ border: none; border-bottom: 1px red dashed;&#125; 获取焦点后，表单的按钮类元素在鼠标移入时不会显示为可以点击的手型，可以用cursor的样式改变其效果(可以用在其他元素上)，鼠标在移入某元素上时的鼠标样式，这里有5种 可以点击的手型 123.button&#123; cursor: pointer;&#125; 禁用手型（不可以被点击） 123.button&#123; cursor: not-allowed;&#125; 可以任意拖动 123.button&#123; cursor: move;&#125; 提供帮助（在浏览器中显示为？，表示帮助） 123.button&#123; cursor: help;&#125; 等待（加载中的状态） 123.button&#123; cursor: wait;&#125; 绑定焦点：label(内联元素)作用：绑定input元素定义标注，并帮助input元素获取焦点，也就是说当点击选择按钮后面的文字时，也能被选中 写法1：label嵌套成input的父元素两个标签分开写，需要给文字加上span标签 以上面的单选代码为例： 123456789&lt;label&gt; &lt;input type="radio" name="sex" checked /&gt; &lt;span&gt;男&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type="radio" name="sex" /&gt; &lt;span&gt;女&lt;/span&gt;&lt;/label&gt; 写法2：label的for属性的值=input的id值，需要给input加上id值 以上面的多选代码为例： 12345678&lt;input type="checkbox" name="hobby" id="football" /&gt;&lt;label for="football"&gt;足球&lt;/label&gt;&lt;input type="checkbox" name="hobby" id="basketball" /&gt;&lt;label for="basketball"&gt;篮球&lt;/label&gt;&lt;input type="checkbox" name="hobby" class="ball" /&gt;&lt;label for="ball"&gt;羽毛球&lt;/label&gt; form属性1.method：表单的提交方式（POST和GET） 一般浏览器通过哪种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method (方法)属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，之后浏览器会按分段传输的方法将数据发送给服务器；在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，读到参数后，会在应用程序能够使用这些表单值以前，对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数 GET 方法，浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔 GET、POST的区别：get在url里传送数据：安全性低、容量小，便于分享(商品地址和url有关)，适合获取，且会缓存；post安全性一般、容量几乎无限，更适合上传(图片等) action：表单处理服务器 注意：凡是用户与服务器交互的表单标签应全部放在form标签内；form内的提交按钮提交的是整个form表单 举个表单提交的例子~做一个天猫商城网站搜索商品的搜索框 HTML： 1234&lt;form action="https://list.tmall.com/search_product.htm" method="GET"&gt; &lt;input type="text" placeholder="搜索天猫商品" name="q" /&gt; &lt;input type="submit" value="搜索" /&gt;&lt;/form&gt; 然后在浏览器中打开，在文本框随便搜索什么东西，都能跳转到天猫商城的对应商品页 其他表单元素 select/option：下拉选框/下拉选框的选项 对高度的支持不兼容 size(select属性)：用来设置同时显示选项的数量 selected(option属性)：用来设置下拉框的默认选项 举个例子~做一个下拉选框，要求有北京、上海、广州，设置广州为下拉框的默认选项，同时显示2个选项 12345&lt;select name="" id="" size=2&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="guangzhou" selected&gt;广州&lt;/option&gt;&lt;/select&gt; textarea：文本域，即自定义文本框的宽高 各个浏览器下的默认滚动条显示不兼容 cols/rows属性：列数/行数 css3新增 resize 自由缩放样式 resize: none;(禁用缩放)；both水平垂直都可以缩放；horizontal：只有水平方向可以缩放；vertical 只有垂直方向可以缩放。注意：一定要配合overflow:auto 一块使用 举个例子~ 设置一个列数为30行数为10的文本框 1234&lt;!-- 文本框：不能改变宽高 --&gt;&lt;input type="text" /&gt;&lt;!-- 文本域：可以通过设置列数和行数来更改宽高 --&gt;&lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; 设置一个150*150背景为红色的div盒子，用自由缩放样式可以拖动div盒子的右下角以改变大小 HTML部分： 1&lt;div&gt;&lt;/div&gt; CSS部分： 12345678div&#123; width: 150px; height: 150px; background-color: red; /* 水平垂直都可以缩放 ，一定要配合overflow: auto;使用*/ resize: both; overflow: auto;&#125;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端定位和居中]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[定位详解 position: static;无定位（默认值） 元素出现在正常的流中(忽略 top, bottom, left, right 或者 z-index声明)。 当你没有为一个元素指定定位方式时，默认为static，也就是按照文档的流式(flow)定位，将元素放到一个合适的地方。 在不同的分辨率下，采用流式定位能很好的自适合，取得相对较好的布局效果。 position: inherit;继承父元素的定位方式 position: relative;相对定位 不影响元素本身特性，没有定位偏移量时对元素无影响 相对定位的元素仍然在文档流中，仍然占据 着它本来占据的未知空间（虽然它已经不在本来的位置了） 相对于其正常位置进行定位，元素的位置通过偏移值：“left”、”top”、”right”、”bottom”进行规定 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: absolute;绝对定位 使元素从文档流中被删除，结果就是钙元素原本占据的空间被其他元素所填充 使内联元素在设置宽高时支持宽高，区块元素在未设置宽度时由内容撑开宽度（改变元素的特性） 相对于 static 定位以外的第一个祖先元素进行定位(其父元素没有定位则逐层上找，直到document)。元素的位置通过偏移值进行规定。（所以一般对其父元素也要设置定位） 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: fixed;固定定位 元素的表现类似于将 position 设置为 absolute，不过其包含块是视窗(window)本身，也就是说下拉滚动条时包含块始终在窗口中。 定位效果类似之前学过的固定背景，元素与视窗始终相对静止。元素的位置通过偏移值进行规定。 提升层级，用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 z-index: 99;z轴的顺序 当网页上出现多个定位所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面 x轴和y轴决定网页平面，z轴则是垂直于屏幕的虚拟坐标轴，浮动层在这个坐标轴上的顺序号就决定了谁上谁下。 定位才可以触发z-index属性，它没有单位，并可拥有负的属性值。默认值为0 position:relative和-margin都可以使元素位置发生偏移，有什么区别？ 相对定位可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他元素的位置不会发生变化 通过负margin偏移的元素会放弃偏移前占据的空间，后面的其它元素就会“流”过来填充，所以它们位置发生了变化。 元素的居中 行内块级元素 基本思想：使用display: inline-block; vertical-align: middle; 以及一个伪元素让内容块垂直居中于容器中央 123456789.parent::after, .son&#123; display:inline-block; vertical-align:middle; &#125; .parent::after&#123;display:inline-block; content:''; height:100%; &#125; 如果“margin-left”和“margin-right”都是“auto”，那么它们的使用值是相等的。它将元素相对于包含块的边缘水平居中(要求子元素比父元素小，且只能做水平方向的居中)。 1.son&#123;margin:0 auto;&#125; 使用CSS3中新增的transform属性, 支持水平和垂直居中，子元素设置如下: 12345.son&#123; position:absolute; left:50%; //top:50%; transform:translate(-50%,0); //transform:translate(0,-50%);&#125; transform是css3的变形，在后面会详细说明 使用绝对定位方式, 以及负值的margin, 支持水平和垂直居中，（适用于子元素宽度大于父元素宽度的特殊情况，是最优的水平垂直居中方法）子元素设置如下: 123456.son&#123; position:absolute; width:固定宽; //height:固定高; left:50%; //top:50%; margin-left:-0.5固定宽; //margin-top:-0.5固定高 &#125; 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; —支持水平和垂直居中，（缺点：子元素宽度必须小于父元素宽度）子元素设置如下: 1234567.son&#123; position:absolute; width:固定宽; //height:固定高 left:0; //top:0; right:0; //bottom:0; margin:0 auto; //margin:auto 0; &#125; 6. 同时支持水平和垂直居中最好的方案是：transform(变形)（后面会说到）、绝对定位 （相对定位只能做水平居中）和移动端阶段学习的弹性盒模型的几个方案 说那么多…做个练习吧！！！！ ​ 1. 定位练习 ​ 题目：做一个宽高300背景为红色的div块，将4个75*75像素背景为黑色的小div块定位在它的四个角 ​ （注：给子元素设置绝对定位时要记得给父元素设置相对定位） HTML部分： 123456&lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021222324.parent&#123; width: 300px; height: 300px; background-color: red; position: relative;&#125;.parent&gt;div&#123; width: 75px; height: 75px; background-color: black; position: absolute;&#125;.parent&gt;div:nth-of-type(2)&#123; right: 0; top: 0;&#125;.parent&gt;div:nth-of-type(3)&#123; left: 0; bottom: 0;&#125;.parent&gt;div:nth-of-type(4)&#123; right: 0; bottom: 0;&#125; 2. 居中练习 题目：做一个宽高为300背景为灰色的div块，固定定位在页面右下角，并为其设置一个子元素son，绝对定位在其正中心 HTML部分： 123&lt;div class="parent"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021body&#123; height: 2000px;&#125;.parent&#123; width: 300px; height: 300px; background-color: gray; position: fixed; right: 0; bottom: 0;&#125;.parent .son&#123; width: 150px; height: 150px; background-color: blue; position: absolute; left: 50%; margin-left: -75px; top: 50%; margin-top: -75px;&#125; 注：CSS部分给body设置高度是为了验证固定定位的特点，即下拉滚动条时没有改变位置]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端布局和HTML5新标签]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%92%8CHTML5%E6%96%B0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[做一个页面布局 大多数网站会把内容安排到多个列中(就像杂志或报纸那样) 开始使用布局的时候尽量通过ps等画图工具进行设计 早期的网站使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具 如今大多数网站使用等元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局 学习布局时需要完成下面的步骤 第一步：创建一个新项目，用index.html作为主页 第二步：按照ui设计画布局图 第三部：按照布局图布局HTML结构(必须与布局图相同) 第四部：在PS中精确测量出ui设计中每个区域的样式并在css中赋值(注意用内部或外链样式表) HTML5 在W3C经历了严格的标签XHTML、css和XHTML的过渡版之后HTML5的标准出现了。它的出现是为了解决Web各种浏览器之间的兼容性低；文档结构不够明确，不够语义化；应用程序功能受限，需要很多额外的插件(如flash) 目前知名浏览器厂商(微软、Google、苹果等)都对HTML5支持(但是目前还有没正式版本，部分内容不完全支持或兼容有问题) HTML5的声明：；元数据标签设置： 当元素去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于SEO(搜索引擎优化)，语义化标签可以和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息——爬虫依赖于标签来确定上下文和各个关键字的权重 方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化 在html5之前只能使用div作为结构元素，而html5新增了很多带有语义的标签 常用HTML5的结构标签 header(双标签)：页眉，用于页面的头部的信息介绍或者板块头部 footer(双标签)：页脚，用于页面的底部或者版块底部 section(双标签)：版块，用于划分页面上的不同区域，或者划分文章里不同的节，属于article的一个部分 hgroup(双标签)：页面上的一个标题组合，一个标题和一个子标题，或者标语的组合 nav(双标签)：导航，包含链接的的一个列表 article(双标签)：用来在页面中表示一套结构完整且独立的内容部分，可以用来呈现论坛的一个帖子，杂志或报纸中的一篇文章，一篇博客，用户提交的评论内容，可互动的页面模块挂件等可以用header/footer/section等来做头部/脚部/部分 aside(双标签)：元素标签可以包含与当前页面或主要内容相关的引用、侧边栏、广告、nav元素组，以及其他类似的有别与主要内容的部分，aside 的内容应该与 article 的内容相关 被包含在article中作为主要内容的附属信息部分，其中的内容 以是与当前文章有关的引用、词汇列表等 在article之外使用，作为页面或站点全局的附属信息部分；最典型的形式是侧边栏(sidebar)，其中的内容可以是友情链接、附属导航或广告单元等]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端样式的初始化和css样式的补充]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8Acss%E6%A0%B7%E5%BC%8F%E7%9A%84%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[浏览器的默认样式 同一个标签在不同的浏览器中有不同的默认样式，为了让样式在所有浏览器中统一，并设置一些预定义样式，我们应该做浏览器默认样式的初始化 默认样式的检查方式：可以用border+浏览器开发者工具来查看是否有默认样式 常见的浏览器默认样式 文字斜体和加粗等字体样式：font-weight:normal;font-style:normal; body、ul等区块元素的填充和边距：margin:0; padding:0; li的列表样式：list-style:none; a标签和其状态性伪类的字体颜色和下划线样式： 12345a&#123;text-decoration:none; color:#000; border:0;&#125;a:link&#123;text-decoration:none; color:#000;&#125;a:visited&#123;text-decoration:none; color:#000;&#125; a:hover&#123;text-decoration:none; color:#000;&#125;a:active&#123;text-decoration:none; color:#000;&#125; 设置盒模型的样式：box-sizing:border-box; 也就是说，每写一个网页就要清一次样式，是不是很麻烦呢？别着急，这里准备了一个common.css，每次写网页直接引用就可以啦~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@charset "utf-8";/* CSS Document */*&#123; box-sizing:border-box; color:#000;&#125;body&#123; font-size:14px; font-family:Arial,Verdana,Tahoma,"微软雅黑","黑体"; line-height:1.2em; background:#fff; margin:0; overflow-x:hidden;&#125;p,h1,h2,h3,h4,h5,h6,ul,ol,dl,li,form,table&#123; margin:0; padding:0;&#125;img&#123; vertical-align:middle;&#125;li&#123; list-style:none;&#125;i,em&#123; font-style:normal;&#125;a&#123; text-decoration:none; color:#000000;&#125;a:link&#123; text-decoration:none; color:#000000;&#125;a:visited&#123; text-decoration:none; color:#000000;&#125;a:hover&#123; text-decoration:none; color:#000000;&#125;a:active&#123; text-decoration:none; color:#000000;&#125;.clearfix:after&#123; display:block; content:""; clear:both;&#125;.clearfix&#123; *zoom:1;&#125; CSS样式的补充 改变元素的透明度 12opacity: 0.9; /* 赋值0-1，从透明到完全不透明 */filter: alpha(opacity=90); /* 为了兼容低版本IE浏览器的滤镜 */ 如果是背景颜色需要加透明度就是background-color: rgba(255,255,255,0.5); 隐藏元素 12visibility: hidden/visible; /* 隐藏元素但是依然占位 */display: none/block; /* 隐藏元素但是不占位 */ 注意：虽然visibility: hidden的隐藏元素依然占位，但是它与透明度为0有区别，透明度为0的元素我们依然可以摸到，但是visibiity: hidden的元素却无法摸得到 举个例子： html部分： 123456 &lt;div class="box1"&gt;div1&lt;/div&gt; &lt;div class="box2"&gt;div2&lt;/div&gt; &lt;div class="box3"&gt;div3&lt;/div&gt; &lt;div class="box4"&gt;div4&lt;/div&gt;&lt;!-- 元素透明和visibility隐藏，元素的位置依然保留；而display的none方法，元素的位置消失 --&gt;&lt;!-- 元素透明opacity看得见摸得着，而visibility和display看得见摸不着 --&gt; css部分： 1234567891011121314151617181920212223 div&#123; width: 150px; height: 150px; background-color: red; font-size: 50px; color: white; &#125; /* 设置box1的透明度为0 */ .box1&#123; opacity: 0; &#125; /* 当鼠标点击时box1变为不透明，即可以显示 */.box1:hover&#123; opacity: 1; &#125; /* 设置box2元素为隐藏元素 */ .box2&#123; visibility: hidden; &#125; /* 当鼠标点击时box2不能显示 */ .box2:hover&#123; visibility: visible; &#125; overflow：溢出的部分应该如何显示 12345678overflow-x:hidden; /*水平方向溢出*/overflow-y:auto; /*垂直方向溢出*/overflow:inherit; /*两个方向溢出*/visible：默认值。溢出的内容不会被修剪，会呈现在元素框之外；hidden：溢出的内容会被修剪，并且其余内容是不可见的；(如上面的初始化默认样式中的overflow-x:hidden;，让body的内容在水平方向溢出时裁切，不显示滚动条)scroll：溢出的内容会被修剪，浏览器会显示滚动条以便查看其余的内容；auto：如果溢出的内容被修剪，则浏览器会显示滚动条以便查看其余的内容；inherit：规定应该从父元素继承 overflow 属性的值 百分比单位： 字体的行高使用了百分比，表示字体大小的百分之多少； 盒子模型子元素的宽高百分比=父元素宽高的百分比*子元素的宽高百分比； 子元素的padding和margin设置百分比时却不是对应父元素的内填充和外边距，而是子元素的padding和margin=父元素的宽*子元素的padding和margin的百分比(后面的left和top也是父元素的宽高，需要注意) 背景定位的X/Y=（父元素宽/高-图片宽/高）*背景定位的百分比 最大最小宽高：可以配合上面的百分比宽高一起使用，做一个变化带有范围的效果： 最大宽：max-width: ; 最小宽：min-width: ; 最大高：max-height: ; 最小高：min-heihgt: ; 注：设置最小高度时，当文字超过最小高度的大小时高度会随文字的增多而变高 轮廓线outline（了解）：它是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，它不会占据空间，也不一定是矩形。 1234outline-color:; /*轮廓线颜色*/outline-style:; /*轮廓线样式*/outline-width:; /*轮廓线宽度*/outline-offset:; /*轮廓线扩张*/ 注：写成集合样式outline，如果不设置其中的某个值，也不会出问题，比如 outline:solid #ff0000; 也是允许的 列表元素 列表元素有dl(定义列表)、dt(定义名)、dd(详情)、ul(无序列表)、ol(有序列表)、li(列表的项) 当我们需要把一系列类似的项在页面中展示的时候就要用到列表，比如名词解释(定义列表)、商品列表或导航(无序列表) 它们是一种绑定关系，其中dt和dd必须是dl的子元素，dl也只能用dt和dd作为子元素；li是ul和ol的子元素，ul和ol也只能用li做子元素 ol(有序列表)有一个type属性，可以把值设为1(默认值，数字序列)、A(大写字母序列)、a(小写字母序列)、I(大写罗马数字序列)、i(小写罗马数字序列)，若已经将li的list-style设置为none则样式都会丢失]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装及基本使用]]></title>
    <url>%2F2019%2F07%2F06%2Fgit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[准备工作 下载git 注册github 将git和github连接起来 获取ssh秘钥 id_rsa.pub github里，找到settings，填入秘钥 正式开始 1、确定git和github已经连接 12git initgit remote add origin 仓库地址 2、本地文件推到github上 将新建的文件添加到git的缓存区 1234添加具体名称文件git add index.html添加全部文件git add . 给提交的文件添加描述 1git commit -m &apos;demo&apos; 汇总到总分支上 1git pull origin master --allow-unrelated-histories 退出 1:wq 文件推到远程仓库 123 git push origin mastergit push -u origin master 输入用户名(如果设置了SSH密匙的话就不用输入密码了) 1输入OpenSSH：输入密码 ==如果出现错误== 1git config --global user.email &quot;you@example.com&quot; 一般在push的时候会出现错误1234hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法 先执行git pull origin master 在执行git push origin master==这个时候又可能出现错误== 1fatal: refusing to merge unrelated histories 不用慌，我在网上搜好多方法，都说使用如下指令 12git pull origin master --allow-unrelated-histories git pull --allow-unrelated-histories 但是输入这些指令之后会跳出来另外一个界面然后从新pull就行了 我的解决方法重新在原文件下Git Brush Here然后重新开始就可以解决 无论使用git pull 出不出现错误只要出现刷新github文件就推过来了学习相关git的操作git的学习 廖雪峰的官方网站]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内联块和浮动问题]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%86%85%E8%81%94%E5%9D%97%E5%92%8C%E6%B5%AE%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[内联块和浮动都是为了使区块元素在一行显示 内联块（inline-block） 设置：很简单，直接在css样式中加上display: inline-block;即可 特点： 可以和非区块元素在一行显示 支持所有的样式 不设置宽高时由内容（文字图片等）撑开 换行符会被解析（缺点） 那么，如何去掉内联块之间的空格（换行符）呢？这里有四种方法哦~ a.第一种方法：将后面的内联块设置左外边距为负值，值为父元素大小的0.25倍 举个例子，假设有两个内联块，直接给后面的内联块（第二个）的css样式设置为margin-left:-0.25m; b.第二种方法：用注释去掉换行符 这个方法可能有点不好理解，前面说了，使用内联块换行符会被解析，那么如果给换行符加上注释会不会解决这个问题呢？答案是肯定的~ 举个例子~ 12&lt;div&gt;&lt;/div&gt;&lt;!--加上注释--&gt;&lt;div&gt; &lt;/div&gt; c.第三种方法：设置字间距（letter-spacing）为-0.25倍 也就是css样式里加上letter-spacing:-0.25em; d.第四种方法：将父元素的字体大小设置为0，在子元素里重新设置字体大小 这个方法很容易理解，这里就不举例啦！！ 我们可以发现，使用内联块实现区块元素并排显示其实非常麻烦，那么有没有更加方便的方法呢？ 浮动元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住：float：left/right/none(默认值)，由于子元素脱离文档流，结果会使父元素高度崩塌，解决浮动元素脱离文档流不占位的方法 我们可以看到，浮动会使父元素高度崩塌。Therefore，解决父元素高度崩塌的方法来啦~ 方法1：给父元素设置高度 ​ 局限性：（1）不确定高度时无法使用；（2）在内容、数量不确定时也无法使用 方法2：将父元素设置为BFC盒子，也就是说不能用浮动方法，要在父元素的css样式里写为overflow:hidden; ​ 局限性：在父元素有溢出部分时无法使用 方法3：为所有浮动元素后面设置一个空元素，在里面设置清除浮动clear:both 举个例子：div元素需要左浮动，我们需要在div元素后面设置空元素span 12345678910&lt;style&gt; div&#123; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;span syyle="display:block; clear:both;"&gt;&lt;/span&gt;&lt;/body&gt; ​ 局限性：创建了一个没有任何意义的空标签 方法4：为父元素设置after伪元素，在该元素上设置清除浮动clear:both; ​ 局限性：低版本的IE浏览器不识别 解决办法：用.cearfix{*zoom:1}来兼容 也就是说这个方法几乎没有缺点，是最优方法 好啦让我们来举例叭 假设有4个div元素，其中一个类名为parent元素是父元素（边框为2px black solid），为这三个div元素设置浮动并清除 123456789101112131415161718192021222324&lt;style&gt; .parent&#123; border:2px black solid; &#125; /*设置伪元素，清除浮动*/ .parent::after&#123; display:block; content:""; clear:both; &#125; .parent&gt;div&#123; width:100px; height:100px; background-color:red; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的选择器扩展]]></title>
    <url>%2F2019%2F07%2F01%2Fcss%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分组选择器：注：以下两种书写方式一般没有区别，但也有特殊情况。假设p标签也有一个类名为class，地址名为id的元素，就必须要在最前面加上标签名 12.class,#id /*选择类名为class的所有选择和地址名为id的元素*/div.class,#id /*选择div的所有后代中类名为.class的元素和地址名为id的元素*/ 多条件选择器：同时满足类名为box1和box2的元素 1.box1.box2 /*既有类名为box1的元素同时也有类名为box2的元素*/ 子元素选择器：1div&gt;.class /*选择div元素的所有子元素中有类名为class的元素*/ next选择器：1div+p /*选择div元素的下个同级元素且标签为p的元素*/ 伪类选择器（状态性伪类）：注：以下的标签a的4个伪类必须按照lvha的顺序书写，否则可能会出错 1234 a:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接（正在击中）*/ 举个状态性伪类的例子：设计一个div盒子（宽200px高200px、红色），要求：当鼠标移动该盒子上时盒子变为蓝色，当鼠标点击该盒子时盒子的宽和高分别为500px和150px 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;状态性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:200px; height:200px; background-color:red; &#125; div:hover&#123; background-color:blue; &#125; div:active&#123; width:150px; height:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器（结构性伪类）：注：before 和after中必须设置content(内容)和display(种类)两个样式，否则无法正确显示 1234p::before /*在每个p元素的内容之前插入内容*/p::after /*在每个p元素的内容之后插入元素*/display /*用来修改元素种类，分别有block（区块元素）、inline(内联元素)、inline-block（内联块元素）、none（隐藏元素，不占用物理空间）*/content:"" /*引号里写要显示的内容，如果没有要显示的内容就空着*/ 举个伪元素选择器（结构性伪类）的例子：写一个div元素(300,300)，为它设置before伪元素（区块元素 150px,150px），当你的鼠标移入div时让伪元素背景颜色发生变化，在div上击中时，伪元素隐藏 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;结构性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:300px; height:300px; background-color:brown; &#125; /*先把div元素转换为伪元素*/ div::before&#123; content:""; display:block; width:150px; height:150px; background-color:chartreuse; &#125; /* 鼠标移伪元素时改变颜色 * 格式：div:hover::befere */ div:hover::before&#123; background-color:cornflowerblue; &#125; div:active::before&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于表格的一些基础知识~]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%85%B3%E4%BA%8E%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先让我们认识一些表格标签12345678&lt;table&gt; &lt;!-- 定义表格（必不可少） --&gt;&lt;caption&gt; &lt;!-- 表格标题（默认居中） --&gt;&lt;thead&gt; &lt;!-- 表格表头 --&gt;&lt;tbody&gt; &lt;!-- 表格正文（必不可少） --&gt;&lt;tfoot&gt; &lt;!-- 表格页脚 --&gt;&lt;th&gt; &lt;!-- 表头单元格（加粗黑体） --&gt;&lt;tr&gt; &lt;!-- 表格行 --&gt;&lt;td&gt; &lt;!-- 表格单元格 --&gt; 举个例子： 123456789101112131415&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;我是第一列表头单元格&lt;/th&gt; &lt;th&gt;我是第二列表头单元格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;我是第一列&lt;/td&gt; &lt;td&gt;我是第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 这是一张2行2列的表格，第一行是表头单元格，第二行是表格正文。在浏览器运行后会发现，不仅单元格间有间隙，表格内边距也有。为了解决这个问题，表格属性来啦1234567891011- ##### 表格属性 ```css cellspacing ------单元间间隙(用于table标签) cellpadding ------表格内边距(用于table标签) colspan=&quot;2&quot; ------横向合并单元格(用于td标签)，2代表两个单元格合并 rowspan=&quot;2&quot; ------纵向合并单元格(用于td标签) ```再试一下，在table标签里加入了cellspacing=&quot;0&quot;，cellpadding=&quot;0&quot;后就不存在这样的问题了 表格样式：为表格和单元格设置border等样式，否则无法看到表格边框，除此外table的border-collapse样式，可以用来合并相邻单元格的边框 1border-collapse:collapse; /* 用于table标签中，注：使用该样式时要把单元间间隙（cellsapcing）设为0 */ 以上就是最简单的表格的制作啦~~ 接下来再举一个小例子：（加上css样式和合并单元格）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;简单的表格制作&lt;/title&gt; &lt;style&gt; table,td,th&#123; border:1px black solid; &#125; table&#123; border-collapse:collapse;/*合并相邻的单元格边框*/ &#125; td,th&#123; width:100px; height:30px; text-align:center; /*所有文字居中*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspancing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--第一行的第一列和第二列合并--&gt; &lt;th colspan="2"&gt;第一行第一列表头单元格&lt;/th&gt; &lt;!--&lt;th&gt;第一行第二列表头单元格&lt;/th&gt;*/--&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;td rowspan="2"&gt;我是第二行第一列&lt;/td&gt; &lt;td&gt;我是第二行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;!--&lt;td&gt;我是第三行第一列&lt;/td&gt;--&gt; &lt;td&gt;我是第三行第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 最后来说一下table表格的缺点~ 太深的嵌套，如table&gt;tbody&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了代码量 灵活性差，比如要将tr设置border等属性，是不行的，得通过td 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱 table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间 不够语义，无论是计算机还是阅读代码的人在阅读时都觉得非常困难]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目： 使用冒泡排序编写程序，实现对数组{25,24,12,76,101,96,28}的排序 2.源代码： 123456789101112131415161718192021222324252627package interest;public class pubble &#123; public static void main(String[] args) &#123; int[] arr=&#123;25,24,12,76,101,96,28&#125;; for(int i=0;i&lt;arr.length-1;i++) &#123; for(int j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println(&quot;冒泡排序的结果是：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非负十进制整数转换为b进制数]]></title>
    <url>%2F2019%2F06%2F07%2F%E9%9D%9E%E8%B4%9F%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BAb%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目名称 将非负十进制整数n转换成b进制。（其中b=2~16） 2.算法构造 （1）递归： 十进制数对b进制取余，若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示。然后利用递归模型返回十进制数和b进制的值，最后利用StringBuilder实现逆序输出字符串 递归模型：duigui(n,b)= duigui(n/b,b) n&gt;=0 递归出口：n&lt;b (其中为是十进制数，b为进制数) （2）非递归： 当十进制数不为0时，十进制数对b进制取余，十进制数变为原来的十进制数/b进制。若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示，最后利用StringBuilder实现逆序输出字符串 5.经验归纳 5.1遇到的问题 &lt;1&gt;刚开始用的是数组，结果发现不用循环很难把字符赋给数组 &lt;2&gt;逆序输出那里考虑不周全 &lt;3&gt;用递归树或者递归栈描述调用过程 5.2心得体会 这次的基本要求没有什么难点，主要就是递归函数的建立，非递归比递归简单一些，就是在最后的逆序输出那里会遇到问题，上网查了一下，说是可以用StringBuffer来实现，所以基本上没什么大问题。对了~画出递归树或者递归栈的调用过程这里也是问题，第一次画，对这个概念不是很熟悉。 附：源代码 1.Test0类（主方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;import java.util.Scanner;public class Test0 &#123; static int n; static int b; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); TwoMethods t=new TwoMethods(); System.out.println(&quot;请输入一个非负整数：&quot;); n=sc.nextInt(); while(true) &#123; if(n&lt;0) &#123; System.out.println(&quot;Error！请输入一个非负整数：&quot;); n=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); while(true) &#123; if(b&lt;1||b&gt;16) &#123; System.out.println(&quot;Error！请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;你想使用哪种方法进行运算？1.递归 2.非递归（1/2）：&quot;); int x=sc.nextInt(); switch(x) &#123; case 1: //调用递归方法 t.digui(n,b); break; case 2: t.feidigui(n,b);//调用非递归方法 break; &#125; sc.close(); &#125;&#125; 2.两种方法实现转换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;public class TwoMethods &#123; static String a=&quot;&quot;; //定义一个字符串，用来存储b进制 static int num; //b进制数 public static void feidigui(int n,int b) //非递归 &#123; while(n&gt;0) //当十进制数不为0时 &#123; num=n%b; //十进制数对b进制取余 n=n/b; //十进制数变为原来的十进制数/b进制 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; &#125; System.out.println(&quot;用非递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; public void digui(int n,int b) //递归 &#123; if(n!=0) &#123; num=n%b; //十进制数对b进制取余 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; digui(n/b,b); //利用递归模型返回十进制数和b进制的值 &#125; else &#123; System.out.println(&quot;用递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的递归程序]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目名称 &lt;1&gt;赶鸭子问题：一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？ &lt;2&gt;角谷定理：输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。 如：输入22， 输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 STEP=16 2.题目分析 &lt;1&gt;赶鸭子问题：假设一共有sum只鸭子，而sum=one(n)，n表示村子数，每经过一个村子就卖出one(n)/2+1只鸭子，剩下的就是下一个村子的鸭子数，也就是one(n+1)，那么鸭子总数one(n)=(one(n)/2+1)+(one(n+1))，经过运算得出鸭子总数one(n)=(one(n+1)+1)_2；题目说这个人经过七个村子后还剩两只鸭子，也就是在第8个村子的时候还有两只鸭子，也就是one(8)=2 &lt;2&gt;角谷定理：这个题的递归出口是固定的，即当得到自然数值1的时候递归结束。假设经过了sum=one(x)次操作后得到自然数1，输入的自然数一共分为3种情况，第一种是x=1，这种情况很特殊，直接sum+1输出即可；第二种情况是x为偶数，按照题目要求，将这个数有限次除以2，也就是one(x/2)，并使sum递加；第三种情况是x为奇数，将这个数有限次乘以3再加1，也就是one(x_3+1)，并使sum递加 3.算法构造 4.心得体会 递归问题主要还是数学思维，我觉得第一个题用递归方法偏难一点，但是算法构造出来实现就简单了，这两个题学C语言的时候有接触过，所以还有印象。这两道题相对以前的作业简单很多~ 附：源代码： &lt;1&gt;赶鸭子问题： 123456789101112131415161718192021222324252627282930package DuckSale;public class 卖鸭子递归 &#123; static int sum; public static void main(String[] args) &#123; int n=1; int num;//每个村子卖出的鸭子数 int sum=one(n); //刚开始的鸭子数,n个村子 System.out.println(&quot;刚开始有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++)//循环输出经过每个村子卖出的鸭子数 &#123; num=sum/2+1; sum-=num; //剩余鸭子数 System.out.println(&quot;经过第&quot;+i+&quot;个村子卖出了&quot;+num+&quot;只鸭子,还剩下&quot;+sum+&quot;只鸭子&quot;); &#125; &#125; public static int one(int n) &#123; if(n&lt;8) &#123; return 2*(one(n+1)+1); &#125; else if(n==8) &#123; return 2; &#125; return n; &#125;&#125; ②非递归实现： 1234567891011121314151617181920package DuckSale;public class 卖鸭子非递归&#123; static int sum=2;//鸭子总数 public static void main(String[] args) &#123; int num; for(int i=1;i&lt;8;i++) &#123; sum=(sum+1)*2;//循环计算出鸭子总数 &#125; System.out.println(&quot;一共有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++) &#123; num=sum/2+1; sum-=num; System.out.println(&quot;经过第&quot;+i+&quot;个村子卖了&quot;+num+&quot;只鸭子，还剩&quot;+sum+&quot;只鸭子&quot;); &#125; &#125;&#125; &lt;2&gt;角谷定理： ①递归实现： 12345678910111213141516171819202122232425262728293031323334353637package JiaoGuTheory;import java.util.Scanner;public class 角谷定理递归 &#123; static int sum=0; //计算次数 public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); int sum=one(x); System.out.println(); System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125; public static int one(int x) &#123; if(x==1) //输入的自然数为1 &#123; System.out.print(x+&quot; &quot;); sum++; &#125; else if(x%2==0) //输入的自然数为偶数 &#123; System.out.print(x+&quot; &quot;); one(x/2);//将这个数有限次除以2 sum++; &#125; else if(x%2!=0) //输入的自然数为奇数 &#123; System.out.print(x+&quot; &quot;); one(x*3+1); //将这个数有限次乘以3再加1 sum++; &#125; return sum; &#125;&#125; ②非递归实现： 1234567891011121314151617181920212223242526272829303132333435package JiaoGuTheory;import java.util.Scanner;public class 角谷定理非递归 &#123; static int sum=0; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); while(x&gt;=1) &#123; if(x==1) &#123; sum++; System.out.println(x); break; &#125; else if(x%2==0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x/2; &#125; else if(x%2!=0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x*3+1; &#125; &#125; System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟肯德基快餐店的收银系统]]></title>
    <url>%2F2019%2F05%2F10%2FJava%E6%A8%A1%E6%8B%9F%E8%82%AF%E5%BE%B7%E5%9F%BA%E5%BF%AB%E9%A4%90%E5%BA%97%E7%9A%84%E6%94%B6%E9%93%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1.题目名称 模拟肯德基快餐店的收银系统 要求：结合设计模式（2种以上）至少实现系统的以下功能： 1.正常餐品结算和找零。 2.基本套餐结算和找零。 3.使用优惠劵购买餐品结算和找零。 4.可在一定时间段参与店内活动（自行设计或参考官网信息）。 5.模拟打印小票的功能（写到文件中）。 2.算法构造 这个系统需要用到两种设计模式，分别是工厂方法模式和抽象工厂模式。 &lt;1&gt;工厂方法模式：在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口。 抽象工厂(IKfcFactory)：给出具体工厂必须实现的接口； 具体工厂(ChinaKfcFactory)：在该工厂中指明生产各种抽象食物的方法：生产汉堡、薯条、鸡翅、饮料、套餐1、套餐2； 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：负责输出用户的订单信息 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：这个工厂需要生产具体的食品：麻辣奥尔良烤堡、奥尔良烤翅、普通霸王薯条、可乐饮料。 &lt;2&gt;抽象工厂模式：抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 抽象工厂(AbstractBaseFood) 具体工厂(ChinaKfcFactory) 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：相当于产品等级 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：相当于产品族，生产出具体的食物 客户类(Customer)：向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 3.类图 4.调试及运行结果 4.1调试结果 4.2运行结果 1.选择单点： 2.选择套餐 4.文件里的账单（在eclipse中打开.txt文件） 5.经验归纳 5.1遇到的问题 &lt;1&gt;将账单写入文件后.txt文件里什么都没有~ &lt;2&gt;不熟悉抽象工厂模式，将工厂方法模式和抽象方法模式混在一起了 &lt;3&gt;单品的种类太少，抽象工厂模式运用的不全面 &lt;4&gt;该系统还存在一些不足，打算后期进行优化 5.2心得体会 这个系统中，最核心的就是设计模式的选择与应用了！个人感觉我做的系统用的工厂方法模式比抽象工厂模式全面一些，因为每一种食品只有一种，没有分很多种，所以产品族的产品对象是不全面的。 还有一个很大的问题，就是账单没有办法写入文件中。我选择的是FileWriter方法将账单写入文件的，然而文件中却什么都没有。后来我发现在eclipse中打开.txt文件，账单是在文件里的，所以我没有用记事本打开.txt文件，而是选择了eclipse。 其实我觉得界面可以用Java的图形图像处理来实现，还涉及到数据库，打算考完试实现一下~~ 附：源代码 1.AbstractBaseFood接口 1234567891011121314151617package inter.KFC;//食物基类 public abstract class AbstractBaseFood &#123; //类别 protected String kind; //数量 protected int num; //价格 protected int price; //合计 public int totalPrice() &#123; return this.num * this.price; &#125;&#125; 2.抽象食物接口IFood 123456789package inter.KFC; //抽象食物接口 public interface IFood &#123; //打印输出食物信息 void printMessage();&#125; 3.肯德基抽象工厂接口IKfcFactory 12345678910111213141516171819202122232425package inter.KFC;//肯德基抽象工厂 public interface IKfcFactory &#123; //生产汉堡 public Hamburg createHamburg(int num); //生产薯条 public FrenchFries createFrenchFries(int num); //生产鸡翅 public ChickenWings createChickenWings(int num); //生产饮料 public Beverage createBeverage(int num); //生产套餐1 public TaoCan1 createTaoCan1(int num); //生产套餐2 public TaoCan2 createTaoCan2(int num);&#125; 4.肯德基具体工厂ChinaKfcFactory继承接口IKfcFactory 123456789101112131415161718192021222324252627282930313233343536package inter.KFC;//肯德基具体工厂public class ChinaKfcFactory implements IKfcFactory&#123; //生产汉堡 public Hamburg createHamburg(int num) &#123; return new ChinaHamburg(num); &#125; //生产薯条 public FrenchFries createFrenchFries(int num) &#123; return new ChinaFrenchFries(num); &#125; //生产鸡翅 public ChickenWings createChickenWings(int num) &#123; return new ChinaChickenWings(num); &#125; //生产饮料 public Beverage createBeverage(int num) &#123; return new ChinaBeverage(num); &#125; //生产套餐1 public TaoCan1 createTaoCan1(int num) &#123; return new RealTaoCan1(num); &#125; //生产套餐2 public TaoCan2 createTaoCan2(int num) &#123; return new RealTaoCan2(num); &#125; &#125; 5.客户类Customer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package inter.KFC;//客户类public class Customer &#123; //抽象工厂 private IKfcFactory kfcFactory; //构造方法将抽象工厂作为参数传入 public Customer(IKfcFactory kfcFactory)&#123; this.kfcFactory = kfcFactory; &#125; //订购食物 //订购麻辣鸡腿汉堡 public int orderHamburg(int num)&#123; //获得奥尔良烤堡 Hamburg hamburg = kfcFactory.createHamburg(num); //输出订购信息 hamburg.printMessage(); //返回总价 return hamburg.totalPrice(); &#125; //订购奥尔良烤翅 public int orderChickenWings(int num)&#123; //获得奥尔良烤鸡翅 ChickenWings chickenWings = kfcFactory.createChickenWings(num); //输出订购信息 chickenWings.printMessage(); //返回总价 return chickenWings.totalPrice(); &#125; //订购薯条 public int orderFrenchFries(int num)&#123; //获得霸王薯条 FrenchFries frenchFries = kfcFactory.createFrenchFries(num); //输出订购信息 frenchFries.printMessage(); //返回总价 return frenchFries.totalPrice(); &#125; //订购可乐 public int orderBeverage(int num)&#123; //获得可乐 Beverage beverage = kfcFactory.createBeverage(num); //输出订购信息 beverage.printMessage(); //返回总价 return beverage.totalPrice(); &#125; //订购套餐1 public int orderTaoCan1(int num)&#123; //获得套餐1 TaoCan1 taocan1=kfcFactory.createTaoCan1(num); //输出订购信息 taocan1.printMessage(); //返回总价 return taocan1.totalPrice(); &#125; //订购套餐2 public int orderTaoCan2(int num)&#123; //获得套餐2 TaoCan2 taocan2=kfcFactory.createTaoCan2(num); //输出订购信息 taocan2.printMessage(); //返回总价 return taocan2.totalPrice(); &#125;&#125; 6.汉堡基类Hamburg 1234567891011package inter.KFC;//汉堡基类 public abstract class Hamburg extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;奥尔良烤堡，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 7.汉堡子类(具体产品实现)ChinaHamburg 12345678910111213package inter.KFC;//奥尔良烤堡//具体产品public class ChinaHamburg extends Hamburg&#123; public ChinaHamburg(int num) &#123; this.kind = &quot;麻辣&quot;; this.price = 28; this.num = num; &#125;&#125; 8.薯条基类(抽象产品)FrenchFries 123456789101112package inter.KFC;//薯条基类//抽象产品public abstract class FrenchFries extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;霸王薯条，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 9.薯条子类(具体产品实现)ChinaFrenchFries 123456789101112package inter.KFC;//薯条实现类//具体产品public class ChinaFrenchFries extends FrenchFries&#123; public ChinaFrenchFries(int num) &#123; this.kind = &quot;普通&quot;; this.price = 8; this.num = num; &#125;&#125; 10.鸡翅基类(抽象产品)ChickenWings 1234567891011package inter.KFC;//鸡翅基类public abstract class ChickenWings extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;烤翅，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 11.鸡翅子类(具体产品实现)ChinaChickenWings 123456789101112package inter.KFC;//鸡翅实现类 //具体产品public class ChinaChickenWings extends ChickenWings&#123; public ChinaChickenWings(int num) &#123; this.kind = &quot;奥尔良&quot;; this.price = 5; this.num = num; &#125;&#125; 12.饮料基类(抽象产品)Beverage 1234567891011package inter.KFC;//饮料基类 public abstract class Beverage extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;饮料，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 13.饮料子类(具体产品实现)ChinaBeverage 1234567891011package inter.KFC;//可乐实现类public class ChinaBeverage extends Beverage&#123; public ChinaBeverage(int num) &#123; this.kind = &quot;可乐&quot;; this.price = 10; this.num = num; &#125;&#125; 14.套餐1基类(抽象产品)TaoCan1 12345678910package inter.KFC;//套餐1基类public abstract class TaoCan1 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐1，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 15.套餐1子类(具体产品实现)RealTaoCan1 1234567891011package inter.KFC;//套餐1实现类public class RealTaoCan1 extends TaoCan1&#123; public RealTaoCan1(int num) &#123; this.kind = &quot;超值&quot;; this.price = 50; this.num = num; &#125;&#125; 16.套餐2基类(抽象产品)TaoCan2 12345678910package inter.KFC;//套餐2基类public abstract class TaoCan2 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐2，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 17.套餐2子类(具体产品实现)RealTaoCan2 1234567891011package inter.KFC;//套餐2实现类public class RealTaoCan2 extends TaoCan2&#123; public RealTaoCan2(int num) &#123; this.kind = &quot;超值&quot;; this.price = 40; this.num = num; &#125;&#125; 18.菜单类MainMenu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package inter.KFC;import java.util.Scanner;import java.io.*;import java.io.FileWriter;//菜单public class MainMenu &#123; //定义一个肯德基（IKfcFactory类型） IKfcFactory kfcFactory = new ChinaKfcFactory(); //创建客户 Customer customer = new Customer(kfcFactory); Scanner sc=new Scanner(System.in); public int a; public int num1; public int num2; public int num3; public int num4; public int num5; public int num6; int hamburgMoney=customer.orderHamburg(num1); int chickenWingsMoney = customer.orderChickenWings(num2); int frenchFriesMoney = customer.orderFrenchFries(num3); int singleMoney = customer.orderBeverage(num4); int taocan1Money =customer.orderTaoCan1(num5); int taocan2Money =customer.orderTaoCan2(num6); public int price; public String b; public int c; public int d; //用户付款金额 public int e; //找零 public void menu() &#123; System.out.println(&quot;* * * * * 欢迎进入肯德基炸鸡店 * * * * *&quot;); System.out.println(&quot;* 您可以选择：1.单点 2.套餐 *&quot;); System.out.println(&quot;* 请您选择：&quot;); a=sc.nextInt(); switch(a) &#123; case 1: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;1.汉堡类：奥尔良烤堡_28元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;2.鸡翅类：奥尔良烤翅_5元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;3.小食类：霸王薯条_8元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;4.饮料类：可乐_10元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择奥尔良烤堡的数量：&quot;); num1=sc.nextInt(); hamburgMoney = customer.orderHamburg(num1); System.out.print(&quot;请您选择奥尔良烤翅的数量：&quot;); num2=sc.nextInt(); chickenWingsMoney = customer.orderChickenWings(num2); System.out.print(&quot;请您选择霸王薯条的数量：&quot;); num3=sc.nextInt(); frenchFriesMoney = customer.orderFrenchFries(num3); System.out.print(&quot;请您选择可乐的数量：&quot;); num4=sc.nextInt(); singleMoney = customer.orderBeverage(num4); price=hamburgMoney+chickenWingsMoney+frenchFriesMoney+singleMoney; System.out.println(&quot;总计：&quot;+price); break; case 2: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐1：奥尔良烤堡+霸王薯条+可乐_50元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐2：香辣鸡腿堡+麻辣烤翅+可乐_40元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择套餐1的数量：&quot;); num5=sc.nextInt(); taocan1Money =customer.orderTaoCan1(num5); System.out.print(&quot;请您选择套餐2的数量：&quot;); num6=sc.nextInt(); taocan2Money =customer.orderTaoCan2(num6); price=taocan1Money+taocan2Money; System.out.println(&quot;总计：&quot;+price); &#125; &#125; //领取优惠券并付款找零 public void other()&#123; System.out.println(&quot;为迎接新老顾客的到来，本店特地准备了两种优惠券&quot;); System.out.println(&quot;---1.满45减5 ---2.满65减8&quot;); System.out.print(&quot;您是否需要优惠券？(y/n)&quot;); String b=sc.next(); if(&quot;y&quot;.equals(b)) &#123; if(price&gt;=45&amp;&amp;price&lt;65) //价格在45-65之间领取5元 &#123; price-=5; c=5; //5元优惠券 &#125; else if(price&gt;=65) //价格&gt;=65领取8元 &#123; price-=8; c=8; &#125; else System.out.println(&quot;您不能使用优惠券！&quot;); System.out.println(&quot;领取&quot;+c+&quot;元优惠券成功！您一共消费：&quot;+price+&quot;元&quot;); &#125; System.out.print(&quot;付款：&quot;); d=sc.nextInt(); e=d-price; System.out.println(&quot;找零：&quot;+e); &#125; //打印账单 public void paint()&#123; System.out.print(&quot;您需要打印账单吗？(y/n)&quot;); String m=sc.next(); if(&quot;y&quot;.equals(m))&#123; //用户需要打印小票 System.out.println(&quot;您的账单为：&quot;); switch(a)&#123; case 1: hamburgMoney=customer.orderHamburg(num1); chickenWingsMoney = customer.orderChickenWings(num2); frenchFriesMoney = customer.orderFrenchFries(num3); singleMoney = customer.orderBeverage(num4); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; case 2: taocan1Money =customer.orderTaoCan1(num5); taocan2Money =customer.orderTaoCan2(num6); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; &#125; try&#123; fully(); &#125;catch(Exception e)&#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; else if(&quot;n&quot;.equals(m))&#123; System.out.println(&quot;欢迎下次光临~&quot;); &#125; &#125; //在文件中打印小票 public void fully() throws Exception&#123; FileWriter pw=new FileWriter(&quot;zhangdan.txt&quot;,true); BufferedWriter bw=new BufferedWriter(pw); try &#123; switch(a) &#123; case 1: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;麻辣奥尔良烤堡 &quot;+&quot;单价：28 数量：&quot;+num1+&quot;合计：&quot;+hamburgMoney+&quot;\r\n&quot;); bw.write(&quot;奥尔良烤翅 &quot;+&quot;单价：5 数量：&quot;+num2+&quot;合计：&quot;+chickenWingsMoney+&quot;\r\n&quot;); bw.write(&quot;普通霸王薯条 &quot;+&quot;单价：8 数量：&quot;+num3+&quot;合计：&quot;+frenchFriesMoney+&quot;\r\n&quot;); bw.write(&quot;可乐饮料 &quot;+&quot;单价：10 数量：&quot;+num4+&quot;合计：&quot;+singleMoney+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; case 2: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;超值套餐1 &quot;+&quot;单价：50 数量：&quot;+num5+&quot;合计：&quot;+taocan1Money+&quot;\r\n&quot;); bw.write(&quot;超值套餐2 &quot;+&quot;单价：40 数量：&quot;+num6+&quot;合计：&quot;+taocan2Money+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;打印成功！欢迎下次光临~&quot;); &#125; &#125; 19.主函数MainApp 12345678910111213141516package inter.KFC;import java.util.*;import java.text.*; //获取当前系统时间public class MainApp &#123; public static void main(String[] args) &#123; Date date=new Date(); DateFormat fullFormat=DateFormat.getDateInstance(DateFormat.FULL); System.out.println(&quot;当前日期：&quot;+fullFormat.format(date)); //引用菜单类 MainMenu mainmenu=new MainMenu(); mainmenu.menu(); mainmenu.other(); mainmenu.paint(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种简单的程序设计模式实例]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.题目名称 (1)简单工厂模式 使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果传入参数M，则返回一个Man对象，如果传入参数W，则返回一个Woman对象，请实现该场景。现需要增加一个新的Robot类，如果传入参数R，则返回一个Robot对象，对代码进行修改并注意女娲的变化。 (2)工厂方法模式 海尔工厂(Haier)生产海尔空调(HaierAirCondition)，美的工厂(Midea)生产美的空调(MideaAirCondition) 。使用工厂方法模式描述该场景，绘制类图并编程实现。(3)抽象工厂模式 电脑配件生产工厂生产内存、CPU等硬件设备，这些内存、CPU的品牌、型号并不一定相同，根据下面的“产品等级结构-产品族”示意图，使用抽象工厂模式实现电脑配件生产过程并绘制相应的类图，绘制类图并编程实现。 2.题目分析 (1)简单工厂模式 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 &lt;1&gt;工厂角色(Nvwa)：实现所有实例的内部逻辑； &lt;2&gt;抽象产品角色(Person)：所有对象的父类，负责描述所有实例共有的公共接口； &lt;3&gt;具体产品角色(Man,Woman,Robot)：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实现； &lt;4&gt;XML配置文件(XMLUtilNvwa,Simple.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (2)工厂方法模式 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 &lt;1&gt;抽象产品(KongTiao)：产品对象同一的基类，或者是同一的接口； &lt;2&gt;具体产品(Haier,Midea)：各个不同的实例对象类； &lt;3&gt;抽象工厂(KongTiaoFactory)：所有的子类工厂类的基类，或是同一的接口； &lt;4&gt;具体工厂(HaierFactory,MideaFactory)：负责每个不同的产品对象的实际创建； &lt;5&gt;XML配置文件(XMLUtil,FactoryMethod.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (3)抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 产品等级结构：即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 &lt;1&gt;抽象工厂(ComputerFactory)：模式的核心，通常是接口或抽象类，其他的具体工厂类必须实现这个接口或继承这个抽象类； &lt;2&gt;具体工厂(macFactory,pcFactory)：直接在客户端的调用下创建产品的实例； &lt;3&gt;抽象产品(CPU,RAM)：工厂模式所创建的对象的父类，或他们共同的接口； &lt;4&gt;具体产品(pcCPU,macCPU,pcRAM,macRAM)：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。 &lt;5&gt;XML配置文件(XMLUtil,AbstractFactory.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 3.类图设计 (1)简单工厂模式： (2)工厂方法模式： (3)抽象工厂模式： 4.经验归纳 4.1遇到的问题 &lt;1&gt;对三种模式都不太熟悉，花费的时间较多 &lt;2&gt;不懂如何解析xml文档 &lt;3&gt;eclipse版本问题导致XMLUtil代码有错误，但可以运行 4.2心得体会 第一次编写程序设计模式的代码，刚开始觉得无从下手。对三种模式不熟悉，导致花费了较多的时间，所以一直在查资料。特别实在xml文档那块，我一直没搞懂为什么要写文档而不直接用输入输出流，结果发现是将参数保存在XML的配置文件中，这样修改参数的时候就没有必要修改任何Java源代码。但是这块还是挺薄弱的，写代码的时候也不能独立完成，还需要参考老师给的代码。第一个简单工厂模式挺简单的，第三个比较难（我觉得），所以要多练习抽象工厂模式的习题~ 附：源代码 (1)简单工厂模式 &lt;1&gt;抽象产品角色(父类):Person 12345package Nvwa;public interface Person&#123; public void make();&#125; &lt;2&gt;工厂角色(实现内部逻辑):Nvwa 1234567891011121314151617181920212223242526package Nvwa;public class Nvwa &#123; public static Person producePerson(String sex) throws Exception &#123; if(sex.equalsIgnoreCase(&quot;M&quot;)) //选择&apos;M&apos; &#123; System.out.println(&quot;造了一个男人！&quot;); return new Man(); //返回参数 &#125; else if(sex.equalsIgnoreCase(&quot;W&quot;))//选择&apos;W&apos; &#123; System.out.println(&quot;造了一个女人！&quot;); return new Woman(); &#125; else if(sex.equalsIgnoreCase(&quot;R&quot;))//选择&apos;R&apos; &#123; System.out.println(&quot;造了一个机器人！&quot;); return new Robet(); &#125; else &#123; throw new Exception(&quot;对不起，女娲正在忙，没空造人！&quot;); &#125; &#125;&#125; &lt;3&gt;具体产品角色(实现类):Man,Woman,Robet: Man: 12345678package Nvwa;public class Man implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造男人...&quot;); &#125;&#125; Woman: 12345678package Nvwa;public class Woman implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造女人...&quot;); &#125;&#125; Robot: 12345678package Nvwa;public class Robet implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造机器人...&quot;); &#125;&#125; &lt;4&gt;XML配置文件(方便修改参数):XMLUtilNvwa,Simple.xml XMLUtilNvwa： 12345678910111213141516171819202122232425262728293031XMLUtilNvwa：package Nvwa;import javax.xml.parsers.*;import org.w3c.dom.*;//import org.xml.sax.SAXException;import java.io.*;public class XMLUtilNvwa &#123; //该方法用于从XML配置文件中提取名称，并返回该名称 public static String getSexName() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;Simple.xml&quot;)); //获取包含名称的文本节点 NodeList nl = doc.getElementsByTagName(&quot;sexName&quot;); Node classNode=nl.item(0).getFirstChild(); String sexName=classNode.getNodeValue().trim(); return sexName; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; Simple.xml: 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;sexName&gt;M&lt;/sexName&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 123456789101112131415161718package Nvwa;public class Client &#123; public static void main(String args[]) &#123; try &#123; Person pe; String sexName=XMLUtilNvwa.getSexName(); pe=Nvwa.producePerson(sexName); pe.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (2)工厂方法模式 &lt;1&gt;抽象产品：KongTiao 12345package FactoryMethod;public interface KongTiao &#123; public void make();&#125; &lt;2&gt;具体产品：Haier,Midea Haier： 12345678package FactoryMethod;public class Haier implements KongTiao&#123; public void make() &#123; System.out.println(&quot;海尔空调正在使用...&quot;); &#125;&#125; Midea： 12345678package FactoryMethod;public class Midea implements KongTiao&#123; public void make() &#123; System.out.println(&quot;美的空调正在使用...&quot;); &#125;&#125; &lt;3&gt;抽象工厂：KongTiaoFactory 12345package FactoryMethod;public interface KongTiaoFactory &#123; public KongTiao produceKT();&#125; &lt;4&gt;具体工厂：HaierFactory,MideaFactory HaierFactory： 123456789package FactoryMethod;public class HaierFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---海尔工厂正在生产海尔空调 &quot;); return new Haier(); &#125;&#125; MideaFactory： 12345678package FactoryMethod;public class MideaFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---美的工厂正在生产美的空调 &quot;); return new Midea(); &#125; &lt;5&gt;XML配置文件：XMLUtil,FactoryMethod.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123; //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;FactoryMethod.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; FactoryMethod.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;FactoryMethod.HaierFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 1234567891011121314151617package FactoryMethod;public class Client &#123; public static void main(String[] args) &#123; try&#123; KongTiao kt; KongTiaoFactory fa; fa=(KongTiaoFactory)XMLUtil.getBean(); kt=fa.produceKT(); kt.make(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (3)抽象工厂模式 &lt;1&gt;抽象工厂：ComputerFactory 123456package AbstractFactory;public interface ComputerFactory &#123; public CPU produceCPU(); public RAM produceRAM();&#125; &lt;2&gt;具体工厂：macFactory,pcFactory macFactory： 12345678910111213141516171819package AbstractFactory;public class macFactory implements ComputerFactory&#123; //生产macCPU public CPU produceCPU() &#123; System.out.println(&quot;生产了macCPU...&quot;); //CPU macCPU; return new macCPU(); &#125; //生产macRAM public RAM produceRAM() &#123; System.out.println(&quot;生产了macRAM...&quot;); return new macRAM(); &#125;&#125; pcFactory： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; &lt;3&gt;抽象产品：CPU,RAM CPU： 12345package AbstractFactory;public interface CPU &#123; public void make();&#125; RAM： 12345package AbstractFactory;public interface RAM &#123; public void make();&#125; &lt;4&gt;具体产品：pcCPU,macCPU,pcRAM,macRAM pcCPU： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; macCPU： 12345678package AbstractFactory;public class macCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;macCPU&quot;); &#125;&#125; pcRAM： 12345678package AbstractFactory;public class pcRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;pcRAM&quot;); &#125;&#125; macRAM： 12345678package AbstractFactory;public class macRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;macRAM&quot;); &#125;&#125; &lt;5&gt;XML配置文件：XMLUtil,AbstractFactory.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package AbstractFactory;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123;//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;AbstractFactory.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125;catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; AbstractFactory.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;AbstractFactory.macFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 12345678910111213141516171819202122package AbstractFactory;public class Client &#123; public static void main(String[] args) &#123; try &#123; ComputerFactory fac; CPU cpu; RAM ram; fac=(ComputerFactory)XMLUtil.getBean(); cpu=fac.produceCPU(); cpu.make(); ram=fac.produceRAM(); ram.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建RPG游戏角色]]></title>
    <url>%2F2019%2F04%2F17%2FJava%E5%88%9B%E5%BB%BARPG%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[◆题目名称 创建RPG游戏角色 ◆题目分析 该程序需要用到有关类与对象的知识点，所以不能使用C语言来编写代码，这里我选择Java语言。本题目要求的游戏角色应有以下属性：名字、性别、种族、职业、力量、敏捷、体力、智力、智慧、生命值和魔法值。本题目要求力量、敏捷、体力、智力和智慧要求是随机值（利用随机数函数来取得随机数），但是五项属性的总和应该是100，并且应该和职业相关。例如狂战士的体力和力量就要比较高，而巫师需要较高的智力，而祭司则需要较高的智慧。各职业初始属性的大致比例应遵从下表： 职业/属性 力量 敏捷 体力 智力 智慧 狂战士 40 20 30 5 5 圣骑士 25 15 30 20 10 刺客 20 35 20 15 10 猎手 15 40 15 10 20 祭司 15 20 15 35 15 巫师 10 20 10 20 40 例如，前面示意图中的祭司的初始属性，大致满足该比例，但是应该是随机的。然后利用属性值计算生命值和魔法值。 最后向用户显示该角色的所有信息，将用户创建角色的相关信息写入文件保存。 ◆算法构造 &lt;1&gt;玩家选择1，则进入游戏；选择2，可以查看游戏规则；选择3，则游戏结束。 &lt;2&gt;选择1：玩家先输入角色姓名、性别、种族以及职业，根据种族和职业的限制表判断玩家是否可以使用该职业，若不能则重新选择职业； &lt;3&gt;利用随机函数分别生成力量、敏捷、体力、智力和智慧五项属性，并将五项属性的总和控制在100，并且属性值和职业相关。可以由(int)(X+Math.random()_10-5)可以得到符合条件的属性值，其中X表示表1中的属性限定值，并计算生命值和魔法值：生命值=体力_20、魔法值=（智力+智慧）*10； &lt;4&gt;打印所有的信息并向用户显示出来； &lt;5&gt;将用户创建角色的相关信息写入txt文件保存。 ◆算法实现 写入文件代码： 123456789101112131415161718192021222324public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125; ◆调试及运行结果 ◆◆调试结果 ◆运行结果 ◆◆文件保存情况 ◆经验归纳 ◆◆遇到的问题 &lt;1&gt;对于Java中的类和对象用的还不是很熟练(还在努力学习中) &lt;2&gt;Java引用写入文件方法出问题(已解决) &lt;3&gt;Java写入文件方法内部出现异常(已解决) &lt;4&gt;IO流未声明(已解决) ◆◆心得体会 用Java写这个程序，让我查了不少有关Java的知识点。在类与对象那块还不太熟悉，其中，有一些知识点是值得记录的： ①访问另一个类中的某个方法：Start g=new Start();g.start(); ②对象引用：Random r=new Random();r.n=name; ③随机函数生成某个值：strength=(int)(40+Math.random()*10-5)(40是限制条件) ④调用写入文件方法： 12345try &#123; REFile(occ);&#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); 在百度文库查找资料的时候我发现可以将这个代码优化，即编为小游戏的形式，我打算找时间写一下。 附：源代码(部分代码参考百度文库) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package game;import java.io.*;import java.util.Scanner;import java.io.FileWriter;public class First &#123; public static void main(String[] args)&#123; //菜单 System.out.println(&quot;这是一个RPG游戏&quot;); System.out.println(&quot;1.开始游戏&quot;); System.out.println(&quot;2.游戏规则&quot;); System.out.println(&quot;3.结束游戏&quot;); System.out.print(&quot;请输入您想进行的操作：(1-3)&quot;); Scanner x=new Scanner(System.in); int num=x.nextInt(); switch(num)&#123; case 1: Start g=new Start(); g.start(); //访问Start类中的start方法开始创建角色 break; case 2: Rule r=new Rule(); r.rule(); //访问Rule类中的rule方法查看规则 break; default: System.out.println(&quot;游戏结束!&quot;); System.exit(0); //游戏结束标识 &#125; &#125;&#125;//开始游戏class Start&#123; int occ=0; String name; public void start()&#123; System.out.print(&quot;请输入您游戏角色的姓名：&quot;); Scanner a=new Scanner(System.in); String name=a.next(); System.out.print(&quot;请选择您游戏角色的性别：(男或女)&quot;); Scanner b=new Scanner(System.in); String sex=b.next(); System.out.print(&quot;请选择您游戏角色的种族：(1.人类,2.精灵,3.兽人,4.矮人,5.元素)&quot;); Scanner c=new Scanner(System.in); int race=c.nextInt(); switch(race)&#123; //职业选择 case 1: //种族为人类 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=1&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1-6之间的数字选择职业！！&quot;); &#125; break; case 2: //种族为精灵 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=3&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入3-6之间的数字选择职业！！&quot;); &#125; break; case 3: //种族为兽人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==4||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,4,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 4: //种族为矮人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==2||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,2,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 5: //种族为元素 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==5||occ==6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入5-6之间的数字选择职业！！&quot;); &#125; break; &#125; Random r=new Random(); r.n=name; //将姓名、性别、种族对象引用到Random类中 r.s=sex; r.ra=race; r.random(occ);//将职业传递到Random类的random方法中 &#125;&#125;//class Random&#123; String n; String s; int ra; int strength=0; //力量 int smart=0; //敏捷 int body=0; //体力 int talent=0; //智力 int wisdom=0; //智慧 int life=0; //生命值 int magic=0; //魔法值 public void random(int occ)&#123; //随机函数生成各个值 System.out.println(occ); if(occ==1) &#123; strength=(int)(40+Math.random()*10-5);//随机函数生成符合题目条件的各个值 smart=(int)(20+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(5+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==2)&#123; strength=(int)(25+Math.random()*10-5); smart=(int)(15+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==3)&#123; strength=(int)(20+Math.random()*10-5); smart=(int)(35+Math.random()*10-5); body=(int)(20+Math.random()*10-5); talent=(int)(15+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==4)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(40+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(10+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==5)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(35+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==6)&#123; strength=(int)(10+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(10+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; life=body*20; //计算生命值和魔法值 magic=(talent+wisdom)*10; print(occ); //调用打印方法 try &#123; //调用写入文件方法 REFile(occ); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //打印 public void print(int occ)&#123; System.out.println(&quot;* * * * * * * * * * * * *&quot;); System.out.println(&quot;* 姓名：&quot;+n+&quot; *&quot;); System.out.println(&quot;* 性别：&quot;+s+&quot; *&quot;); System.out.println(&quot;* 种族：&quot;+ra+&quot; *&quot;); System.out.println(&quot;* 职业：&quot;+occ+&quot; *&quot;); System.out.println(&quot;* 力量：&quot;+strength+&quot; *&quot;); System.out.println(&quot;* 敏捷：&quot;+smart+&quot; *&quot;); System.out.println(&quot;* 体力：&quot;+body+&quot; *&quot;); System.out.println(&quot;* 智力：&quot;+talent+&quot; *&quot;); System.out.println(&quot;* 智慧：&quot;+wisdom+&quot; *&quot;); System.out.println(&quot;* 生命值：&quot;+life+&quot; *&quot;); System.out.println(&quot;* 魔法值：&quot;+magic+&quot; *&quot;); System.out.println(&quot;* * * * * * * * * * * * *&quot;); &#125; //写入文件 public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125;//游戏规则class Rule&#123; public void rule()&#123; System.out.println(&quot;很多职业会限制某些种族选择,种族和职业的限制情况如下：(下表均为不允许)&quot;); System.out.println(&quot;┎---------------------------------------------┒&quot;); System.out.println(&quot;│ 种 类 职 业 │&quot;); System.out.println(&quot;│ 精灵 狂战士、圣骑士 │&quot;); System.out.println(&quot;│ 兽人 圣骑士、刺客、巫师 │&quot;); System.out.println(&quot;│ 矮人 刺客、猎手、巫师 │&quot;); System.out.println(&quot;│ 元素 狂战士、圣骑士、刺客、猎手 │&quot;); System.out.println(&quot;┖---------------------------------------------┚&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24点游戏简单版]]></title>
    <url>%2F2019%2F04%2F10%2F24%E7%82%B9%E6%B8%B8%E6%88%8F%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[●题目名称 24点游戏（经典的纸牌益智游戏） ●题目分析 随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，可以利用穷举法列出4个数字加减乘除的各种可能性，包括括号的算法，并且要利用循环控制计算范围，防止出现重复的表达式。 ●算法构造 &lt;1&gt;利用随机函数生成4个随机数 &lt;2&gt;将4个数所有可能的顺序列举，并调用计算函数 &lt;3&gt;循环调用使4个数字分别进行两两运算，并将表达式储存在一个数组中 &lt;4&gt;将3个运算符的顺序进行调整，调用加减乘除运算操作函数计算并输出 ●算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define N 10 //定义四个数的取值最大为10double operate(double a,double b,char ch) //加减乘除运算操作函数 &#123; if(ch==&apos;+&apos;) return a+b; else if(ch==&apos;-&apos;) return a-b; else if(ch==&apos;/&apos;) return a/b; else if(ch==&apos;*&apos;) return a*b; else return 0; &#125; int precede(char a,char b) //判断优先级函数 &#123; if(a==&apos;+&apos;||a==&apos;-&apos;) &#123; if(b==&apos;*&apos;||b==&apos;/&apos;) return 1; if(b==&apos;+&apos;||b==&apos;-&apos;) return 0; &#125; if(a==&apos;*&apos;||a==&apos;/&apos;) return 0; return 0; &#125; int check(double A,double B,double C,double D) &#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; //数组储存运算符 double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) //循环调用使A,B进行运算操作,d[]为运算符,运算结果存到a[]中 a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); //A,B运算的结果和C运算，结果存到b[][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //循环防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); //A,B,C运算的结果和D运算，结果存到c[][][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 return 1; &#125; return 0; &#125; void SHOW(double A,double B,double C,double D) //输出函数，运算过程与check()函数相同&#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 &#123; if(precede(d[i],d[j])) //调用判断优先级函数，判断第一、第二个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f)%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); //(AB)CD printf(&quot;\n&quot;); &#125; else if(precede(d[j],d[k])) //调用判断优先级函数，判断第二、第三个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f%c%.0f)%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; else //调用判断优先级函数，判断第一、第三个运算符可能出现的情况 &#123; printf(&quot;%.0f%c%.0f%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; &#125; &#125; &#125; void game_24() &#123; double A=0,B=0,C=0,D=0; char j; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; srand((unsigned)time(NULL)); while(1) &#123; while((A==0||B==0)||(C==0||D==0)) //当A,B,C,D不为0时，4个随机数赋值给A,B,C,D &#123; A=rand()%10*1.0; B=rand()%10*1.0; C=rand()%10*1.0; D=rand()%10*1.0; &#125; if((check(A,B,C,D)||check(B,C,A,D))||(check(C,B,D,A)||check(D,A,B,C))) break; else &#123; A=0; B=0; C=0; D=0; &#125; &#125; printf(&quot;随机生成四个数为：&quot;); printf(&quot;%.0f %.0f %.0f %.0f\n&quot;,A,B,C,D); printf(&quot;是否要看答案(y/n):&quot;); while(1) &#123; scanf(&quot;%s&quot;,&amp;j); if(j==&apos;y&apos;||j==&apos;Y&apos;) &#123; SHOW(A,B,C,D); //将24种可能列举，并调用函数计算并输出结果 SHOW(A,B,D,C); SHOW(A,D,B,C); SHOW(A,D,C,B); SHOW(A,C,B,D); SHOW(A,C,D,B); SHOW(B,A,C,D); SHOW(B,A,D,C); SHOW(B,C,A,D); SHOW(B,C,D,A); SHOW(B,D,A,C); SHOW(B,D,C,A); SHOW(C,A,B,D); SHOW(C,A,D,B); SHOW(C,B,A,D); SHOW(C,B,D,A); SHOW(C,D,A,B); SHOW(C,D,B,A); SHOW(D,A,B,C); SHOW(D,A,C,B); SHOW(D,B,A,C); SHOW(D,B,C,A); SHOW(D,C,A,B); SHOW(D,C,B,A); break; &#125; else printf(&quot;是否要看答案(y/n):&quot;); &#125; &#125; void menu() &#123; int i; while(1) &#123; system(&quot;cls&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 智力游戏24点 *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 1.开始游戏. *\n&quot;); printf(&quot;* 2.退出游戏. *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;你准备好了吗？\n&quot;); printf(&quot;输入你的选择:&quot;); scanf(&quot;%d&quot;,&amp;i); if(i==3) break; switch(i) &#123; case 1: game_24(); //开始游戏 system(&quot;PAUSE&quot;); break; default: printf(&quot;error input!\n&quot;); system(&quot;PAUSE&quot;); &#125; &#125; &#125; void main() &#123; menu(); &#125; ●经验归纳 ●●遇到的问题 &lt;1&gt;在防止重复问题上有点迷茫，已解决 &lt;2&gt;对数据结构栈不够清楚，未写提高要求 ●●心得体会 感觉自己对数据结构栈的知识点很薄弱，需要加强。而且在解决基本要求时考虑的不够全面，刚开始没有考虑到防止重复的问题，还有出现过进入无限循环的问题，好在均已解决，但是随机函数生成4个数字的时候，4个数字可能会出现重复的情况，我在网上找了一下，有不重复的随机函数代码，在这里不赘述了。 个人认为这个代码还可以优化~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于文件的C语言学生信息管理系统]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[●题目名称 C语言学生信息管理系统 ●题目分析 将文件引入学生信息管理系统，完善学生信息数据的处理，包括信息的读取、保存、刷新。编写与文件有关的程序，需要考虑将对文件以什么方式操作，文件能否被打开，文件在什么位置。为了程序的可读性，一般将文件的读取、存盘、操作自定义为函数。 ●算法构造 ●●刷新学生信息update()函数 &lt;1&gt;以只读方式打开指定文件，判断文件是否为空，若为空，则提示：文件为空！ &lt;2&gt;循环读入学生信息，并累加当前记录的学生人数n &lt;3&gt;输出提示：刷新成功！ &lt;4&gt;关闭文件 ●●查询学生信息seek()函数 &lt;1&gt;用户输入要进行的操作:1.按学号查询；2.按姓名查询；3.退出本菜单 &lt;2&gt;选择1：输入要查询的学生的学号；判断输入的学号和存好的学号一致；一致则输出学生的信息，不一致则输出：该学号不存在！ &lt;3&gt;选择2：输入要查询的学生的姓名；判断输入的姓名和存好的姓名一致；一致则输出学生的信息，不一致则输出：该姓名不存在！ ●●修改学生信息modify()函数 &lt;1&gt;输入要修改的学生的学号 &lt;2&gt;比较输入的学号和文件存好的学号是否一致，选择要进行的操作编号：1.修改姓名；2.修改年龄；3.修改性别；4.修改C语言成绩；5.修改高等数学成绩；6.修改大学英语成绩；7.退出本菜单 &lt;3&gt;选择1：输入新的姓名s2；新的姓名s2替换原来的姓名；保存新的姓名 &lt;4&gt;选择2：输入新的年龄age；新的姓名age替换原来的年龄；保存新的年龄 &lt;5&gt;选择3：输入新的性别sex1；新的性别sex1替换原来的性别；保存新的性别 &lt;6&gt;选择4：输入新的C语言成绩score1；新的C语言成绩score1替换原来的C语言成绩；保存新的C语言成绩 &lt;7&gt;选择5：输入新的高等数学成绩score1；新的高等数学成绩score1替换原来的高等数学成绩；保存新的高等数学成绩 &lt;8&gt;选择6：输入新的大学英语成绩score1；新的大学英语成绩score1替换原来的姓名；保存新的大学英语成绩 &lt;9&gt;选择7：返回主菜单 ●●插入学生信息函数insert()函数 &lt;1&gt;输入待增加的学生数n &lt;2&gt;循环依次输入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;将这些信息依次写入文件 &lt;4&gt;提示：添加成功！ &lt;5&gt;调用按学号排序函数，将信息排序好 &lt;5&gt;关闭文件 ●●按学号删除信息del()函数 &lt;1&gt;输入要删除学生的学号s1 &lt;2&gt;初始化flag=0，进入循环，比较输入的学号和文件记录的学号是否一致，若一致则令flag=1，循环将后面的学生记录向前移动 &lt;3&gt;判断flag=0，提示：该学号不存在！ &lt;4&gt;判断flag=1，学生人数-1并保存，提示：删除成功！ &lt;5&gt;关闭文件 ●●显示当前信息display()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次输出每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●●保存当前学生信息fileWrite()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次写入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432#include&lt;stdio.h&gt; /*I/O函数*/#include&lt;stdlib.h&gt; /*其它说明*/#include&lt;string.h&gt; /*字符串函数*/#define max 100#define LEN 15 /* 学号和姓名最大字符数,实际请更改*/#define N 100 /* 最大学生人数,实际请更改*/int k=1,n=0, m=0;/* n代表当前记录的学生人数*///学生信息结构体struct student &#123; char no[LEN];//学号 char name[LEN];//姓名 char sex[LEN];//性别 int age;//年龄 float C;//c语言成绩 float M;//数学成绩 float E;//英语成绩&#125;stu[N];void fileWrite();//系统帮助及说明void help() &#123; printf("\n0.欢迎使用系统帮助！\n"); printf("\n1.初次进入系统后,请先选择增加学生信息;\n"); printf("\n2.按照菜单提示键入数字代号;\n"); printf("\n3.增加学生信息后,切记保存;\n"); printf("\n4.谢谢您的使用！\n");&#125;//刷新学生信息void update()&#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s,%s,%s,%d,%f,%f,%f\n",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) //从文件中读取信息 &#123; j++; &#125; n=j; printf("\n 提示：刷新成功!!! \n"); fclose(fp);&#125;//查询学生信息void seek() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i=0,item,flag; char s1[LEN+1]; /* 以姓名和学号最长长度+1为准*/ printf("----------------------\n"); printf("-----1.按学号查询-----\n"); printf("-----2.按姓名查询-----\n"); printf("-----3.退出本菜单-----\n"); printf("----------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); //用户输入要进行的操作 flag=0; switch(item) &#123; case 1: printf("请输入要查询的学生的学号:\n"); scanf("%s",&amp;s1); for(i=0; i&lt;n; i++) //n代表当前记录的学生人数 if(strcmp(s1,stu[i].no)==0) //strcmp()是字符串比较函数，判断输入的学号和存好的学号一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的学号和存好的学号不一致 printf("该学号不存在！\n"); break; case 2: printf("请输入要查询的学生的姓名:\n"); scanf("%s",&amp;s1); //输入学生姓名 for(i=0; i&lt;n; i++) if(strcmp(stu[i].name,s1)==0) //输入的姓名和存好的姓名一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的姓名和存好的姓名不一致 printf("该姓名不存在！\n"); break; case 3: return; default: printf("请在1-3之间选择\n"); &#125; &#125;&#125;//修改学生信息void modify() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) &#123; printf("\n 警告：打开文件错误，请退出重新打开！\n"); system("pause"); exit(0); &#125; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,item=0,num; int age; char sex1[4],s1[LEN+1],s2[LEN+1]; /* 以姓名和学号最长长度+1为准*/ float score1; printf("请输入要修改的学生的学号:"); scanf("%s",s1); for(i=0;i&lt;n;i++) &#123; if(strcmp(stu[i].no,s1)==0) /*比较字符串是否相等*/ &#123; num=i; //给num赋i值 printf("------------------\n"); printf("1.修改姓名\n"); printf("2.修改年龄\n"); printf("3.修改性别\n"); printf("4.修改C语言成绩\n"); printf("5.修改高等数学成绩\n"); printf("6.修改大学英语成绩\n"); printf("7.退出本菜单\n"); printf("------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); switch(item) &#123; case 1: printf("请输入新的姓名:"); scanf("%s",s2); strcpy(stu[num].name,s2); //strcpy()是字符串复制函数，将新输入的值赋给原先的值 fileWrite(); break; case 2: printf("请输入新的年龄:"); scanf("%d",&amp;age); stu[num].age=age; fileWrite(); break; case 3: printf("请输入新的性别:"); scanf("%s",&amp;sex1); strcpy(stu[num].sex,sex1); fileWrite(); break; case 4: printf("请输入新的C语言成绩:"); scanf("%d",&amp;score1); stu[num].C=score1; fileWrite(); break; case 5: printf("请输入新的高等数学成绩:"); scanf("%d",&amp;score1); stu[num].M=score1; fileWrite(); break; case 6: printf("请输入新的大学英语成绩:"); scanf("%d",&amp;score1); stu[num].E=score1; fileWrite(); break; case 7: return; default: printf("请在1-7之间选择\n"); &#125; &#125; &#125; else &#123; printf("没有该学生学号!!!"); &#125; &#125;&#125;//按学号排序函数void sort()&#123; int i,j,*p,*q,s; char temp[LEN+1],ctemp[LEN]; float *x,*y,z; float *a,*b,c; float *k,*l,h; for(i=0;i&lt;n-1;i++) &#123; for(j=n-1;j&gt;i;j--) if(strcmp(stu[j-1].no,stu[j].no)&gt;0) &#123; strcpy(temp,stu[j-1].no); strcpy(stu[j-1].no,stu[j].no); strcpy(stu[j].no,temp); strcpy(temp,stu[j-1].name); strcpy(stu[j-1].name,stu[j].name); strcpy(stu[j].name,temp); p=&amp;stu[j-1].age; q=&amp;stu[j].age; s=*q; *q=*p; *p=s; strcpy(ctemp,stu[j-1].sex); strcpy(stu[j-1].sex,stu[j].sex); strcpy(stu[j].sex,ctemp); x=&amp;stu[j-1].C; y=&amp;stu[j].C; z=*x; *x=*y; *y=z; a=&amp;stu[j-1].M; b=&amp;stu[j].M; c=*a; *a=*b; *b=c; k=&amp;stu[j-1].E; l=&amp;stu[j].E; h=*k; *k=*l; *l=h; &#125; &#125;&#125;//插入学生信息函数void insert() &#123; int i; printf("请输入待增加的学生数:"); scanf("%d",&amp;n); FILE * fp; if((fp=fopen("student.txt","at"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; printf("\n请输入第%d个学生的学号：",i+1); scanf("\n%s",&amp;stu[i].no); printf("\n请输入第%d个学生的姓名：",i+1); scanf("%s",&amp;stu[i].name); printf("\n请输入第%d 个学生的性别：",i+1); scanf("%s",&amp;stu[i].sex); printf("\n请输入第%d 个学生的年龄:",i+1); scanf("%d",&amp;stu[i].age); printf("\n请输入第%d 个学生的C语言成绩:",i+1); scanf("%d",&amp;stu[i].C); printf("\n请输入第%d 个学生的高等数学成绩:",i+1); scanf("%d",&amp;stu[i].M); printf("\n请输入第%d 个学生的大学英语成绩:",i+1); scanf("%d",&amp;stu[i].E); sort(); //调用按学号排序函数 //写入文件 fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; printf("\n添加成功!!!\n"); fclose(fp);&#125;//按学号删除信息void del() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f ",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,flag=0; char s1[LEN+1]; printf("请输入要删除学生的学号:\n"); scanf("%s",s1); for(i=0; i&lt;n; i++) &#123; if(strcmp(stu[i].no,s1)==0) //比较输入的学号和记录的学号一致 &#123; flag=1; for(j=i; j&lt;n-1; j++) &#123; stu[j]=stu[j+1]; //后面的学生记录向前移动 &#125; &#125; &#125; if(flag==0) //比较输入的学号和记录的学号不一致 printf("该学号不存在！\n"); if(flag==1) //判断flag的值为1，则成功删除 &#123; n--; //删除成功后，学生人数-1 fileWrite(); fclose(fp); printf("删除成功,显示结果请选择菜单\n"); &#125;&#125;//显示当前信息void display() &#123; int i=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s %s %s %d %f %f %f",stu[i].no,stu[i].name,stu[i].sex,&amp;stu[i].age,&amp;stu[i].C,&amp;stu[i].M,&amp;stu[i].E)==7) &#123; i++; &#125; n=i; //记录文件中数据的行数 printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); for(i=0;i&lt;n;i++) //依次输出学生信息 &#123; printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp);&#125;//保存当前学生信息void fileWrite()&#123; FILE *fp; int i; if((fp=fopen("student.txt","w"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp); printf("保存成功!!!");&#125; //界面void menu() &#123; int num; printf(" \n\n \n\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf(" * 学生信息管理系统 *\n"); printf(" * *\n"); printf(" * * * * * * * *系统功能菜单* * * * * * * *\n"); printf(" * -------------------------------------------- *\n"); printf(" * *\n"); printf(" * 0.系统帮助及说明 | 1.刷新学生信息 *\n"); printf(" * *\n"); printf(" * 2.查询学生信息 | 3.修改学生信息 *\n"); printf(" * *\n"); printf(" * 4.增加学生信息 | 5.按学号删除信息 *\n"); printf(" * *\n"); printf(" * 6.显示当前信息 | 7.保存当前学生信息 *\n"); printf(" * *\n"); printf(" * 8.退出系统 *\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n"); printf("请选择菜单编号:"); scanf("%d",&amp;num); switch(num) &#123; case 0: help(); break; case 1: update(); break; case 2: seek(); break; case 3: modify(); break; case 4: insert(); break; case 5: del(); break; case 6: display(); break; case 7: fileWrite(); break; case 8: k=0; break; default: printf("请在0-8之间选择\n"); &#125;&#125;//主函数 int main() &#123; while(k) &#123; menu(); &#125; system("pause"); return 0;&#125; ●经验归纳 ●●遇到的问题 程序无法读取文件信息：对文件的概念不清楚，文件的读取中各个数据之间不能用逗号隔开 ●●算法优化 &lt;1&gt;将主函数写到子函数后面，删去函数声明 &lt;2&gt;利用结构体，使学生信息更加结构化 &lt;3&gt;新增按学号排序函数，用户在增加了学生信息后，调用该函数，将文件中学生信息按学号排序好 &lt;4&gt;优化删除学生信息函数，直接将后面的学生记录向前移动 &lt;5&gt;将每个涉及文件的子函数都加入了文件读取功能，目的是进行相应操作时不必每次都要先执行刷新函数 &lt;6&gt;优化修改学生信息函数，每次修改完都调用保存函数，实现自动保存 ●●心得体会 学生信息管理系统是我们在学习C语言时的典例，但是我感觉在文件读取方面基础还是比较薄弱，一些基础性的知识点还是不能记住，所以以后要多多练习与读取文件有关的习题。]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求N个数的最大公约数和最小公倍数&&Hankson问题]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%B1%82N%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%26%26Hankson%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[● 题目名称 &lt;1&gt;求N个数的最大公约数和最小公倍数 &lt;2&gt;计算出Hankson的“逆问题”的答案 ● 题目分析 &lt;1&gt;求N个数的最大公约数和最小公倍数：可以先求出第一个数和第二个数的最大公约数和最小公倍数，再将这个最大公约数和最小公倍数与下一个数计算出新的最大公约数和最小公倍数，以此类推 &lt;2&gt;计算出Hankson的“逆问题”的答案：先输入组数，再根据组数以每组4个数循环输入，然后判断输入的四个数是否满足条件，接着再调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件，若满足，则累加，最后输出累加的结果 ● 算法构造 ● ● 求N个数的最大公约数和最小公倍数 &lt;1&gt;输入要计算最大公约数和最小公倍数的整数个数 &lt;2&gt;循环输入整数 &lt;3&gt;调用函数，求出这些整数的最大公约数和最小公倍数 &lt;4&gt;先计算出两个数的最大公约数（最小公倍数），再用该最大公约数（最小公倍数）和下一个数求最大公约数（最小公倍数），以此类推 &lt;5&gt;输出这些整数的最大公约数和最小公倍数 ● ● 计算出Hankson的“逆问题”的答案 &lt;1&gt;输入组数 &lt;2&gt;每组输入四个数，判断是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;3&gt;循环依次输入各组，每组4个数 &lt;4&gt;判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;5&gt;循环计算有多少个满足条件的数，调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件 &lt;6&gt;输出累加的数 ● 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;//辗转相除法求两个数的最大公约数int max1(int a,int b) &#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;//求n个数的最大公约数int max2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; z=max1(x,y); //先计算出两个数的最大公约数，再用该最大公约数和下一个数求最大公约数，以此类推 for(int i=2;i&lt;n;i++) z=max1(z,a[i]); return z;&#125; //求两个数的最小公倍数int min1(int a,int b) &#123; int max1(int a,int b); //自定义函数返回值类型 int temp; temp=max1(a,b); //再次调用自定义函数，求出最大公约数 return (a*b/temp); //返回最小公倍数到主调函数处进行输出&#125;//求n个数的最小公倍数int min2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; //与n个数的最大公约数同理 z=min1(x,y); for(int i=2;i&lt;n;i++) z=min1(z,a[i]); return z;&#125;void main()&#123; int n=0,x=0,max=0,min=0,b,sum=0,i=0; int c[4]; int a[]=&#123;0&#125;; printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* 1.输入n个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.计算出Hankson的“逆问题”的答案. *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x&lt;1||x&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;x); &#125; switch(x) &#123; case 1: printf(&quot;请输入你想要计算的整数个数（大于1）：&quot;); scanf(&quot;%d&quot;,&amp;n); //输入要计算最大公约数和最小公倍数的整数个数 printf(&quot;请依次输入整数：\n&quot;); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //循环输入整数 max=max2(a,n); //调用函数，求出这些整数的最大公约数 min=min2(a,n); //调用函数，求出这些整数的最小公倍数 printf(&quot;这些数的最大公约数为：%d\n&quot;,max); printf(&quot;这些数的最小公倍数为：%d\n&quot;,min); break; case 2: printf(&quot;请输入数据的组数：&quot;); scanf(&quot;%d&quot;,&amp;b); //输入组数 printf(&quot;每组输入四个数，要求：保证第一个数能被第二个数整除，第三个数能被第四个数整除：\n&quot;); for(;b&gt;0;b--) //循环依次输入b个组 &#123; for(i=0;i&lt;4;i++) //每组4个数 &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; if(c[0]%c[1]!=0||c[3]%c[2]!=0) //判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &#123; printf(&quot;输入不符合条件，请重新输入：\n&quot;); for(i=0;i&lt;4;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; &#125; for(int y=0;y&lt;=c[3];y++) //循环计算有多少个满足条件的数 &#123; if(max1(y,c[0])==c[1]&amp;&amp;min1(y,c[2])==c[3]) //调用计算两个数的最大公约数和最小公倍数的函数，判断y是否满足条件 sum++; &#125; printf(&quot;一共有%d个数满足条件\n&quot;,sum); sum=0; //累加sum初始化 &#125; &#125;&#125; ● 经验归纳 ● ● 遇到的问题 &lt;1&gt;习惯了计算两个数的最大公约数和最小公倍数，对N个数迷茫了… &lt;2&gt;最大公约数和最小公倍数计算有误 &lt;3&gt;提高要求要输入的那四个数的限制条件运用不当，审题不清，导致频繁出错 &lt;4&gt;在一次循环之后未将累加的值初始化，导致下一次循环完毕后的结果有误 ● ● 心得体会 以前都是计算两个数的最大公约数和最小公倍数，这次要计算n个数的最大公约数和最小公倍数，我其实运用的还是计算两个数的那个思想，就是加入了函数调用。 感觉自己有时候还挺粗心的（也可能是代码敲久了有点晕hhh），还有就是提高要求把我卡住了。。完全不知道逆着怎么求…查了一些资料，然后和一起去图书馆敲代码的同学讨论了一下，大体有思路了，但只要写程序就有错误。。。。 失误挺多的，希望自己能在以后的程序生涯里越来越棒，小细节都可以注意到~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JAVA编写奇数累加和猜数字小游戏代码（包含JAVA产生随机数）]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8JAVA%E7%BC%96%E5%86%99%E5%A5%87%E6%95%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%8C%9C%E6%95%B0%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8C%85%E5%90%ABJAVA%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.题目名称： 奇数累加、猜数字小游戏 2.题目要求： 求自然数1-99的所有奇数累加的和； 计算机自动生成答案，玩家手动输入其猜想的数字，判断玩家是否猜对。 3.算法分析： 3.1奇数累加 （1）利用for循环，遍历自然数并限制累加范围在1-99之内 （2）遍历过程中，判断正在遍历的自然数是否奇数 （3）如果是奇数，则进行累加 3.2猜数字小游戏 （1）利用随机数产生一个1-100的整数，即为正确答案 （2）玩家输入一个整数 （3）如果玩家输入的数为0，则退出游戏；如果玩家输入的数小于0或大于100，则重新输入 （4）利用循环判断计算机生成的数和玩家输入的数是否一致 （5）如果不一致：玩家输入的过大，则提示“太大了”；玩家输入的过小，则提示“太小了” （6）如果玩家输入的数与计算机产生的数一致，则提示“恭喜你，答对啦！” 4.源代码： 4.1奇数累加 12345678910111213package com.itheima.first;public class Sum &#123; public static void main(String[] args)&#123; int i,sum=0; for(i=1;i&lt;100;i++) &#123; if(i%2!=0) sum+=i; &#125; System.out.println(&quot;在自然数1-99中奇数累加之和为：&quot;+sum); &#125;&#125; 4.2猜数字小游戏 12345678910111213141516171819202122232425262728293031323334package interesting;import java.util.Scanner;public class game &#123; public static void main(String[] args) &#123; int n=(int)(Math.random()*100)+1; //利用随机数生成一个正确答案 Scanner a=new Scanner(System.in); System.out.println(&quot;***********这是一个猜数字的游戏***********\n&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)，退出游戏请按0：&quot;); int b=a.nextInt(); while(b&lt;0||b&gt;100) &#123; System.out.println(&quot;输入错误~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; if(b==0) System.out.println(&quot;你已退出游戏~~~&quot;); else &#123; while(b!=n) //如果用户输入的数与正确答案不符 &#123; if(b&gt;n) System.out.println(&quot;太大了~&quot;); else if(b&lt;n) System.out.println(&quot;太小了~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; &#125; if(b==n) System.out.println(&quot;恭喜你，猜对啦!&quot;); &#125;&#125; 5.心得体会： 这些都是简单的程序，但是JAVA与C语言和C++的语法不一样，比如游戏里的产生随机数，我本来用的是C语言的随机数，但运行的时候发现了错误，于是我上网搜了一下，发现JAVA和C语言的随机数不一样；JAVA的输入代码，我在网上找了一下，接收字符和数字的输入代码是不一样的~ 还有程序最后保存是以文件夹的形式，我不知道最好是删除某个文件还是保留整个文件夹…于是我又做了新的尝试，我只留了src那个文件夹，然后…代码运行不了…我只好重新建了个项目，这次不敢删了… 不过这是我第一次用JAVA写代码呢感觉自己学到了很多*****]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方法计算两个数的最大公约数]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0~~~%2F</url>
    <content type="text"><![CDATA[1.题目名称 计算两个数的最大公约数 2.题目分析 计算两个数的最大公约数，可以采用最大公约数的四种常用算法，分别是辗转相除法、穷举法、更相减损法、Stein算法。每种方法写一个函数，分别计算出最大公约数，主函数的菜单里有选择功能，用户可以选择自行输入两个数，然后调用这四种方法的任一种；也可以选择程序的测试功能，通过自己选择的组数，计算机自动产生随机函数，然后调用四种方法的任一种，并计算出程序运行的时间。 3.算法构造 3.1辗转相除法 设两数为a,b设其中a 做被除数,b做除数，temp为余数 1、大数放a中、小数放b中； 2、求a/b的余数； 3、若temp=0则b为最大公约数； 4、如果temp!=0则把b的值给a、temp的值给a； 5、返回第二步； 3.2穷举法（利用数学定义） 穷举法（也叫枚举法）穷举法求两个正整数的最大公约数的解题步骤： 从两个数中较小数开始由大到小列举，直到找到公约数立即中断列举，得到的公约数便是最大公约数 。 对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp能同时被a和b所整除，则temp即为最大公约数。 3.3更相减损法 更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。《九章算术》是中国古代的数学专著，其中的“更相减损术”可以用来求两个数的最大公约数，即“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 翻译成现代语言如下： 第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。 3.4 Stein算法 Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。来研究一下最大公约数的性质，发现有 gcd( k_x,k_y ) = k_gcd( x,y ) 这么一个非常好的性质。试取 k=2，则有 gcd( 2x,2y ) = 2 * gcd( x,y )。很快联想到将两个偶数化小的方法。那么一奇一个偶以及两个奇数的情况如何化小呢？ 先来看看一奇一偶的情况： 设有2x和y两个数，其中y为奇数。因为y的所有约数都是奇数，所以 a = gcd( 2x,y ) 是奇数。根据2x是个偶数不难联想到，a应该是x的约数。我们来证明一下：(2x)%a=0，设2x=n_a，因为a是奇数，2x是偶数，则必有n是偶数。又因为 x=(n/2)*a，所以 x%a=0，即a是x的约数。因为a也是y的约数，所以a是x和y的公约数，有 gcd( 2x,y ) &lt;= gcd( x,y )。因为gcd( x,y )明显是2x和y的公约数，又有gcd( x,y ) &lt;= gcd( 2x,y )，所以 gcd( 2x,y ) = gcd( x,y )。至此，我们得出了一奇一偶时化小的方法。 再来看看两个奇数的情况：设有两个奇数x和y，不妨设x&gt;y，注意到x+y和x-y是两个偶数，则有 gcd( x+y,x-y ) = 2 * gcd( (x+y)/2,(x-y)/2 )，那么 gcd( x,y ) 与 gcd( x+y,x-y ) 以及 gcd( (x+y)/2,(x-y)/2 ) 之间是不是有某种联系呢？为了方便设 m=(x+y)/2 ，n=(x-y)/2 ，容易发现 m+n=x ，m-n=y 。设 a = gcd( m,n )，则 m%a=0,n%a=0 ，所以 (m+n)%a=0，(m-n)%a=0 ，即 x%a=0 ，y%a=0 ，所以a是x和y的公约数，有 gcd( m,n )&lt;= gcd(x,y)。再设 b = gcd( x,y )肯定为奇数，则 x%b=0,y%b=0 ，所以 (x+y)%b=0 ，(x-y)%b=0 ，又因为x+y和x-y都是偶数，跟前面一奇一偶时证明a是x的约数的方法相同，有 ((x+y)/2)%b=0,((x-y)/2)%b=0 ，即 m%b=0 ，n%b=0 ，所以b是m和n的公约数，有 gcd( x,y ) &lt;= gcd( m,n )。所以 gcd( x,y ) = gcd( m,n ) = gcd( (x+y)/2,(x-y)/2 )。 整理一下，对两个正整数 x&gt;y ： 1.均为偶数 gcd( x,y ) =2gcd( x/2,y/2 )； 2.均为奇数 gcd( x,y ) = gcd( (x+y)/2,(x-y)/2 )； 2.x奇y偶 gcd( x,y ) = gcd( x,y/2 )； 3.x偶y奇 gcd( x,y ) = gcd( x/2,y ) 或 gcd( x,y )=gcd( y,x/2 )； 现在已经有了递归式，还需要再找出一个退化情况。注意到 gcd( x,x ) = x ，就用这个。 4.算法实现 4.1辗转相除法 123456789101112131415161718192021222324int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125; 4.2穷举法（利用数学定义） 12345678910111213141516int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125; 4.3更相减损法 123456789101112131415161718192021222324252627int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125; 4.4 Stein算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;****4.5完整代码**** 在这里插入代码片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include&lt;stdio.h&gt;#include&lt;math.h&gt; //计算2的i次方的函数pow(2,i)的头文件#include&lt;time.h&gt; //计算程序运行时间和随机产生数的头文件#include&lt;stdlib.h&gt;int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125;int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125;int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125;int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;void main()&#123; int x,y,p,i,n,N,m[1000]; int a,b,c,d,e; printf(&quot;*********************你有两种选择********************\n&quot;); printf(&quot;* 1.输入两个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.利用随机数测试最大公约数并计算程序运行时间. *\n&quot;); printf(&quot;*****************************************************\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n&lt;1||n&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;n); &#125; if(n==1) &#123; printf(&quot;请输入两个正整数:\n&quot;); //用户自行输入两个数 scanf(&quot;%d%d&quot;,&amp;x,&amp;y); while(x&lt;0||y&lt;0||x==0||y==0) &#123; printf(&quot;请按要求输入正整数:\n&quot;); scanf(&quot;%d%d&quot;,&amp;x,&amp;y); &#125; printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); break; case 2: a=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); break; case 3: a=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); break; case 4: a=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); break; case 5: a=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); break; &#125; printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125;&#125;else if(n==2)&#123; clock_t start,finish; //计算随机函数 double duration; srand((unsigned)time(NULL)); printf(&quot;你想测试多少组数据？\n&quot;); scanf(&quot;%d&quot;,&amp;N); for(i=0;i&lt;N;i++) //随机取20个数（1-100） &#123; m[i]=rand()%100+1; printf(&quot;%d\t&quot;,m[i]); &#125; printf(&quot;\n&quot;); printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: start=clock(); //程序运行，开始计时 while(j&lt;20) &#123; x=m[j++]; y=m[j++]; a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125; finish=clock(); //程序运行结束，结束计时 break; case 2: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; b=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,b); &#125; finish=clock(); break; case 3: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; c=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,c); &#125; finish=clock(); break; case 4: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; d=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,d); &#125; finish=clock(); break; case 5: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; e=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,e); &#125; finish=clock(); break; &#125; duration=(double)(finish-start)/1000; ////计算时间差，由于计算机计算的是毫秒，转换成秒要除以1000 printf(&quot;这个方法的运行时间是%f秒\n&quot;,duration); &#125; &#125; &#125; 5.经验归纳 5.1遇到的问题 1.对随机函数不熟悉； 2.测试环节，对计算程序运行时间不熟悉； 3.在更相减损法的最后，用到了pow()函数，因没加头文件#include&lt;math.h&gt;而出错； 4.因知识储备不足，对最后一种方法（Stein算法）不理解。 PS：以上问题均已解决。 5.2心得体会 我觉得这四种方法里Stein算法我有点看不懂（可能是因为有&gt;&gt;运算符），还有随机数的生成和计算程序运行时间的函数都只是有一些印象，并不熟悉。（但是我可以查资料和问同学啊hhh） 主函数我改了很多次，就是想让界面更加美化一些，改完就发现程序出错了…其实就是赋值这么一个小细节，但就是发现不了（Emmmm），感觉自己还需要学很多东西，动手能力也要加强 总之就是~add oil!!!]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三天打鱼两天晒网]]></title>
    <url>%2F2019%2F03%2F01%2F%E2%80%9C%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[♦ 题目： 三天打鱼两天晒网 ♦问题： 某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。 ♦ 要求： 基本要求：1.程序风格良好(使用自定义注释模板)，提供友好的输入输出。 提高要求：1.输入数据的正确性验证。 2.使用文件进行数据测试。如将日期 20100101 20111214 等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。 ♦程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void hanshu(int year,int month,int day)&#123; int sum=0; int a=0; int b=0; int c=0; int x[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; //平年各月份的天数 int y[12]=&#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; //闰年各月份的天数 for(int i=2010;i&lt;year;i++) //利用循环结构计算出在输入年份之前的那几年一共有几天 &#123; if((i%4==0&amp;&amp;i%100!=0)||i%400==0) //判断是否有闰年，有的话，一年为366天；否则一年为365天 a+=366; else a+=365; &#125; for(int j=0;j&lt;month-1;j++) //利用循环计算在输出月份之前的几个月一共有几天 &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) //判断该年是否为闰年，如果是，则用闰年数组；否则，用平年数组 b+=y[j]; else b+=x[j]; &#125; c=day; //用户输入的天数 sum=a+b+c; //将年，月，日所计算的天数相加，即为总天数 printf(&quot;距离2010年1月1日一共有%d天\n&quot;,sum); if(sum%5==1||sum%5==2||sum%5==3) //判断总天数取余后余数是否为1,2,3，如果是，输出“你在打鱼”；否则，输出“你在晒网” printf(&quot;你在打鱼~~~\n&quot;); else printf(&quot;你在晒网~~~\n&quot;);&#125;void main()&#123; int year,month,day,m,p,a,b,c; printf(&quot;***************计算你到底在打鱼还是晒网***************\n&quot;); printf(&quot;1.使用文件测试\n&quot;); printf(&quot;2.从键盘输入计算\n&quot;); printf(&quot;请输入你想选择的操作的序号：\n&quot;); scanf(&quot;%d&quot;,&amp;m); if(m==1) //选择1，进入文件测试环节 &#123; FILE *fp1; FILE *fp2; fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;); fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;); if(fp1==NULL) //判断文件in.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else if(fp2==NULL) //判断文件out.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else fscanf(fp1,&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); //文件不为空，则用格式化读写函数fscanf()和fprintf()来读取文档in.txt和out.txt中的信息 hanshu(a,b,c); fprintf(fp2,&quot;%1d&quot;,&amp;p); fclose(fp1); //关闭文件 fclose(fp2); &#125; else if(m==2) &#123; printf(&quot;请输入年，月，日：(在2010年1月1日之后)\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); while(year&lt;2010||month&gt;12||day&gt;31) //判断输入年份是否小于2010年，如果是，则重新输入 &#123; printf(&quot;输入错误！请重新输入！\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); &#125; hanshu(year,month,day); &#125; else &#123; printf(&quot;你的输入有误！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;m); &#125;&#125; ♦ 心得： 第一次接触文件测试这样的问题，我刚开始还真无从下手还好问了班里比较厉害的同学，然后自己复习了C语言课本上的文件那一章，感觉遇到的问题挺多的，但是还好在我的不懈努力（不断问别人）下，最终是把文件测试这关通过了！！！ 刚开始敲得那个代码只有一个主函数，后来检查了一下觉得太简单了，然后运用了子函数，感觉自己对C语言还掌握的不是很清楚，还需要多多动手敲代码啊！！！（希望老师能看到我这个代码小白的认真） 我觉得这次作业让我学到了好多东西，也了解到了大企业的程序设计风格，我可以从现在开始学习他们的风格。 个人感觉还是对C语言感情更深一些，毕竟是接触计算机学到的第一门语言hhhh希望我能够在史晓楠老师（超级厉害）的教导下学到更多以前没接触过的东西！！！ 新的一年，新一学期，新的起点，FIGHTING]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
