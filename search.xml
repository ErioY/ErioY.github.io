<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js流程控制、JSON和this]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%81JSON%E5%92%8Cthis%2F</url>
    <content type="text"><![CDATA[1copyright: true]]></content>
  </entry>
  <entry>
    <title><![CDATA[js数组和循环]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%95%B0%E7%BB%84%E5%92%8C%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[数组(Array) 声明一个数组的变量： 12var arr1 = []; //字面量写法ar arr2 = new Array(); //构造函数实例化写法 注意：第一种写法等号右边就可以认为是字面量，字面量就是可以通过该值来判断它的类型；构造函数会在后面详细说明 数组是数据仓库，可以放任意多个任意数据类型的数据，甚至是其他数组；数据之间用”,”分隔；数组也是对象的一种，属性length为数组数据的数量，如： 1var arr = ["第一个数据","第二个数据","第三个数据"]; //可以通过arr[下标]来获取对应位置的数据 注意：js中(包括数组)，在计数的时候都是从0开始，所以arr[0]==&gt;”第一个数据” 数组的添加和修改方法： 12arr.push("第四个数据"); //从数组最后添加新数据("第四个数据")arr[0] = "第零个数据"; 类数组(伪数组) 用标签名来获取元素： 1document.getElementsByTagName(""); 注意：该方法获得的不是一个元素，因此不能直接拿来操作，可以用数组的[下标]来拿到你想操作的对象 例~ 获取p元素： 1var oP = document.getElementsByTagName("p")[0]; //获取p元素 它不是数组，却和数组很像，是类数组(也叫伪数组)的一种，伪数组可以被转化成数组，语法： 1Array.prototype.slice.call() //把类数组放在括号里并用变量接收数组结果 该方法(document.getElementByTagName)与document.getElementById的区别： document.getElementById： 前面必须是document； 获取的只有一个元素(id在同一个页面中也是唯一的)； 无法选中动态创建的元素(如通过innerHTML生成的标签) document.getElementsByTagName 前面可以是另一个元素； ByTagName获取的可能是多个(无论是一个和多个都会变成类数组)，需要加上[]和数字或者遍历(既循环)来控制； ByTagName可以选中动态创建的元素 另外特殊标签选取：在页面中唯一的标签如body、title：可以用document.body和document.title获取到该元素。注意：虽然html也是唯一标签，但是必须通过document.documentElement才能获取 循环 当我们需要重复执行某些代码或连续执行的代码有数字在变化时，就可以使用循环，语法： 1for(;;)&#123;反复执行的代码块......&#125; 注意：()里用两个;将其分成3个部分，第一个部分是初始变量，第二个为判断条件(为真就会继续循环)，第三个为变量的变化 循环经常被用做给数组或类数组遍历，如 1234var aDiv = document.getElementsByTagName("div");for(var i=0;i&lt;aDiv.length;i++)&#123; aDiv[i]...... //aDiv的每个数据执行某代码&#125; 注意：不要漏写[]，否则就变成让数组或类数组执行某代码了 例~我们先用for循环和body.innerHTML属性为body添加100个按钮，并一点一点增加数量，你会发现下面写法会使电脑速度越来越慢 1document.body.innerHTML += "&lt;input type='button' value='按钮'/&gt;"; 原因就是循环去修改DOM树的做法在数量过多时太耗性能，可以先循环将要添加的字符串预先连接后保存到str变量里，再一次修改DOM树就可以了 123var str = ""; //用字面量的写法创建一个空字符串str += "&lt;input type='button' value='按钮'/&gt;"; //在循环中反复拼接字符串document.body.innerHTML =str; //最后一次性将字符串添加到body里 JavaScript的for循环如果要遍历一个嵌套的数组，需要用两次for循环来遍历数据，执行第一个for时变量需小于arr.length，而执行第二个for时变量则需要小于arr[i].length，最后输出arr[i][j]： 123456var arr = [[1,2,3],[4,5,6],[7,8,9]];for(var i=0;i&lt;arr.length;i++)&#123; //第一次遍历出的arr[i]也都是数组，因此开启第二个循环 for(var j=0;j&lt;arr[i].length;j++)&#123; //遍历arr[i]，将其中的数据都遍历出来 arr[i][j]...... &#125;&#125; 注意：多个并列的for循环可以用相同的变量i，但是循环的嵌套就必须要换变量名了(如上面的j) 练习： ​ 1.]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型和判断]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[关键字、保留字和ECMAScript标准 class也是页面元素的属性之一，我们可以通过赋予元素不同的class来改变样式，但js元素的class属性写法却与其他的属性不同： 12元素.class //报错元素.className //正确写法 关键字：js里用到的语法单词(如：function var) 保留字：js里保留的单词(如：class ) 不要使用关键字和保留字来给变量命名，但是可以和其他单词组合使用，比如classOne className可以用来解决兼容问题，例如没有style.float的这种写法，style.styleFloat是ie写法；style.cssFloat是其他浏览器写法，那么我们设置元素的浮动时就可以用给元素添加class或移除class的方法来做 当你需要解决兼容问题时，要么知道做如何解决兼容问题(如封装带有兼容问题的代码)，要么会使用其他的解决方案(如用className绕过该问题)，有时我们要做一个兼容性很好的代码往往比代码本身要麻烦的多 js里的所有语言规范就是ECMAScript标准，例如function[]{}不能这么写，这是已经定义好的，必须遵守的 数据类型 js的数据类型，像HTML的标签就有各种类型：block、inline、inline-block，数据类型的目的是对他们能够做更准确的操作 JavaScript中有5种原始数据类型——Undefined(未定义)、Null(空对象)、Boolean(布尔值)、Number(数字)、String(字符串)和特殊一个引用型类型——Object(对象)： Undefined(未定义)表示一个变量不含值(一般非人为因素) Null(空对象)通过设置NULL来清空变量(人为设置) 注意：undefined实际上的从null派生来的，它们在定义上是相等的 1alert(null==undefined) //true 注意：==在js中用来判断值相等，如果两边数据类型不同会在判断大小时会发生数据类型转换，但是undefined和null不会发生转换，判断结果依然为true Boolean(布尔值)只有true(真)和false(假)两个值 Number(数字)不分整数和浮点 自增/自减： 123456num += x; //相当于num = num + x;num -= x; //相当于num = num - x;num++; //先赋值再自增1num--; //先赋值再自减1++num; //先自增1再赋值--num; //先自增1再赋值 String(字符串)用双引号或单引号括起来的部分，“+”可以用来做字符串的拼接 1alert("hello"+"world"); object(对象类型)指向性数据类型(包括Array、Function、Date、Json以及页面中所有元素等)会在后面详细说明 用typeof可以判断数据类型，对变量调用typeof将返回下列值之一：string,number,Boolean,object,function,undefined，这些结果都是字符类型的 12var i = 100;alert(typeof(i)); //"number" 注意：对null调用typeof会返回object,null被认为是对象的占位符；而对象中的函数会返回function，这两种是特殊情况。 if判断 判断的语法： 123456789if(条件)&#123;代码块&#125; //当条件为true时执行代码块if(条件)&#123;代码块1&#125;else&#123;代码块2&#125; //当条件为true时执行代码块1，否则执行代码块2 if(条件1)&#123;代码块1&#125;else if(条件2)&#123;代码块2&#125;......else&#123;代码块n&#125; //当条件1为true时执行代码块1，否则条件2为true时执行代码块2,......否则执行代码块n 判断的注意事项： js获取元素的href和src属性得到不是相对路径而是绝对路径，因此不能用来做判断 通常颜色值也不能用来做判断，因为有很多颜色值的输出方式，如英文单词、rgb和16进制数 元素的内容innerHTML也不能用来做判断(在低版本浏览器上会有兼容性的问题) 当需要判断上面这些值时可以使用布尔值开关的方式解决问题，既每次执行的时候将一个布尔值变量取反(取反的符号为!，作用是将真假转换)，每次判断根据新的布尔值结果执行相应代码 判断时若使用的条件需要运算，我们常用以下的运算符：”==”(数值相等)；”===”(绝对相等—类型数值都相等)；”&gt;”，”&lt;”，”&gt;=”，”&lt;=”(大于，小于，大于等于，小于等于)等 练习： ​ 1. （用户控制时间调用函数特效）做两个input输入框和一个input按钮，通过分别向两个输入框输入样式名和样式的值的方法来改变一个div的样式 ​ a. HTML部分： 1234567891011&lt;div class="wrap"&gt; &lt;p&gt;请为下面的div设置样式：&lt;button id="btn1"&gt;点击设置&lt;/button&gt;&lt;/p&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;div id="div2"&gt; &lt;div class="ctrl"&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式" id="te1"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式值" id="te2"&gt;&lt;/div&gt; &lt;div&gt;&lt;button id="btn2"&gt;变化&lt;/button&gt;&lt;button id="btn3"&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100.wrap&#123; width: 735px; height: 420px; background-color: #efefef; margin: 0 auto; padding: 25px; box-sizing: border-box; position: relative; &#125; p&#123; margin: 0; font-size: 24px; font-weight: bold; &#125; #btn1&#123; border: none; padding: 0; width: 100px; height: 40px; font-size: 14px; color: white; background-color: red; &#125; #div1&#123; width: 100px; height: 100px; border: #393129 4px solid; background-color: white; &#125; #div2&#123; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); position: absolute; left: 0; top: 0; display: none; &#125; .ctrl&#123; position: absolute; right: 25px; bottom: 30px; width: 340px; height: 240px; box-sizing: border-box; border: 20px #9c949c solid; background-color: white; padding-top:15px; padding-bottom: 20px; &#125; .ctrl div&#123; text-align: center; font-size: 16px; margin-bottom: 5px; &#125; .ctrl div:nth-last-child(1)&#123; margin-top: 21px; &#125; .ctrl div button&#123; width: 36px; height: 32px; box-sizing: border-box; &#125; #color1&#123; background-color: red; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color2&#123; background-color: yellow; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color3&#123; background-color: blue; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #width1,#width2,#width3,#height1,#height2,#height3&#123; background-color: #efefef; border: 1px #c0c0c0 solid; color: #808080; font-size: 12px; margin-left: 5px; &#125; #btn2,#btn3&#123; width: 60px; height: 30px; background-color: #002952; color: white; &#125; ​ c. JS部分： 123456789101112131415var oBtn1 = document.getElementById("btn1");var oDiv2 = document.getElementById("div2");var oDiv1 = document.getElementById("div1");var oBtn2 = document.getElementById("btn2");var oBtn3 = document.getElementById("btn3");var oTe1 = document.getElementById("te1");var oTe2 = document.getElementById("te2");oBtn1.onclick = function ()&#123; oDiv2.style.display = "block";&#125;oBtn2.onclick = function ()&#123; var style = oTe1.value; var val = oTe2.value; oDiv1.style[style] = val;&#125; ​ 2. 做一个用两个按钮(加大、缩小)点击改变字体大小的效果，字体变换范围在12px-28px区间 ​ a.HTML部分： 12&lt;button id="btn1"&gt;变小&lt;/button&gt;&lt;button id="btn2"&gt;变大&lt;/button&gt;&lt;p id="p1"&gt;电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅&lt;/p&gt; ​ b. CSS部分： 123p&#123; font-size: 20px;&#125; ​ c. JS部分： 1234567891011121314var iFont = 20;var oBtn1 = document.getElementById("btn1");var oBtn2 = document.getElementById("btn2");var oP = document.getElementById("p1");oBtn1.onclick = function ()&#123; if(iFont&gt;12)&#123; oP.style.fontSize = --iFont + "px"; &#125;&#125;oBtn2.onclick = function ()&#123; if(iFont&lt;28)&#123; oP.style.fontSize = ++iFont + "px"; &#125;&#125; ​ 3.（表单验证）输入框input的验证，为空时弹出”输入框内容不能为空” ​ a. HTML部分： 123&lt;input type="text" id="te1"/&gt;&lt;input type="text" id="te2"/&gt;&lt;button id="btn1"&gt;弹出&lt;/button&gt; ​ b. JS部分： 1234567891011121314// 弹出第一个输入框的值 + "在" + 第二个输入框的值 // 如果第一个输入框内为空，则弹出 "输入内容不能为空" var oTe1 = document.getElementById("te1"); var oTe2 = document.getElementById("te2"); var oBtn1 = document.getElementById("btn1"); oBtn1.onclick = function ()&#123; // if(oTe1.value == "")&#123; // alert("输入内容不能为空"); // &#125;else&#123; // alert(oTe1.value + "在" + oTe2.value); // &#125; // oTe1.value == "" ? alert("输入内容不能为空") : alert(oTe1.value + "在" + oTe2.value); alert(oTe1.value == "" ? "输入内容不能为空" : oTe1.value + "在" + oTe2.value); &#125; ​ 4. 布尔值开关（取反）实现下拉框 ​ a. HTML部分： 12&lt;button id="btn1"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 120px; height: 40px; &#125; div&#123; width: 120px; height: 350px; background-color: red; display: none; &#125; ​ c. JS部分： 123456789101112var oDiv = document.getElementById("div1");var oBtn = document.getElementById("btn1");var bOn = true;oBtn.onclick = function ()&#123; // if(bOn)&#123; // oDiv.style.display = "block"; // &#125;else&#123; // oDiv.style.display = "none"; // &#125; oDiv.style.display = bOn ? "block" : "none"; bOn = !bOn;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件函数和属性操作]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js选择器和事件函数 js的事件：鼠标事件、键盘事件、系统事件、表单事件、自定义事件等，如下常见的鼠标事件 鼠标左键点击：onclick 鼠标移入：onmouseover 鼠标移出：onmouseout 鼠标左键落下：onmousedown 鼠标左键抬起：onmouseup 鼠标移动：onmousemove 获取元素的方法：通过ID名称来获取元素，其中.代表”的”： 1document.getElementById('link'); –&gt;document get element by id ‘link’(既在文档上通过id的值来获取元素)，获取的元素可以配合事件：元素.onmouseover=元素在鼠标移入该元素时做什么，由于做的事情应该是该事件触发时执行，那么这些代码我们不能直接使用，而是放在函数内部 函数(function)：由事件去命令它做一些事(执行代码块)，它不会主动执行： 函数是执行某一任务的JavaScript 语句，可被其他部分调用。 下面是声明一个有名函数的方法： 123function functionName()&#123; //function==&gt;关键字；functionName==&gt;是给函数取的名字 代码块...... //代码块==&gt;是完成某一任务的代码 &#125;; 我们把完成特定功能的代码块放到一个函数里，再调用这个函数，就省重复输入大量代码的麻烦。 有名函数执行方法：例如函数名为abc的函数 12abc(); //直接调用执行，当逐行执行代码执行到这步时执行代码元素.事件 = abc; //当事件发生时执行该函数 注意：事件调用函数后面没有括号，使用括号会出错，原因会在后面说明 匿名函数：没有名字的函数，使用方法： 123元素.事件 = function ()&#123; 代码块......&#125; 注意：由于匿名函数没有函数名，因此不能直接调用，一般是用在事件调用及后面的传参、闭包等地方 当很多地方需要反复使用一段代码的时候，我们应该声明一个有名函数；若只在一个事件使用的函数则可以使用匿名函数 onload是加载事件，可用在一个图片或者body等对象加载上。我们在开头的地方说过JS的代码可以放在head或body里，但是我们刚才用来获取元素的方法如果放在head里，输出的元素却找不到了。原因就是html文件是同步代码(顺序执行)，当读取到获取元素时，实际HTML中的元素并不存在，解决方法：1、将放在head里的script中的代码包在一个函数内，在&lt;/body&gt;前script里调用(不推荐)；2、将放在head里的script中的代码放在window的onload的事件里执行(推荐)；3、把script标签放在&lt;/body&gt;前，这样还可以提高用户体验(推荐) 属性操作 其实我们获取的页面中的元素就是对象(对象：就是带有属性和方法的特殊数据类型)，而元素也就是标签本身就是有属性的如：&lt;input id=&quot;btn1&quot; type=&quot;button&quot;/&gt; 属性名(id和type)，属性值(btn1和button)； 12元素.属性; //读：获取某元素属性的值 元素.属性 = "新值"; //写：替换某元素属性的值 注意：“读”的值都是字符串类型；“写”是替换操作，不是添加，因此原值会消失 元素的内容，语法： 12元素.innerHTML;元素.innerHTML = "新内容" 注意：内容包括子元素，所以“写”的时候可以用来加入新元素 元素的值，语法： 12元素.value;元素.value = "新内容" 元素的样式，语法: 12元素.style.样式 = "新值";元素.style.cssText= 'width:200px'; //注意该写法里面的值和css的写法相同 注意：这两种方法都会把样式加在元素的行间样式中，而获取样式时，获取的也是行间样式，它不会去计算当前样式，因此一般只用来“写”不用来“读”；另外js里不能出现”-“，因此第一个方法中background-color需写成backgroundColor，第二个由于写法和css相同，因此不用修改 “[]”的一种用法类似”.”，由于”.”后面的值不能变(如.style.width的width不能用变量)，因此在需要我们用变量的时候会用到”[]”： 12元素.style.width; //用"."的写法元素.style["width"]; //用"[]"的写法，"[]"里可以是变量 注意：”[]”里如果是属性，必须加双引号；如果是变量，不可以加双引号 练习： ​ 1.做一个下拉框效果，鼠标点击按钮时，在该元素下显示一个下拉框区域 ​ a. HTML部分： 12&lt;button id="btn"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 150px; height: 60px;&#125;div&#123; width: 150px; height: 400px; background-color: red; display: none;&#125; ​ c. JS部分： 12345var oBtn = document.getElementById("btn");var oDiv = document.getElementById("div1");oBtn.onclick = function ()&#123; oDiv.style.display = "block";&#125; ​ 2. 设置css和选择器 1.box&#123;width:150px; height:150px; background-color: red; &#125; 页面中设置一个textarea、button和div，在点击button时，将带有class(box)的div元素在页面的div里创建出来，即点击按钮时，将文本域中的值在div1的内容中展示出来 ​ a. HTML部分： 12&lt;textarea name="" id="te" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;button id="btn"&gt;按钮&lt;/button&gt; ​ b. CSS部分： 1.box&#123;width:150px; height:150px; background-color: red; &#125; ​ c. JS部分： 123456var oDiv = document.getElementById("div1");var oText = document.getElementById("te");var oBtn = document.getElementById("btn");oBtn.onclick = function ()&#123; oDiv.innerHTML = oText.value;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习要求和基本语法]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B1%82%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js的组成 尽管ECMAscript是一个重要的标准,但它并不是JavaScript的唯一的部分，当然，也不是唯一被标准化的部分。 实际上，一个完整的JavaScript实现是由一下3个不同的部分组成的。 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) DOM和BOM就是前文说到的浏览器大战而产生的拥有大量不兼容的地方 js是什么 简单来说，JavaScript是一种可以用来给网页增加交互性的编程语言。也常被称为”脚本语言”。 学习它有很多用途和好处： 所有主流浏览器都支持JavaScript 基本所有的网页都会用到JavaScript 可以让网页呈现各种动态效果 不需要安装环境(浏览器都支持)，有文本编辑器就可以编写JavaScript代码 js的学习要求 非必要条件：数学功底，英文功底，其他程序语言的基础 必要条件：HTML+CSS2基础好，尤其CSS2的样式使用要求灵活 主观条件：多去网上看，多思考别人的方法，多练习实现效果。如何布局，如何设置脚本 例如让一个元素移出我们的视线的方法，而我们往往必须想到在当前条件下哪种是最优的选择： 设置透明度opacity为0 用visibility或display隐藏元素 用position和偏移值定位出可视区 width \ height设置为0，并溢出隐藏 js引入html和输出 html中的js代码必须放在script标签里面，script标签可以放在页面中head和body标签中。 一行结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束； “hello world!”是一串字符串，“//”是单行注释 &lt;/script&gt;这里结束JavaScript，并告诉浏览器后面的代码是html代码了： 123&lt;script&gt; document.write(&quot;hello world!&quot;); //获得文档窗口并在其中写入&quot;Hello, world!&quot;&lt;/script&gt; 注意：每行结尾的分号可有可无，好的代码编写习惯是加入分号，这会增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。 我们需要让多个html页面共享一个脚本时就把脚本保存到外部文件中。外部文件扩展名是.js。使用时在&lt;script&gt; 标签的src属性中设置该文件的路径。如： 1&lt;script src="myScript.js"&gt;&lt;/script&gt; 注意：外部JavaScript文件中不能出现&lt;script&gt;标签(标签都是html语言) 输出数据方式除了document.write外还有下面两个方法： 12alert("hello world"); //弹出一个确认框，里面显示"hello world"console.log("hello world"); //在控制台打印"hello world" 注意：控制台里输出的字符串和其他数据的颜色不同。 js语法特征 注释与Java，C相同，支持单行注释 //；与多行注释/…/ 变量是用于存储信息的容器，JavaScript区分大小写，a和A是两个不同的变量 js的变量是弱类型的，定义变量只用var运算符，可以将它初始化为任意值，也可以随时改变变量所存数据的类型，可以用“,”将多个变量定义在一个var中，如： 12345var color = "red"; //声明了一个字符串类型变量，但不需要声明其类型color = 16; //弱类型语言，在这里将color的值从字符串改成了数字var num = 25; //等号"="叫做赋值操作，意思是将等号右侧的值赋给左侧var visible = true;var a = "5", b = 5; //一个var声明了2个变量 注意：由于js引擎会在出错时自动停止，因此我们可以将上面alert输出方法逐行放置，如果alert未执行，说明上面的代码有错误。初学者应养成随时写随时测试的习惯，以防做完一堆代码都是不能用的。 js变量的命名规则 没人天天叫毕加索的全名，js里也可以用一个名字储存数据，将事件加在名字上可以大大减少代码量 变量的命名规则：变量必须以字母开头；虽然变量也能以$和_符号开头(不过不推荐这么做)；变量名称也对大小写敏感(a和A是不同的变量)。 变量使用var关键字声明：var 名字 = ，后面可以是数字，字符串或者一个对象等等 好的代码编写习惯是总是用var声明变量的，并且始终存放相同类型的值，常用的命名规则： Camel标记法：首字母是小写的，接下来的单词都以大写字母开头。 Pascal标记法：首字母是大写的，接下来的单词都以大写字母开头。 匈牙利标记法：在以Pascal标记法命名的变量前附加一个小写字母说明该变量的类型。如比较常用的:i表示整数；s表示字符串；b代表boolean值；o代表对象；a代表数组或集合]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的概述和历史]]></title>
    <url>%2F2019%2F07%2F19%2Fjavascript%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[JavaScript作为赋予网页活力与交互性的主要手段之一，已成为web设计师和开发人员的必备技能。但它诞生时其实是个屌丝，没有想到发展到如今的地位 JavaScript是被人误解和误用最多的主流编程语言，很多人将它看作Java等面向对象语言的功能不全的小兄弟。随着越来越多的程序员转向浏览器/服务器模式开发，加上WEB2.0和Ajax的兴起，人们开始认识到，JavaScript绝非一种容易学习和掌握的技术，它具有面向对象，过程和函数型语言三类语言的特性，灵活性与强大功能完美结合，迄今为止，它的潜力远远没有正真释放出来。 上古时代的浏览器Netscape中，主要是些丑陋的静态文本和简单的图片， 和现在的页面相比，差的实在太远了。 当互联网刚开始兴起时，用户的数据需要全部在服务器端处理，这在网速非常慢的当时使用户的上网体验非常痛苦。Brendan Eich( JavaScript的发明人)有一回注册用户，由于忘了填写性别，等待了38秒后服务器告诉了他。他很崩溃：”这么简单的问题浏览器不会告诉我，还得把数据提交到几千公里外的服务器在那里检查才能发现问题吗！”。于是他向老板反馈问题，老板说： “我也早有此意，你来设计一个类似java的脚本吧”，老板对java非常感兴趣。Brendan Eich对java 毫无兴趣，但为了应付公司的任务，他花了10天设计出个脚本语言，由于设计时间太短，一些细节考虑得不够严谨。 如果他能预见到未来这种语言会成为互联网第一大语言，全世界有成千上万的学习者，他一定会多花一点时间吧。1995年Natscape公司决定在即将发行的Netcape Navigator2.0中加入一个称之为LiveScript的脚本语言，用于客户端数据验证。 后来NetScript与SUN公司联手完成LiveScript实现，就在Netcape Navigator2.0即将发布前，Netscape将其更名为JavaScript，目的是为了利用Java这个因特网当时的时髦词汇，Netscape的赌注最终得到了回报，JavaScript从此变成了因特网的必备组件。Brendan Eich最初遇到的问题简直就是小菜一碟了， 做个简单的表单验证，就解决问题了。 除此以外JavaScript 还可以操作DOM树。有了这棵树，它可以定位到DOM树中任意一个节点， 然后对这个节点进行操作，例如隐藏节点、显示节点、改变颜色、获得文本的值，改变文本的值，添加一个响应点击事件的函数等等，几乎为所欲为。这些操作可以立刻展示出效果来，你完全不用刷新网页。这些操作完全是内部进行的，html源码并不会改变，所以有时候你打开html源码，会发现这些源码和你在浏览器中看的效果并不一致，那就是JavaScript在背后改变了这个DOM树了。 JavaScript还能控制浏览器，比如打开窗口，在一个窗口内前进、后退，获得浏览器的名称，版本等等。为啥要获得浏览器的名称和版本呢？因为JavaScript1.0的成功，Netscape在它的3.0版本中发布了1.1版，恰巧那个时候，微软决定进军浏览器，发布了IE3.0并搭载了一个JavaScript的克隆版，叫做Jscript(这个命名是为了避免与NetScape潜在的许可纠纷)，微软步入Web浏览器领域的这重要一步虽然令其声名狼藉，但也成为了JavaScript语言发展过程中的重要一步。 在Netscape 和IE 进行浏览器之战的期间，他们都争相在自己的浏览器中支持Javascript，并且为了锁定程序员，还开发了很多自己浏览器的独特功能，有些功能只能在IE用，有些只能在Netscape 用，所以必须的判断是什么浏览器，这样才能特殊处理。不管怎么说，这些功能让浏览器中的网页变的更加动态了，更加有趣好玩了。 在微软进入后，有3个不同的JavaScript版本同时存在：JavaScript，Jscript以及ScriptEase，当时JavaScript并没有一个标准来统一其语法或特性。因此在1997年，JavaScript1.1作为一个草案提交给欧洲计算机制造商协会(ECMA)，第39技术委员会(TC39)被委派来”标准化一个通用、跨平台、中利于厂商的脚本语言的语法和语义” 。 由来自Netscape，Sun，微软、Borland和其他一些对脚本编程感兴趣的公司的程序员组成的TC39锻炼出了ECMA-262，该标准定义了叫做ECMAScript的全新的脚本语言，从此Web浏览器就开始努力将ECMAScript作为JavaScript实现的基础。 互联网的发展超出了所有人的预料，JavaScript被应用在几乎每一个网站上，但它只能在浏览器中运行，没法像java 那样访问网络，也就没有办法调用服务器端的接口来获取数据。用户只能通过GET或者POST向服务器发送请求，这时候服务器返回的数据是整个页面，而不是页面中的一个片段，也就是说整个页面都得刷新一遍，哪怕是页面中只有一个文字的改变。 1998年，IE5中引入一个新的功能：XMLHttpRequest，这个新功能将允许JavaScript直接向服务器发出接口调用。这个过程就是访问一下服务器端处理登陆的接口，IE5先干别的事儿，JavaScript得到服务器端的返回数据以后，用下IE5的这个函数。这其实就是异步调用，如果服务器处理和网络速度都足够快的话，用户就会发现：咦，我没有刷新整个页面，竟然已经登录了啊。IE都没有料到，这个功能带来了一场革命：这种方式可以使得网页局部刷新，让用户浏览网页的体验极佳，尤其是Google 地图，Gmail 等应用让互联网应用火了起来。其他浏览器也迅速跟进，实现了类似功能，各种各样交互性极佳的网站如雨后春笋般出现。之后桌面应用慢慢的都被搬到了互联网上。上面的那种处理方式称为AJAX即”Asynchronous Javascript And XML”(异步的JavaScript和XML)，异步问题解决了，但是XML真正的数据很少，标签反而占了大头，把数据都给淹没了。 Javascript的语法，里边有个叫对象的东西, 它有一个花括号，在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义，属性由逗号分隔。这种结构完全可以表达上面的xml内容。而且还支持数组，这样表达多个对象也不在话下。更重要的是，如果采用这种结构， Javascript根本不用什么XML解析器去解析了，它就是Javascript语言的一部分。直接拿来用即可。这种简洁的格式叫做JSON, 并且和服务器约定，都用JSON来传输数据。 HTML结构层，CSS样式层，而Javascript (加上AJAX, JSON)行为层。前端编程三个部分形成了。ExtJS, prototype, JQuery这些框架把前端编程推向另外一个高峰。甚至出现了AngularJS ，实现了SPA(单一页面应用程序)。但Javascript依然只能在浏览器和网页上。这也是为什么总有的人将Javascript被贬为雕虫小技，对它不屑一顾。但在Javascript发明十几年以后，又一位大牛Ryan Dahl于2009年把Javascript放到了服务器端，这就是node.js。越来越多使用node.js的网站证明， javascript的确可以在服务器端立足，并且有一个巨大的优势：前端和后端都用javascript！]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端CSS3选择器和常用样式]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFCSS3%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSS3基础 说明：CSS3完全向后兼容，浏览器永远支持CSS2，CSS3就是CSS2的扩展版，W3C的CSS3规范虽然仍在开发，但许多新的CSS3属性已在现代浏览器中使用。主要包含：选择器、盒模型、背景和边框、文字特效、2D/3D转换、动画、多列等 CSS3属性选择器​ 以&lt;input type=&quot;text&quot;&gt;为例 input[type] ：只使用属性名，但没有确定任何属性值 input[type=&quot;value&quot;] ：指定属性名，并指定了该属性的属性值 input[type~=&quot;value&quot;] ：指定属性名，并且具有属性值，此属性值是一个以空格隔开的词列表，词列表中包含了一个value词 input[type^=&quot;value&quot;] ：指定了属性名，并且拥有属性值，属性值是以value开头的 input[type$=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type*=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type|=&quot;value&quot;] ：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn） CSS3伪类 （常用）E:nth-child(n) ：表示E父元素的第n个子节点，且类型为E 特殊值：odd(匹配奇数行)等价于2n+1 even(匹配偶数行)等价于2n(下面的其他选择器同理) （常用）E:nth-of-type(n) ：表示E父元素的第n个E子节点 E:nth-last-child(n) ：表示E父元素的第n个子节点，从后向前算，且类型为E E:nth-last-of-type(n) ：表示E父元素的第n个E子节点，从后向前算 E:first-child ：表示E父元素中的第一个子节点，且类型为E，等价于E:nth-child(1) E:last-child ：表示E父元素中的最后一个子节点，且类型为E，等价于E:nth-last-child(1) E:first-of-type ：表示E父元素中的第一个E子节点，等价于E:nth-of-type(1) E:last-of-type ：表示E父元素中的最后一个E子节点，等价于E:nth-last-of-type(1) E:empty ：表示E元素没有子节点。注意：包含文本节点 E:only-child ：表示E父元素中只有一个子节点。注意：不包含文本节点 E:only-of-type ：表示E父元素中只有一个子节点，且这个唯一的子节点的类型必须是E。注意：不包含文本节点 E:target ：表示当前的URL片段的元素类型(id被a的href链接并被点击，也就是锚点——访问的a标签的链接为某元素的id)，这个元素必须是E E:disabled ：表示不可点击(获取焦点)表单控件 E:enabled ：表示可点击(获取焦点)的表单控件 E:checked ：表示已选中的checkbox或radio E:not(s) ：表示E选中的元素中的s不被匹配(s是标签名) E~F ：表示E元素毗邻的所有F元素(之后的所有同级元素，类似于nextAll())，下一个F元素则要用”+” 举几个例子~ 锚点和激活锚点（第12条）： ​ 题目：设置3个div盒子(150*150,红)，设置3个a标签，div盒子和a标签内容分别为div1,div2,div3 ​ 要求：1. 激活锚点：当点击a标签的内容时，跳转到对应的div盒子所在位置； ​ 2. 当div元素的锚点被激活时，背景颜色变为蓝色 ​ 提示：激活锚点：a标签的href里是#div（也就是div元素的id值） a. HTML部分： 123456&lt;a href="#div1"&gt;div1&lt;/a&gt;&lt;a href="#div2"&gt;div2&lt;/a&gt;&lt;a href="#div3"&gt;div3&lt;/a&gt;&lt;div id="div1"&gt;div1&lt;/div&gt;&lt;div id="div2"&gt;div2&lt;/div&gt;&lt;div id="div3"&gt;div3&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122232425262728293031323334/* 为了展示跳转效果，特意给body设置高度 */body&#123; height: 4000px;&#125;/* 设置div盒子的样式 */div&#123; width: 150px; height: 150px; background-color: red; position: absolute; font-size: 50px; color: white;&#125;/* 分别定位每个div盒子的位置（也是为了展示跳转效果） */div:nth-of-type(1)&#123; left: 0; top: 500px;&#125;div:nth-of-type(2)&#123; left: 0; top: 1500px;&#125;div:nth-of-type(3)&#123; left: 0; top: 1800px;&#125;di:nth-of-type(4)&#123; left: 0; top: 2000px;&#125;/* 当div元素的锚点被激活时，背景颜色变为蓝色 */div:target&#123; background-color: blue;&#125; 表单伪类（第13条）：设置一个不可点击的表单控件 a. HTML部分： 1&lt;input type="text" disabled&gt; ​ b. CSS部分： 123input:disabled&#123; border: 1px blue solid;&#125; CSS3伪元素 E::first-line ：表示E元素中的第一行 E::first-letter ：表示E元素中的第一个字符 E::selection ：表示E元素在用户选中文字时(moz) 举个例子~ ​ 题目：设计一个p标签，文字随意 ​ 要求：第一个字大小为30px，第一行文字颜色为蓝色，当用户选中文字时选中的背景颜色变为绿色且被选文字颜色为橘色 ​ a. HTML部分： 123&lt;p&gt; 语文老师说：“如果你越来越冷漠，你以为你成长了，但其实没有。长大应该是变得温柔，对全世界都温柔。”&lt;/p&gt; ​ b. CSS部分： 123456789101112131415161718/* 设置p标签的样式 */p&#123; width: 300px; border: 1px #000 solid;&#125;/* 设置第一个字的大小 */p::first-letter&#123; font-size: 30px;&#125;/* 设置第一行文字的颜色 */p::first-line&#123; color: blue;&#125;/* 当用户选中文字时的样式变化 */p::selection&#123; background-color: green; color: orange;&#125; 练习1： 做一个商品列表（12个），要求4行一列，每两个商品(100*100)之间需要有间距(10px)，但是商品与边界之间无间距 a. HTML部分： 123456789101112131415&lt;!-- 设置12个li --&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ​ b. CSS部分： 123456789101112131415161718ul&#123; /* 引入common.css后，宽度要加上2px的边框 */ width: 432px; border: 1px #000 solid; /* 清浮动 */ overflow: hidden;&#125;li&#123; background-color: red; width: 100%; height: 100px; float: left; margin: 0 10px 10px 0;&#125;/* 商品与边界之间无间距 */li:nth-of-type(4n)&#123; margin-right: 0;&#125; 模拟单选和多选框 a. HTML部分： 123&lt;!-- 加span标签 --&gt;&lt;label&gt;&lt;input type="radio" name="sex"&gt;&lt;span&gt;&lt;/span&gt; 男&lt;/label&gt;&lt;label&gt;&lt;input type="radio"&gt;&lt;span&gt;&lt;/span&gt; 女&lt;/label&gt; ​ b. CSS部分： 123456789101112131415161718192021/* 这样设置没作用 *//* input[type="radio"]&#123; width: 50px; height: 50px; border: 1px red solid; &#125; */span&#123; display: inline-block; width: 10px; height: 10px; border: 1px red solid; vertical-align: middle;&#125;input[type="radio"]&#123; position: absolute; left: -9999px;&#125;/* 下一个同级元素span：+span */input[type="radio"]:checked+span&#123; background-color: red;&#125; CSS3新文本样式 文本阴影：text-shadow:x y blur color, … （x/y 横向偏移/纵向偏移 blur 模糊距离 color 阴影颜色）文本阴影如果加很多层，会很卡，如：text-shadow:2px 2px 4px black 注意：有多个阴影的先渲染后面的，再渲染前面的 叠加： 1text-shadow: 2px 2px 0px red, 2px 2px 4px green; 层叠： 1234color:red; font-size:100px; font-weight:bold; text-shadow:2px 2px 0px white, 4px 4px 0px red; 光晕： 123color:white; font-size:100px;text-shadow:0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de, 0 0 100px #ff00de, 0 0 150px #ff00de; 火焰： 12345text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-family:Verdana, Geneva, sans-serif; font-size:100px; font-weight:bold; color:white; 盒模型阴影：box-shadow:[inset] x y blur [spread] color ​ （ [inset]：投影方式(默认为外投影，inset为内投影)​ x、y：水平和垂直方向的阴影偏移​ blur：模糊半径​ [spread]：扩展阴影半径(先扩展原有形状，再开始画阴影)​ color：颜色 ） 举例~ ​ a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 1234567div&#123; width: 150px; height: 150px; background-color: red; margin: 150px auto; box-shadow: 10px 10px 2px 20px rgba(0,0,0,0.7);&#125; 定义文字排列方式(全兼容)：directionrtl ：从右向左排列；ltr ：从左向右排列注意：要配合unicode-bidi:bidi-override; 一块使用 1234/* 文字从左向右排列 */.ltr p&#123;direction:ltr;unicode-bidi:bidi-override;&#125;/* 文字从右向左排列 */.rtl p&#123;direction:rtl;unicode-bidi:bidi-override;&#125; 定义省略文本的处理方式：text-overflow clip ：无省略号 ellipsis ：省略号 注意：要配合overflow:hidden和white-space:nowrap一块使用 多列：将文本内容设计成像报纸一样的多列布局，集合样式：column column-width：指定列的宽度 column-count：要分的列数 column-gap：列之间的距离 column-rule：栏目间隔线由column-rule-style(hidden：定义隐藏规则/dotted：定义点状规则/dashed：定义虚线规则/solid：定义实线规则/double：定义双线规则)、column-rule-width和column-rule-color的集合成 calc()函数：用于动态计算长度值 ​ 注意：运算符前后都需要保留一个空格 ​ 例如：width: calc(100% - 10px) (父元素宽度-10px) 任何长度值都可以使用calc()函数进行计算 calc()函数支持 “+”, “-“, “*”, “/“ 运算calc()函数使用标准的数学运算优先级规则 练习2： 阴影：给一个P标签做一个火焰效果 a. HTML部分： 1&lt;p&gt;最美的时光&lt;/p&gt; ​ b. CSS部分： 1234567p&#123; font-weight: bold; text-align: center; text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-size:100px; font-weight:bold; color:white;&#125; 做《静夜思》的文字布局（从右向左，从上到下） a. HTML部分： 1&lt;p&gt;床前明月光疑是地上霜举头望明月低头思故乡&lt;/p&gt; ​ b. CSS部分： 123456789p&#123; font-size: 20px; width: 100px; /* 一共有4列 */ column-count: 4; /* 从右向左排列 */ direction: rtl; unicode-bidi: bidi-override;&#125; CSS3新样式 变形：包含旋转函数、倾斜函数、缩放函数、位移函数 旋转函数： 12transform:rotate() /* 旋转度数(deg) */transform-origin:x y /* 旋转基点 */ 倾斜函数： 123transform:skew() /* 斜切度数(deg) */transform:skewX() /* 水平方向倾斜 */transform:skewY() /* 垂直方向倾斜 */ 缩放函数： 123transform:scale() /* 缩放取值(正数、负数和小数) */transform:scaleX() /* 水平方向缩放 */transform:scaleY() /* 垂直方向缩放 */ 位移函数： 123transform:translate() /* 位移取值(像素值) */transform:translateX() /* 水平方向位移 */transform:translateY() /* 垂直方向位移 */ ​ 2. 过渡：transition集合样式(css3的动画的一种) 12345678transition-property：要运动的样式(all || [attr] || none)transition-duration：规定完成过渡效果需要多少秒或毫秒transition-delay：定义动画延迟多久开始transition-timing-function：运动速度曲线。 ease：(逐渐变慢)默认值；linear：(匀速)； ease-in：(加速)；ease-out：(减速)； ease-in-out：(先加速后减速)； cubic-bezier 贝塞尔曲线( x1, y1, x2, y2 )，可以百度一下贝赛尔曲线的图 圆角：border-radius 集合样式：border-top-left-radius/border-top-right-radius/border-bottom-right-radius/border-bottom-left-radius，也就是从左上角开始顺时针数 即，1-4个数字 / 1-4个数字：/前面是水平方向圆角，后面是垂直方向圆角，不加/指的两个方向圆角相同，如：border-radius: 10px/5px; 参数：各种长度单位都可以：px，%，…，%有时很方便，但宽高不一致时不太好参数个数1：四个方向都一样，border-radius: 一样参数个数2：对角，border-radius: 左上&amp;右下 右上&amp;左下参数个数3：斜对角，border-radius: 左上 右上&amp;左下 右下参数个数4：全部，顺时针，border-radius: 左上 右上 右下 左 边框图片：border-image(集合样式) 引入图片url ：border-image-source 切割图片(从外向内，可以是不带单位的数字或百分比)：border-image-slice 边框宽度(展示边框图片区域)：border-image-width 边框图像区域超出边框的量：border-image-outset 图片的排列：border-image-repeat 图片的排列方式：round 四舍五入，repeat 重复，stretch 拉伸 集合样式：border-image:url() s s s s/w w w w/o o o o repeat 练习3： 做一个可旋转的风车，用圆角做风车的叶片 a. HTML部分： 123456&lt;div class="wrap"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122.wrap&#123; width: 600px; height: 600px; overflow: hidden; margin: 0 auto; transition: 10s all linear;&#125;.wrap&gt;div&#123; width: 300px; height: 300px; background-color: red; float: left;&#125;.wrap&gt;div:nth-child(1),.wrap&gt;div:nth-child(4)&#123; border-radius: 0 90%;&#125;.wrap&gt;div:nth-child(2),.wrap&gt;div:nth-child(3)&#123; border-radius: 90% 0;&#125;.wrap:hover&#123; transform: rotate(1800deg);&#125; 用过渡做按钮1：做一个搜索按钮，在鼠标移入时慢慢出现一个=&gt;符号 a. HTML部分： 1&lt;div class="parent"&gt;搜索&lt;/div&gt; ​ b. CSS部分： 1234567891011121314151617181920.parent&#123; width: 120px; height: 40px; border: 1px #000 solid; text-align: center; line-height: 40px; font-size: 22px; border-radius: 20px;&#125;.parent::after&#123; display: inline-block; content: "=&gt;"; width: 0; opacity: 0; transition: all 0.3s linear;&#125;.parent:hover::after&#123; width: 25px; opacity: 1;&#125; 用过渡做按钮2：做一个立体按钮，在击中时显示下压效果 a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112div&#123; width: 80px; height: 35px; background-color: greenyellow; box-shadow: 0 8px 0 rgba(0,0,0,0.4); border-radius: 17px; transition: all 0.3s linear;&#125; div:active&#123; box-shadow: 0 1px 0 rgba(0,0,0,0.4); transform: translateY(7px);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端BFC和三栏式布局、SEO和服务器、HTTP]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFBFC%E5%92%8C%E4%B8%89%E6%A0%8F%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81SEO%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81HTTP%2F</url>
    <content type="text"><![CDATA[BFC(Block fomatting context) “块级格式化上下文”。是一个独立的渲染区域，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Box是CSS布局的对象和基本单位，一个页面是由很多个Box组成的。元素的类型和display属性，决定了这个Box的类型。 不同类型的Box，会参与不同的Formatting Context(一个决定如何渲染文档的容器)，因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且会参与 block fomatting context；(简称BFC) inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且会参与 inline formatting context；(简称IFC) Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会变成BFC区域 根元素 float属性不为none position属性值为absolute或fixed display属性为inline-block, table-cell, table-caption, flex, inline-flex overflow属性不为visible BFC的用法： 自适应两栏布局：左栏定宽左浮动，右栏不定宽overflow:hidden;(设置成BFC) 清除内部浮动：父元素设置overflow:hidden;(设置成BFC)，既之前我们用来清除浮动的方法之一 防止垂直 margin 重叠：其中一个元素外套一个div并设置overflow:hidden;(设置成BFC) 三栏式布局 三栏式布局是一种，两边盒子固定宽度，中间盒子自适应的布局 圣杯布局和双飞翼布局 父元素包含左中右三个盒子，分别左浮动，中间元素宽度100%(必须为第一个渲染) 用margin-left的负值将两边盒子拉上去和中间盒子同行(左边-100%，右边-右盒子宽度) 给父元素上清除浮动 父元素用左右padding为左右盒子留位置并用相对定位将左右元素移动到正确的位置上(圣杯) 给中间元素设置子元素，并给其左右margin为左右盒子留位置(双飞翼) 转义和框架标签 HTML的转义字符，网上可以找到转义字符的表(http://tool.oschina.net/commons?type=2) 通过&amp;XXXX的格式生成一个转义字符 原因是有部分字符无法直接在html里直接生成，如：空格 、&amp;符号、大于号&gt;、小于号&lt;、©符号等 做个练习~ 在页面中生成下面的句子： ​ 在页面里输入一个&lt;br /&gt;就可以实现换行了 ​ 在页面里输入&amp;nbsp;就可以实现空格&nbsp;效果了 ​ 在页面里输入&amp;copy;就可以实现&copy;符号了 123&lt;p&gt;在页面里输入&amp;lt;br /&amp;gt;就可以实现换行了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;nbsp;就可以实现空格效果了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;copy;就可以实现©符号了&lt;/p&gt; iframe：框架标签(在当前页面显示多个网页) scrolling：是否有滚动条，值为yes(有)/no(无)，默认为auto(需要的时候出现) frameBorder：是否有边框，值为正整数，默认为1，值为0时无边框 align：对齐方式 src：嵌套页面地址 width/height：嵌套页面区域的宽高 name：配合a的target属性值等于iframe的name，可以让a在超链接的跳转打开页面时在iframe区域打开 优点：解决加载缓慢的第三方内容图标和广告等的加载问题；iframe无刷新文件上传；iframe跨域通信 缺点：iframe会阻塞主页面的onload事件；无法被一些搜索引擎索引到；页面会增加服务器的http请求；会产生很多页面，不容易管理。 雪碧图和引入样式表 sprites(雪碧图)原理 首先把网页中一些背景图片整合到一张图片文件中(png格式) 用”background-image”引入图片；”background- repeat”禁止平铺；”background-position”精确定位背景 优点：减少网页的http请求次数，并防止切换图片出现的闪白；减少图片的字节数，解决图片命名上的困扰(对一张集合的图片上命名就可以了，不用对每一个小图片进行命名)；更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变 缺点：在宽屏，高分辨率的屏幕下的自适应页面，雪碧图如果不够宽，容易出现背景断裂；在开发的时候，需要通过photoshop或其他工具测量计算每一个背景单元的精确位置在维护的时候比较麻烦，如果页面背景有少许改动，一般就要修改整张合并的图片 @import：引入css样式表 1@import url(CSS文件路径地址); //语法 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 SEO 搜索引擎工作原理： 搜索引擎网站的数据库存储着海量的关键词，每个关键词对应着很多网址，收集这些数据的程序称之为“搜索引擎蜘蛛”或“网络爬虫”。 “爬虫”每天在互联网上分析提炼，找到对用户有用关键词便存入数据库；垃圾或重复信息就舍弃。 用户输入关键词时，搜索引擎就能检索出与关键字相关的网址。关键词又对应多个网址，就出现了排序的问题，与关键词最吻合的网址就会排在前面。 并不是所有语言“爬虫”都能看懂。flash和js它便看不懂，即使关键字再贴切也没用。而网站内容是它的语言(SEO)，它便能看懂。 SEO简介 Search English Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 SEO就是为了提升我们的网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。 白帽SEO起到改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。 黑帽SEO利用和放大搜索引擎政策缺陷来获取更多用户的访问量，大多是欺骗搜索引擎，这是搜索引擎公司是不支持与鼓励的。 白帽SEO怎么做：对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；网站内容优化：内容与关键字的对应，增加关键字的密度；在网站上合理设置Robot.txt文件(保障网络安全与网站隐私，里面规定了哪些不予许“爬虫”搜索)；生成针对搜索引擎友好的网站地图；增加外部链接，到各个网站上宣传； 前端SEO：通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“爬虫”看懂。 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。建立的网站结构层次越少，越容易被“爬虫”抓取； 控制首页链接数量：链接太少会使“爬虫”缺乏往下爬的“桥”，影响收录数量；链接太多，影响用户体验，降低了网站首页权重，效果也不好。尽量让“爬虫”最多跳转3次，就能到达网站内的任何一个内页。 导航优化，尽量采用文字，如果用图片代码一定要添加“alt”和“title”属性(图片未能正常显示时用户也能看到提示)。另外每个网页上应该加上面包屑导航(如新闻&gt;某新闻) 网站的结构：头部——logo及主导航，以及用户的信息；页面主体——一边面包屑导航及正文；一边放热门文章及相关文章，这些相关链接增强了页面相关性，也增强页面的权重；页面底部——版权信息和友情链接；分页写法——“首页 1 2 3 4 5 下拉框”，这样“爬虫”能直接跳转，下拉框直接选择页面；而“首页 下一页 尾页”的写法，当分页数量特别多时，“爬虫”需要经过很多次往下爬，才能抓取，超时容易放弃。 控制页面的大小，减少http请求，提高网站的加载速度。页面最好不要超过100k，太大页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“爬虫”也会离开。 网页代码优化：除了精简代码外还要有以下设置 meta keywords标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌；meta description标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 title标签，强调重点，把重要的关键词放在前面且不要重复出现，每个页面的title标题中不要设置相同的内容；body的标签：代码语义化，适当的位置使用适当的标签。让阅读源码者和“爬虫”都一目了然。比如：h1-h6 是用于标题类的，nav标签是用来设置页面主导航的等。 a标签：页内链接要加 “title” 属性说明，让访客和 “爬虫” 知道。外部链接，则需要加上 el=”nofollow” 属性, 告诉 “爬虫” 不要爬，否则它就不会再回来了；br标签：只用于文本内容的换行；img应使用 “alt” 和”title”属性加以说明 正文标题要用h1标签：“爬虫”认为它最重要，副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签；表格标签用caption strong和em标签：需要强调时使用。strong在搜索引擎中会得到高度重视，它突出关键词表现重要的内容，em强调效果仅次于strong。b和i标签: 只是显示效果，在SEO中不会起任何效果。 文本缩进不要使用特殊符号，应使用CSS进行设置；版权符号不要使用特殊符号，可以直接使用输入法中的版权符号©；对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。搜索引擎会过滤掉display:none中的内容。 巧妙布局，将重要内容的代码放在前面，前面的内容被认为是最重要的，优先让“爬虫”读取，进行内容关键词抓取。 少使用iframe框架,因为“爬虫”一般不会读取其中的内容；重要内容不要用JS输出，因为“爬虫”不认识；js代码如果是操作DOM操作，应尽量放在body结束标签之前，html所有标签之后。 Server-Browser技术 WEB的三要素：直接打开的html文件并没有经过WEB的三要素，正式项目时需要安装环境 Server(服务器) Client(客户端)/Browser(浏览器) HTTP(传输通信)/HTTPS(加密传输) 客户端技术：HTML/CSS/JS和图片等，储存于服务器，供客户端申请下载，在服务器看来他们只是二进制的字符，服务器不会对这些内容做任何处理 服务器端技术：JSP/PHP/ASP.NET，储存于服务器，供客户端进行请求，但返回客户端之前，其中的代码会在服务器端获得执行，得到的结果是纯的静态数据，发送给客户端。 服务器(Server)：是网络环境中的高性能计算机，它侦听网络上的其他客户机提交的服务请求，并提供相应的服务，如”域名解析”、”文件下载”、”网页浏览”、”邮件收发”等等。 要求：高可用性、高速运算、高带宽、高可靠性、强大的数据吞吐能力。 Client-Server模型(C/S模型)：如QQ客户端 Brouser-Server模型(B/S模型)：如谷歌浏览器 随着H5和前端的发展，B/S会部分取代C/S，因为只需要在服务器端更新就可以立即使用最新版 硬件服务器：按大小可以分为工作站、小型机、中型机、大型机、超级计算机。 软件服务器：不论是超级计算机、小型服务器、还是PC机，为了向客户端提供服务，必须安装能够监听特定端口，并接受客户端请求的应用程序–服务器应用程序。根据能投提供的服务的不同，服务器应用程序包括： DNS服务器：把域名解析为计算机的IP地址 Web服务器：提供Web页面服务 数据库服务器：提供数据的永久储存和高效查询 FTP服务器：文件上传和下载服务 SMTP/POP3服务器：邮件收发服务 SSH服务器：远程登录服务 Samba服务器：文件和打印机共享服务 如何访问服务器：客户端访问网络上的一台服务器，必须提供如下信息——访问协议：类似两个人通话必须先确定所说的语言；主机地址：服务器的域名或IP地址；端口号：一台计算机上可能提供多种服务，不同服务使用不同端口；除此之外，有的服务还可能需要客户端提供用户名/密码、资源路径，请求参数等。 配置服务器环境 AMP–集成了Apache, PHP5, 和MySQL 浏览器服务器文件localhost/文件.txt，这种方式和用路径在浏览器上打开的方式是不同的，前者是在服务器上 很多东西必须在服务器上运行，如cookie和ajax等 超文本传输协议(HTTP，HyperText Transfer Protocol) HTTP协议是互联网应用最为广泛的一种网络协议。设计它的最初目的是为了提供一种发布和接收HTML页面的方法。 只要上网就要用到它，比如我们登录百度页面就要使用HTTP请求百度页面的数据，同时要遵守HTTP协议的语法和规则。 HTTP是两台电脑(服务器和客户端)之间的通讯，客户端发起请求(通常是用域名)，服务器响应请求(发送页面数据)。 下面是客户端和服务器在发起HTTP协议时的详细过程： 第一步，先建立服务器和客户端的TCP的握手。 第二步，客户端向服务器发出文本数据，如：POST //发送请求的方法；index.html //请求的页面；HTTP/1.1 //HTTP的版本 还有请求的报头和它的值如：HOST: www.baidu.com //域名；Connection: //服务器发送数据后的链接状态；User_agent: Mozilla/4.0 //浏览器；Accept-language: zh-CN //语言 以及报体(get请求不需要报体)，如：Name=unknow&amp;age=22 //内容 第三步，服务器响应结果：HTTP/1.1 //HTTP的版本；200 ok //状态码和文本描述 以及响应的报头和它的值如：Server: Apache-Coyote/1.1 //域名；Last-Modified: Thu， 24 Nov 2011 12::22:00 GMT //最后修改时间；Content_Type: text/html;charset=GB18030 //使用的字符集；Content-Language: zh-CN//语言；Content-Length: 23980 //内容大小；Date: Fri, 25 Nov 2011 07:22:02 GMT //时间 最后空一行之后是它的报体(html页面)：…… HTTP详解：https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html 上传一个网站 我们需要一个网上的服务器(需要花钱租用，比如西部数码、阿里云、腾讯云等等) 准备一个网站项目，并用FTP软件将它上传到该服务器上 在FTP软件的快速连接里输入服务器的地址，并通过用户名和密码连接到服务器上，然后上传你的项目 准备一个自己的域名，并将其绑在我们的服务器上，这样在互联网上打开该域名就会自动打开项目中的index.html了 个人网站也是需要备案的，这里是个人网站详细的备案过程]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-八、VIM程序编辑器]]></title>
    <url>%2F2019%2F07%2F18%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AB%E3%80%81VIM%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[八、VIM程序编辑器]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 七、RAID 与 LVM]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%83%E3%80%81RAID-%E4%B8%8E-LVM%2F</url>
    <content type="text"><![CDATA[七、RAID 与 LVM RAID (1) RAID : Redundant Array of Independent Disks，磁盘冗余阵列 (2) RAID意义：通过增肌多个硬盘，形成独立的硬盘组，将数据划分成多份，分散存储，以提高硬盘读写效率 (3) RAID本质：防止硬盘物理损坏及增加存储设备吞吐量 (4) 分类： ​ A. RAID0 ​ (a) 意义：原理：把至少2块硬盘通过硬件或软件方式串联，组成一个大的卷组，并将数据依次写入到各个硬盘中 ​ (b) 优点：数据同步传输，读取/写入分开，性能大大提升 ​ (c) 缺点：若任意一块硬盘故障会导致整个系统的数据损坏，无备份冗余能力、错误修复能力 ​ (d) 总结：使用率100%，至少2块硬盘才能使用，优点是快，提升磁盘的读写速度，缺点是不安全 ​ (e) 结构图： ​ ​ B. RAID1： ​ (a) 产生原因：若生产环境对硬盘的读写速度没有较大要求，但希望增加数据安全性时可使用RAID1 ​ (b) 原理：将至少2块硬盘并联起来，写入数据时，同时写入，多个硬盘内容相同 ​ (c) 本质：多个硬盘的镜像备份 ​ (d) 优点：备份冗余数据，安全性大大提升 ​ (e) 缺点： 硬盘利用率下降 ​ (f) 总结：本质是镜像，使用两块磁盘，一式两份的方式，支持容错，冗余，数据安全不丢失，缺点是速度不快，使用率50%，成本较大 ​ (g) 结构图： ​ ​ C. RAID5: ​ (a) 产生原因：兼顾“读写速度”、“数据安全”、“成本”的一种折中方式 ​ (b) 原理：需至少3块硬盘，将数据分块存储到不同硬盘中，硬盘中必须存储其他一个硬盘的parity（奇偶校验信息） ​ (c) 优点：兼顾性能，通过“奇偶校验”替代“镜像备份” ​ (d) 缺点：硬盘数据安全性较低 ​ (e) 总结：使用率(n-1)/n*容量，磁盘坏了会立即补上，数据会恢复 ​ (f) 结构图： ​ ​ D.RAID10：（主流） ​ (a) 原理：至少需要4块硬盘，先制作两两的RAID1阵列，以保证安全性，在两两制作RAID0，以提高读写速度 ​ (b) 本质：RAID1+RAID0的组合 ​ (c) 优点：兼具速度和安全性 ​ (d) 缺点：成本较高 ​ (e) 结构图： ​ (5) mdadm命令： ​ A. 过程： ​ (a) 关机添加4个新硬盘 ​ (b) mdadm命令建立RAID10 ​ (c) 格式化 ​ (d) 建立挂载目录 ​ (e) 挂载 ​ (f) 开机挂载 ​ (g) 查看信息 ​ B. mdadm命令格式： ​ mdadm -参数 &lt;RAID 设备名&gt; [模式] [成员设备名称] ​ C. 作用：建立或管理RAID ​ D. 参数： ​ (a) -a ：检测设备名称 ​ (b) -C ：创建RAID ​ (c) -v ：显示过程 ​ (d) -l ：指定RAID级别 ​ (e) -n ：指定硬盘数量 ​ (f) -f ：模拟设备损坏 ​ (g) -D ：查看详细信息 ​ (h) -r ：移除设备 ​ (i) -Q ：查看摘要 ​ (j) -S ：停止RAID磁盘阵列 ​ E. 例：添加4块硬盘，创建RAID10 ​ (a) 创建RAID10： mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde ​ -Cv ：创建RAID并显示过程 ​ -a yes ：检测创建设备名 ​ -n 4 ：4块硬盘参与建立 ​ -l 10 ：RAID级别为10 ​ (b) 格式化：mkfs.xfs /dev/md0 ​ (c) 建立挂载目录：mkdir /mnt/raiddev ​ (d) 挂载：mount /dev/md0 /mnt/raiddev ​ (e) 开机挂载设置：vim /etc/fstab ​ 增加行： /dev/md0 /mnt/raiddev xfs defaults 0 0 ​ (f) 开机挂载检测：mount -a ​ (g) 查看RAID10信息：mdadm -D /dev/md0 ​ F. 模拟硬盘损坏的处理流程 ​ (a) 模拟损坏：mdadm /dev/md0 -f /dev/sdb ​ (b) 查看信息：mdadm -D /dev/md0 ​ (c) 关机，添加新硬盘 ​ (d) 卸载RAID：umount /dev/md0 ​ (e) RAID补上新硬盘：mdadm /dev/md0 -a /dev/sdf ​ (f) 重启：reboot ​ (g) 查看信息：mdadm -D /dev/md0 ​ (h) 注意：添加新硬盘时必须先卸载 ​ G. 停止RAID ​ (a) 注意：在实际工作中，停止RAID前必须备份其中数据，否则数据会全部丢失 ​ (b) 过程： ​ ◆ 卸载设备：umount /dev/md0 ​ ◆ 删除开机挂载配置文件中RAID的记录 ​ ◆ 停止RAID：mdadm -S /dev/md ​ H. RAID 10备份盘功能 ​ (a) 产生原因：在RAID1中，某块硬盘损坏，在手工修复成功前另一块硬盘也同时损坏，则整个数据会全部丢失 ​ (b) 原理：在RAID10中再添加一块硬盘，作为备份盘，一旦某硬盘损坏，会自动修复 ​ (c) RAID共需5块硬盘（4个数据盘，1个备份盘） ​ (d) 方法： ​ ◆ 新建RAID10+备份盘：mdadm -Cv /dev/md1 -a yes -n 4 -l 10 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf ​ （-x 1 ：表示备份盘，1块硬盘） ​ （一般最后一块硬盘/dev/sdf 为备份盘，习惯放置在最后） ​ ◆ 查看信息摘要：mdadm -D /dev/md1 ​ ◆ 模拟某硬盘损坏：mdadm /dev/md1 -f /dev/sdb ​ ◆ 重启系统：reboot ​ ◆ 再次查看信息摘要：mdadm -D /dev/md1 ，备份盘/dev/sdf已替换故障硬盘 LVM（逻辑卷管理器） (1) 产生原因：由于硬盘分区并设置为RAID后，对其空间调整并不容易，此时用户随着实际的需求变化而动态调整硬盘分区大小时受到限制，无灵活性 (2) LVM作用：允许用户动态调整磁盘空间大小 (3) 原理：LVM是在磁盘分区与文件系统之间添加逻辑层，以提供一个抽象的卷组，使管理者可以忽略底层磁盘布局，从而实现对分区的灵活动态调整 (4) 分析： ​ A. 图： ​ ​ B. 物理卷（PV, Physical Volume）：整个硬盘或分区 ​ C. 卷组（VG, Volume Group）：由一个或多个物理卷（PV）组成的整体 ​ D. 逻辑卷（LV, Logical Volume）：从卷组（VG）切割出的空间，用于创建文件系统，大小由PE的个数决定 ​ E. 基本单元（PE, Physical Extent）：默认为4MB的基本块 (5) 基本命令： ​ (6) 硬盘支持LVM的流程： ​ A. 将新硬盘支持物理卷技术 ​ B. 创建卷组，将新硬盘加入卷组 ​ C. 根据需求切割出指定容量的逻辑卷 ​ D. 格式化逻辑卷 ​ E. 创建挂载目录 ​ F. 添加开机挂载信息 ​ G. 挂载测试 ​ H. 重启系统 (7) 例：在虚拟机中添加2块新硬盘，创建物理卷及卷组，划分出150MB空间的逻辑卷并格式化挂载使用 ​ A. 新建物理卷：pvcreate /dev/sdb /dev/sdc ​ B. 新建卷组：vgcreate /dev/vg1 /dev/sdb /dev/sdc ​ C. 查看卷组信息：vgdisplay /dev/vg1 ​ D. 切割150MB逻辑卷：lvcreate -n lv1 -L 150MB /dev/vg1 ​ (a) -n ：新建逻辑卷 ​ (b) -L：逻辑卷的容量，单位为数据量（K M G） ​ E. 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ F. 格式化逻辑卷：mkfs.xfs /dev/vg1/lv1 ​ G. 建立挂载点：mkdir /mnt/lvdev ​ H. 编辑开机挂载文件：vim /etc/fstab 增加下列记录： ​ /dev/vg1/lv1 /mnt/lvdev xfs defaults 0 0 ​ I. 挂载测试：mount -a (8) 例：添加2块新硬盘，建立卷组，划分出200MB空间的逻辑卷并格式化挂载使用 ​ A. pvcreate /dev/sdd /dev/sde ​ B. vgcreate /dev/vg2 /dev/sdd /dev/sde ​ C. vgdisplay /dev/vg2 ​ D. lvcreate -n lv2 -l 50 /dev/vg2 ​ (a) lv2的路径：/dev/vg2/lv2 ​ (b) -l ：表示以PE物理卷基本存储单位4MB为单位划分，给出4MB的倍数，50表示PE个数（50*4MB） ​ E. lvdisplay /dev/vg2/lv2 ​ F. mkfs.xfs /dev/vg2/lv2 ​ G. mkdir /mnt/lvdev2 ​ H. vim /etc/fstab 增加下列记录： ​ /dev/vg2/lv2 /mnt/lvdev2 xfs defaults 0 0 ​ I. mount -a (9) 逻辑卷扩容 ​ A. 作用：根据实际需要扩大逻辑卷的存储容量 ​ B. 过程： ​ (a) 卸载逻辑卷 ​ (b) 扩容逻辑卷 ​ (c) 再次格式化 ​ (d) 挂载 ​ (e) 查看信息 ​ C. 例1：对上例lv1逻辑卷扩容到495MB ​ (a) 卸载：umount /dev/vg1/lv1 ​ (b) 查看卷组容量是否足够：vgdisplay /dev/vg1 ​ (c) 扩容：lvextend -L 495MB /dev/vg1/lv1 ​ (d) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (e) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (f) 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：对上例lv2逻辑卷扩容到800MB ​ (a) umount /dev/vg2/lv2 ​ (b) vgdisplay /dev/vg2 ​ (c) lvextend -l 200 /dev/vg2/lv2 ​ (d) mkfs.xfs -f /dev/vg2/lv2 ​ (e) mount -a ​ (f) lvdisplay /dev/vg2/lv2 ​ E. 注意 ​ (a) 扩容或缩容之前必须先卸载设备 ​ (b) 扩容后的逻辑卷必须格式化，否则挂载后显示逻辑卷容量不变 (10) 逻辑卷缩容 ​ A. 注意 ​ (a) 逻辑卷缩容相对扩容来说会有数据丢失的风险，则缩容之前应备份数据 ​ (b) 对逻辑卷缩容之前应对逻辑卷进行数据完整性检查，以保证数据正确性、完整性 ​ (c) 逻辑卷缩容之前必须卸载设备 ​ B. 过程 ​ (a) 查看逻辑卷使用量及剩余量 ​ (b) 卸载设备 ​ (c) 逻辑卷数据完整性检查 ​ (d) 缩容逻辑卷 ​ (e) 格式化逻辑卷 ​ (f) 挂载逻辑卷 ​ (g) 查看逻辑卷信息 ​ C. 例：将上列lv1逻辑卷缩容到320MB ​ (a) 查看lv使用量：df -h /dev/vg1/lv1 ​ (b) 卸载设备：umount /dev/vg1/lv1 ​ (c) 对lv进行完整性检查：xfs_repair -n /dev/vg1/lv1 ​ (d) 缩容：lvreduce -L 320MB /dev/vg1/lv1 ，输入y确认 ​ (e) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (f) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (g) 查看lv信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：将上例lv2逻辑卷缩容到440MB ​ (a) df -h /dev/vg2/lv2 ​ (b) umount /dev/vg2/lv2 ​ (c) xfs_repair -n /dev/vg2/lv2 ​ (d) lvreduce -l 110 /dev/vg2/lv2 ，输入y确认 ​ (e) mkfs.xfs -f /dev/vg2/lv2 ​ (f) mount -a ​ (g) lvdisplay /dev/vg2/lv2 (11) 删除LVM ​ A. 删除顺序：逻辑卷-&gt;卷组-&gt;物理卷 ​ B. 注意： ​ (a) 删除时，上述顺序不能反向 ​ (b) 删除时，需要输入“y”来确认操作 ​ (c) 删除时，备份卷一同被删除 ​ (d) 删除之前必须先备份数据 ​ C. 过程 ​ (a) 卸载设备 ​ (b) 删除开机挂载记录信息 ​ (c) 删除逻辑卷 ​ (d) 删除卷组 ​ (e) 删除物理卷（去掉硬盘的物理卷技术支持） ​ (f) 查看卷信息是否还存在 ​ D. 例1：删除上例 lv1、 vg1 及物理卷技术 ​ (a) 卸载设备：umount /dev/vg1/lv1 ​ (b) 删除lv1开机挂载记录：vim /etc/fstab 删除其记录项 ​ (c) 删除逻辑卷：lvremove /dev/vg1/lv1 ，输入y确认 ​ (d) 删除卷组：vgremove /dev/vg1 ​ (e) 删除物理卷：pvremove /dev/sdb /dev/sdc ​ (f) 查看信息：lvdisplay vgdisplay pvdisplay （分别执行） ​ E. 例2：删除上例 lv2、vg2及物理卷技术 ​ (a) umount /dev/vg2/lv2 ​ (b) vim /etc/fstab ​ (c) lvremove /dev/vg2/lv2 ，输入y确定 ​ (d) vgremove /dev/vg2 ​ (e) premove /dev/sdd /dev/sde (12) 逻辑卷快照功能 ​ A. 作用：类似于虚拟机软件的“快照”，可以通过快照还原点进行还原，起到备份功能 ​ B. 注意： ​ (a) 快照卷的容量必须等于逻辑卷的容量 ​ (b) 快照卷只能恢复一次，恢复后会自动删除 ​ C. 过程： ​ (a) 查看卷组剩余容量是否足够 ​ (b) 查看被制作快照的逻辑卷容量 ​ (c) 制作快照卷 ​ (d) 查看快照卷 ​ (e) 测试恢复快照卷 ​ D. 例：创建 lv 逻辑卷，制作快照卷 ​ (a) 创建物理卷：pvcreate /dev/sdb ​ (b) 创建卷组：vgcreate /dev/vg ​ (c) 创建逻辑卷：lvcreate -n /dev/vg/lv -L 200MB /dev/vg ​ (d) 格式化：mkfs.xfs /dev/vg/lv ​ (e) 建立挂载点：mkdir /mnt/lvdev ​ (f) 挂载：mount /dev/vg/lv /mnt/lvdev ​ (g) 添加点文件：touch t1.txt ​ (h) 制作 lv 的快照卷：lvcreate -L 200MB -s -n SNAP /dev/vg/lv ​ (i) 进入逻辑卷：cd /mnt/lvdev ​ (j) 新建大文件：dd if=/dev/zero of=loop count=1 bs=10M ​ (k) 浏览文件：ls ​ (l) 退出挂载点：cd / ​ (m) 卸载设备：umount /mnt/lvdev ​ (n) 快照卷恢复：lvconvert –merge /dev/vg/SNAP ​ (o) 挂载设备：mount /dev/vg/lv /mnt/lvdev ​ (p) 进入逻辑卷查看文件是否存在：cd /mnt/lvdev ​ ls]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 六、磁盘管理]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AD%E3%80%81%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[六、磁盘管理 磁盘基础知识 (1) 概念：使用一片或多片带有磁性的铝合金制的盘片构成的外部存储介质 (2) 物理结构 ​ A. 盘体 ​ B. 磁头 ​ C. 马达驱动 ​ D. 缓存 ​ E. SATA3接口 ​ F. 电路板 (3) 逻辑结构 ​ A. 磁道：同心圆 ​ B. 扇区 ​ C. 柱面 (4) 硬盘参数 ​ A. 容量：1-4TB ​ B. 转速：7200转/分 5400RPM ​ C. 缓存：64MB-256MB ​ D. 接口：SATA3 / SCSI (5) 分区 ​ A. 主分区：系统启动区 ​ B. 扩展分区 ​ C. 逻辑分区：基于扩展分区继续划分 分区模式 (1) MBR（主引导记录区模式） ​ A. 组成 ​ (a) MBR位于磁盘第0磁道第0柱面第1扇区 ​ (b) MBR总容量：446B ​ (c) 磁盘分区表（DPT）：64B ​ (d) 最后有2B（55 AA）为分区结束标志 ​ (e) MBR所占扇区为512B ​ B. 作用：MBR包含硬盘一系列参数和一段引导程序，引导程序是检查分区表是否正确并且在系统硬件完成自检后引导具有激活标志的分区上的操作系统（C盘），并将控制权交给启动程序 ​ C. MBR分区原则 ​ (a) 主分区+扩展分区最多4个 ​ (b) 扩展分区最多1个 ​ (c) 扩展分区基础上再次划分逻辑分区 ​ (d) 扩展分区不能格式化 ​ (e) 一般会划分3个主分区+1个扩展分区 ​ (f) 主分区（P） 扩展分区（E） 逻辑分区（L） ​ (g) 推荐剩余一些自由空间以方便分区空间扩容 (2) GPT ​ A. 产生原因 ​ (a) MBR分区格式最大支持2.2TB硬盘 ​ (b) 没有备份机制，若分区表损坏则会丢失整个硬盘内容 ​ (c) MBR存储空间较小，只有446B，无法存储叫多功能数据 ​ B. 方法 ​ (a) 使用LBA（逻辑地址区块）的结构存储分区信息 ​ (b) 共可分为68个LBA块，前34个LBA存储分区信息，后43个LBA块存储备份信息 ​ C. GPT分区格式不再区分主分区及扩展分区，共可分128个主分区 ​ D. GPT分区格式与MDR分区格式不兼容，不能混合使用 文件系统 (1) 意义：若空白硬盘相当于一张白纸，分区就是对其进行“裁切”，对分区进行方格划分就是对其进行建立文件系统，即格式化 (2) 常见文件系统格式：ext2 ext3 ext4 xfs msdos (3) ext2文件系统 ​ A. 组成： ​ (a) super block （超级块） ​ (b) inode （索引块） ​ (c) block （数据块） ​ B. 超级块：又称为硬盘地图，记录文件系统的整体信息，如：inode/block块的总量、使用量、空间块量、文件系统格式等相关信息 ​ C. inode块：记录文件属性，一个文件占用一个inode块，并且记录文件数据所在的block块的地址，默认为128B ​ D. block ：存储文件数据，大小为1KB 2KB 4KB，大文件会占用多个数据块 ​ E. 装入方式：将文件的数据块链式的不连续的装入硬盘中 ​ F. ext2文件系统支持 Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB ​ (4) Centos7系统默认文件系统为xfs ​ (5) df命令： ​ A. 格式：df 参数 目录/文件名 ​ B. 作用：列出文件系统的磁盘使用量 ​ C. 参数： ​ (a) -a ：列出所有文件系统 ​ (b) -h ：以容量理解的方式列出信息（GB MB KB） ​ D. 常见：df -ah ​ (6) du命令： ​ A. 格式：du -参数 文件或目录名 ​ B. 作用：查看文件或目录占用硬盘容量 ​ C. 参数： ​ (a) -a ：列出所有文件与目录信息 ​ (b) -h ：以容易理解的方式列出信息（GB MB KB） ​ (c) -s ：列出总量 ​ D. 注意：df命令检测速度较快 硬件设备命名原则 (1) 硬盘 ​ A. 以sd开头后跟a-p表示16块硬盘编号，即sd[a-p] ​ B. 在MBR分区格式中由于主分区+扩展分区最多4个，则编号为1-4，第一个逻辑分区从5开始编号，即使主分区编号未使用，逻辑分区也不能使用 ​ C. 硬盘名称格式：sd[a-p]数字 ​ D. 例：sda1 第一块硬盘的第1个主分区 ​ sdb5 第二块硬盘的第1个逻辑分区 ​ E. 例：PPELL ​ (a) P:sda1 ​ (b) P:sda2 ​ (c) E:sda3 ​ (d) L:sda5 ​ (e) L:sda6 ​ F. 模式： ​ (a) PE ​ (b) PPE ​ (c) PPPE ​ (d) PPPP (2) 光驱：/dev/sr0 (3) 鼠标：/dev/mouse (4) 打印机：/dev/lp[1-15] 添加新硬盘 (1) 方法：关闭系统-&gt;编辑虚拟机设置-&gt;添加-&gt;硬盘-&gt;磁盘类型：SCSI（推荐）-&gt;创建新的虚拟磁盘-&gt;磁盘大小：20GB，存储为单个文件-&gt;默认名称-&gt;完成 (2) 注意：添加的新硬盘必须在关机情况下进行，必须保证新硬盘文件名不能重名 硬盘分区 (1) 检测硬盘分区的类型 ​ A. 格式：parted 设备名 print ​ B. 例：parted /dev/sda print ​ C. 查看Prtition Table:msdos，分区表类型，若为msdos说明使用的为MBR分区格式，就不能使用GPT分区格式命令进行继续分区，否则已有数据会丢失 (2) fdisk分区 ​ A. 规划：规划分区个数、容量、类型 ​ B. 注意：fdisk为MBR分区格式命令 ​ C. 分区功能 ​ (a) n：新建分区 ​ (b) p：查看分区列表 ​ (c) d：删除分区 ​ (d) w：保存分区并退出 ​ (e) m：查看帮助 ​ (f) l ：查看可分区的类型 ​ D. 过程： ​ (a) 分析： ​ ◆ 目标：dev/sdc ​ ◆ 个数：3个分区 ​ ◆ 类型：2P 1E 1L ​ ◆ 容量：5G 5G 剩余 ​ (b)fdisk /dev/sdc ​ ◆ command ：输入分区命令为n（新建） ​ ◆ partition type ：分区类型，p（主分区），e（扩展分区），l（逻辑分区） ​ ◆ partition number ：分区编号，回车默认 ​ ◆ First Sector ：起始扇区编号，回车默认 ​ ◆ last sector ：终止扇区编号，输入：+5G，回车 ​ ◆ 剩余同上 ​ ◆ 输入p查看分区列表，输入w保存同步磁盘并退出 ​ E. 删除分区 ​ (a) 分区向导中输入d ​ (b) 正向新建分区，反向删除分区 ​ F. 注意：若无法查看分区结果列表，则表示分区信息还未写入内核（常见情况），输入“partprobe”命令进行手动将分区信息同步到内核，再不行就重启 ​ (2) lsblk命令 ​ A. 格式：lsblk -参数 /dev/sd? ​ B. 作用：查看磁盘分区信息 ​ (3) blkid命令 ​ A. 格式：blkid -参数 /dev/sd? ​ B. 作用：查看磁盘ID信息 ​ C. 常用：blkid ​ (4) gdisk分区 ​ A. 注意：对于同一硬盘，fdisk和gdisk不能混用 ​ B. 格式：gdisk /dev/sd? ​ C. 过程： ​ (a) gdisk /dev/sdd ​ (b) partition table scan ：扫描分区类型是否已存在 ​ (c) Command(? for help) ：新建（n） 删除（d） 查看列表（p） 保存（w） ​ (d) partirion number(1-128, default 1)：设置分区编号，回车即可 ​ (e) First sector：设置起始扇区值，默认，回车即可 ​ (f) Last sector：设置终止扇区值，输入分区容量，如：+5G ​ (g) Hex code or GUID(L to show code,Enter = 8300) ：设置分区文件系统的ID，回车即可 格式化 (1) 意义：对分区或其他设备建立文件系统 (2) 查看分区命令及类型：输入mkfs后2次tab键 (3) mkfs.xfs命令： ​ A. 格式：mkfs.xfs -参数 设备名 ​ B. 作用：对磁盘分区或文件进行xfs类型格式化 ​ C. 参数： ​ (a) -f ：强制格式化，已有文件系统需要使用此参数 ​ (b) -b ：后跟上block容量，范围512B-64KB，注意，Linux限制为4KB ​ D. 例：对/dev/sdc 进行xfs格式化 ​ mkfs.xfs /dev/sdc1 ​ mkfs.xfs /dev/sdc2 (4) mkfs.ext4命令： ​ A. 格式：mkfs.ext4 -参数 设备名 ​ B. 参数：-b ：设定block大小，如：1KB 2KB 3KB 4KB 挂载 (1) 意义：建立文件目录，通过设置该目录与分区的关系，以进入分区 (2) 挂载点：进入分区的目录称为挂载点 (3) 挂载前的注意事项 ​ A. 单一文件系统不应该被重复挂载在不同的挂载点（目录）中 ​ B. 单一目录不应该重复挂载多个文件系统 ​ C. 作为挂载点的目录，应为空目录，否则原有数据会隐藏 (4) mount目录 ​ A. 格式：mount -参数 设备名 挂载点目录 ​ B. 作用：将分区挂载挂载到指定文件目录上 ​ C. 参数： ​ (a) -a ：按照挂载配置文件/etc/fstab对未挂载的设备全部进行挂载 ​ (b) -t ：指定文件系统，不常用，一般系统会自动判断文件系统类型 ​ D. 例：建立挂载目录，挂载/dev/sdc的分区 ​ mkdir /mnt/m1 /mnt/m2 /mnt/m5 /mnt/m6 ​ mount /dev/sdc1 /mnt/m1 ​ mount /dev/sdc2 /mnt/m2 ​ mount /dev/sdc5 /mnt/m5 ​ mount /dev/sdc6 /mnt/m6 ​ E. 挂载光盘 ​ (a) 光盘名称：/dev/sr0 或 /dev/cdrom ​ (b) 方法：mount /dev//sr0 /media ​ (c) 注意：光盘为只读属性，只能以只读方式挂载 卸载 (1) mount命令： ​ A. 格式：umount -参数 设备名称或挂载点目录名 ​ B. 作用：卸载设备 ​ C. 参数： ​ (a) -f ：强制卸载 ​ (b) -l ：立刻卸载文件系统，比-f还强 ​ (c) -n ：不更新/etc/mtab情况下卸载 ​ D. 例：卸载/dev/sdc ​ umount /dev/sdc1 ​ umount /dev/sdc1 ​ umount /mnt/m5 ​ umount /mnt/m6 ​ E. 注意：卸载时应cd离开挂载点目录，否则文件系统忙，无法卸载 开机挂载 (1) 产生原因：手动挂载后系统重启会自动卸载，应设置开机挂载使其永久生效 (2) 配置文件：/etc/fstab (3) 配置文件分析 ​ A. 共6列 ​ B. 内容： ​ 设备名 挂载点目录 文件系统 defaults 0 0 ​ /dev/sdc1 /mnt/m1 xfs defaults 0 0 ​ C. defaults ：文件系统参数为默认 ​ D. 0 ：是否备份 ​ E. 0 ：开机是否用fsck进行扇区检查，但xfs文件系统不支持则为0 (4) fstab配置完毕后使用：mount -a 完成检测 再重启 (5) 使用lsblk命令查看是否开机挂载成功 (6) 注意： ​ A. 根目录/ 是必须挂载的，而且一定要先于其他mount point被挂载 ​ B. 其他mount point必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则（FHS） ​ C. 配置完毕后必须使用mount -a检测，否则系统启动失败 挂载大文件 (1) 产生原因：由于无自由分区空间，需要添加新分区时，可以对某个已存在的分区的剩余空间制作一个大文件，对其进行格式化挂载当做一个新的分区使用，从而实现不添加新的硬件而增加新分区 (2) 步骤：制作大文件-&gt;格式化-&gt;开机挂载 (3) 方法：例：对/dev/sdc6的剩余空间制作3G大文件进行挂载 ​ A. cd /mnt/m6 ​ B. df /mnt/m6 ​ C. dd if=dev/zero of=/mnt/m6/loopdisk bs=1G count=3 ​ （制作3G的大文件） ​ D. start /mnt/m6/loopdisk （查看文件属性） ​ E. mkfs.xfs -f loopdisk （格式化） ​ F. mkdir /mnt/loopdev （建立大文件挂载点目录） ​ G. mount -o loop /mnt/m6/loopdisk /mnt/loopdev ​ （挂载大文件，需要加 -o loop 参数） ​ H. 开机挂载设置 ​ (a) vim /etc/fstab ​ (b) 插入如下内容： ​ /mnt/m6/loopdisk /mnt/loopdev xfs defaults 0 0 ​ (c) 保存退出 ​ (d) mount -a （进行检测） ​ (e) reboot （重启） 增加swap交换分区 (1) 过程 ​ A. 成新划分一个分区 ​ B. 格式化分区 ​ C. 启用新的swap ​ D. 查看系统信息 ​ E. 开机挂载 (2) 例：对/dev/sdb 新建2G分区空间，对其格式化并生效为swap 空间 ​ A. fdisk /dev/sdb ​ B. mkswap /dev/sdb6 ​ C. swapon /dev/sdb6 ​ D. free -h ​ E. vim /etc/fstab ，输入以下内容： ​ /dev/sdb6 swap swap defaults 0 0 ​ F. mount -a ​ G. reboot （重启） ​ H. free -h （检测） 13.制作大文件生成swap ​ (1) 过程 ​ A. 查看分区 ​ B. 制作大文件 ​ C. 格式化 ​ D. 开机挂载 ​ E. 查看swap信息 ​ (2) 方法 ​ A. cd /mnt/m5 ​ B. dd if=/dev/zero of=swaploop bs=512MB count=1 ​ C. mkswap /mnt/m5/swaploop （格式化为虚拟内存） ​ D. swapon /mnt/m5/swaploop （生效） ​ E. vim /etc/fstab ，插入如下内容： ​ /mnt/m5/swaploop swap swap defaults 0 0 ​ F. mount -a ​ G. reboot]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 五、用户账户及权限]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%94%E3%80%81%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[三、用户账户及权限 用户账户及身份 (1) UUID值 ​ A. 作用：User Identification，系统为每一个账户都分配了一个 唯一的编号（身份证号），具有唯一性，账户的权限来源 于 UUID值 ​ B. 分类： ​ (a) 超级管理员root：0 ​ (b) 系统用户UUID：1-999，系统为每一个服务都分配一个账户，防止某个服务程序出现漏洞，从而被黑客提权至整个服务器，每个服务程序都由一个账户负责，控制破坏范围 ​ (c) 普通账户：从1000开始，由root创建，用于日常维护 ​ C. 特点： ​ (a) UUID值不能相同 ​ (b) 系统账户即使某些UUID值未使用，也不能分配给普通账户 ​ D. id命令： ​ (a) 作用：查看账户的UUID值 ​ (b) 格式：UUID 账户名 (2) 账户及工作组的创建 ​ A. 意义：为了方便管理数据，引入了系统-&gt;工作组-&gt;账户-&gt;权限的概念，相当于企业-&gt;部门-&gt;员工-&gt;权限 ​ B. useradd命令： ​ (a) 作用：创建账户 ​ (b) 格式：useradd -参数 账户名 ​ (c) 参数： ​ ◆ -d ：指定用户的家目录（默认为：/home/用户名称） ​ ◆ -e ：账户到期时间，格式为：YYYY-MM-DD ​ ◆ -u ：指定该用户账户的UID值 ​ ◆ -g ：指定一个初始的用户基本组（必须已存在） ​ ◆ -G ：指定一个或多个扩展用户组 ​ (d) 例： ​ useradd test3 -e 2019-7-15 -u 3000 -g test ​ （设置test3账户，到期时间为2019-7-15，指定该账户UID值为3000，指定用户基本组为test） ​ C. userdel命令： ​ (a) 作用：删除账户 ​ (b) 格式：userdel -参数 账户名 ​ (c) 参数 ​ ◆ -f ：强制删除 ​ ◆ -r ：同时删除账户及用户家目录 ​ D. groupadd命令： ​ (a) 作用：创建工作组 ​ (b) 格式：group -参数 工作组名称 ​ (c) 参数：-g ，指定工作组的gid编号 ​ E. groupdel命令： ​ (a) 作用：删除工作组 ​ (b) 格式：groupdel 工作组名 ​ (c) 注意：工作组中包含有账户时，不能删除，可以通过删除账户一并删除工作组 (3) 账户及工作组的修改 ​ A. usermod命令： ​ (a) 作用：修改账户信息参数 ​ (b) 格式：usermod -参数 账户名 ​ (c) 参数： ​ ◆ -u ：修改用户uid ​ ◆ –g ：变更用户组 ​ B. passwd命令： ​ (a) 作用：给账户设置密码 ​ (b) 格式：passwd -参数 账户名 ​ (c) 参数： ​ ◆ -l ：锁定用户，禁止登录 ​ ◆ -u ：解除锁定，允许用户登录 ​ ◆ -d ：允许用户可以用空格密码登录系统 ​ ◆ -e ：强制用户在下次登录时修改密码 文件权限及归属 （1）文件权限 ​ A. 可读：r ​ B. 可写：w ​ C. 可执行：x （2）目录权限 ​ A. 可读：r ，可以查看目录中的文件列表 ​ B. 可写：w ，可对目录中的文件进行操作 ​ C. 可执行：x ，可打开目录 （3）文件归属 ​ A. 所有者 ​ B. 所属组 ​ C. 其他用户 （4）文件权限数字化 ​ A. 数字组成：r（4） w（2） x（1） ​ B. 表示类别 ​ (a) rwx：完整权，7 ​ (b) rw- : 6 ​ (c) r-x : 5 ​ (d) r– : 4 ​ (e) -wx : 3 ​ (f) -w- : 2 ​ (g) –x ：1 ​ (h) — ： 0 ​ C. 例： ​ 764：rwxrw-r– 642: rw-r—w- 153 : –xr-x-wx ​ rwxrw-r– : 764 rw–w–wx : 623 rw-r–r– : 644 （5）执行ls -l （ll）显示信息意义 ​ 如：-rw-r–r–. 1 root root 1950 6 jun 13 01:00 initial-setup-ks.cfg ​ A. -rw-r–r–. ：普通文件（-） 权限（rw-r–r–） 开启SELinux(.) ​ B. 1 : 文件字节数 ​ C. root root： 所属账户 所属工作组 ​ D. 1950 ：文件占用容量 ​ E. 6 jun 13 01:00 ：文件修改时间 ​ F. initial-setup-ks.cfg：文件名 （6）chmod命令： ​ A. 作用：修改文件权限信息 ​ B. 格式：chmod 参数 权限 文件或目录名 ​ C. 例： chmod 777 h1.cfg （7）chown命令： ​ A. 作用：修改文件所属账户及工作组 ​ B. 格式：chown 参数 所有者：所属组 文件或目录名 ​ C. 例： chown mk1:mk1 h2.cfg 文件隐藏属性 （1）文件隐藏权限：文件拥有一般权限还拥有隐藏权限，当文件权限足够但无法删除时，考虑是否有隐藏权限 （2）chattr命令： ​ A. 作用：查看设置文件的隐藏权限 ​ B. 格式：chattr -参数 文件名 ​ C. 参数： ​ ◆ i: 无法修改文件（目录中不能新建和删除） ​ ◆ a: 仅允许追加内容，不可以覆盖、删除 ​ ◆ s: 文件变更后同步到硬盘 ​ ◆ S: 从硬盘中彻底删除，不可恢复（0填充文件所在存储区） （3）lsattr命令： ​ A. 作用：查看文件的隐藏权限属性 ​ B. 格式：lsattr -参数 文件名 ​ C. 例： ​ touch h3.cfg ​ chattr +a h3.cfg （+a 增加a隐藏权限） ​ rm -f h3.cfg （无法删除） ​ lsattr h3.cfg ​ chattr -a h3.cfg （-a 去掉a隐藏权限） ​ rm -f h3.cfg 账户切换 (1) 切换原则 ​ A. Root账户可任意切换到其他普通账户，不需要密码 ​ B. 普通账户切换到root账户必须输入密码 ​ C. 账户切换并不是注销，只是同时登录 (2) su命令： ​ A. 格式：su -参数 账户名 ​ B. 作用： 切换账户 ​ C. 常用： su - 账户名，减号表示创建新的环境变量信息 ​ D. 注意：尽量减少使用su命令，因为可能暴露root密码 (3) sudo命令： ​ A. 作用：临时赋予普通账户权限，完成原本root完成的任务 ​ B. 格式：sudo -参数 命令名称 ​ C 参数： ​ ◆ -h: 列出帮助信息 ​ ◆ -l : 列出当前用户可执行命令 ​ ◆ -u (用户名UID值)：使用指定的用户身份执行命令 ​ ◆ -k: 清空密码的有效时间，下次执行sudo时需要再次密码验证 ​ D. sudo功能总结 ​ ◆ 限制用户执行指定的命令 ​ ◆ 记录用户执行的每一条命令 ​ ◆ 验证密码后5分钟内不需再次输入密码 ​ ◆ Sudo必须通过编译配置文件才能使用：visudo ​ E. 赋予普通账户临时权限 ​ ◆ useradd fox 新建账户 ​ ◆ passwd fox 设置密码 ​ ◆ su - fox 切换账户 ​ ◆ cd /root ​ ◆ su - root ​ ◆ visudo ​ ◆ 点击shfit + : 后输入set nu 查看行号 ​ ◆ 定位第98行 ​ ◆ 点击i键添加 fox ALL=(ALL) ALL ​ （谁可以使用 允许使用的主机=（以谁的身份） 可以执行的命令列表） ​ ◆ 点击shfit +: 输入wq保存退出 ​ ◆ su - fox ​ ◆ sudo cd /root ​ ◆ 输入fox账户密码 ​ ◆ sudo cat /etc/passwd 完美执行]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 四、文件系统命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[四、文件系统命令 FHS (1) FHS：Linux文件系统层次化标准 (2) 拓扑：倒置树型，一切数据从/根目录开始 (3) 常见一级目录作用 ​ A. root：管理员的家目录 ​ B. etc：配置文件目录 ​ C. dev：设备文件目录 ​ D. mnt：挂载设备的默认目录 ​ E. media：挂载光盘镜像的默认目录 ​ F. bin：常用命令的程序存储目录 ​ G. tmp：临时目录或共享目录 ​ H. var：日志文件存储默认目录 ​ I. boot：系统启动文件目录 (4) 注意： ​ A. FHS不具有强制性约束，但应遵循次行业规则，否则存储混乱 ​ B. 所有目录注意区分大小写（默认小写） 增、删、改命令 (1) touch命令： ​ A. 作用：新建文件 ​ B. 格式：touch -参数 文件名 ​ C. 例： 新建文本文档：touch -t1.txt ​ touch k1.txt k2.sh k3.cfg ​ D. 注意：vim 文件名 ，此文件若不存在则会新建 (2) mkdir命令： ​ A. 作用：新建目录 ​ B. 格式：mkdir -参数 目录名称 ​ C. 参数 ​ (a) -p ：创建递归目录（多级目录），用ls命令查看 ​ (b) -m ：为新建目录增加权限 ​ (c) 练习：用上面的命令建一个目录，安装tree小工具：yum install tree -y ，然后cd /test检查树型目录的正确性 ​ (d) rpm -q gcc查看gcc是不是安装成功 (3) 利用touch命令创建c源文件编译并执行 ​ touch test.c ​ vim test.c ​ 点击i键输入代码, ​ Include &lt;stdio.h&gt; ​ Int main(void) ​ { ​ Int i,j; ​ For(i=1;i&lt;10;i++) ​ Printf(“%d\t”,i); ​ Printf(“\n”); ​ For(int i=1;i&lt;66;i++) ​ Printf(“-”); ​ } ​ 点击ESC键 ​ 点击shift+:后输入wq保存并退出 ​ 编译: gcc test.c（即源文件名） ​ 看结果：../a.out (4) rm命令： ​ A. 格式：rm -参数 文件名 ​ B. 作用：删除文件或目录 ​ C. 参数： ​ (a) -r ：删除目录 ​ (b) -f ：删除不确认，即强制删除 ​ (c) 例：cd ~ （回到家目录） ​ 输入ls查看 ​ 输入y确认删除 ​ 输入ls查看 ​ rm -f t1.txt t2.cfg（删除） (5) cp命令： ​ A. 作用：拷贝文件或目录 ​ B. 格式：cp -参数 源文件 目标文件 ​ C. 参数： ​ (a) -p ：保留源文件的原始属性 ​ (b) -r ：递归拷贝 ​ (c) -i ：目标文件已存在，提示是否覆盖 ​ (d) 例：cp /root/m1.txt /home （/root等价于~） (6) mv命令： ​ A. 作用：移动文件或改名 ​ B. 格式：mv -参数 源文件或目录 目标文件或目录 ​ C. 例：mv m2.txt t1/m1.txt 表示将m2移到t1中并改名为m1 ​ D. 结论： ​ (a) 若源类型和目标类型都是文件或目录，则为重命名 ​ (b) 若源类型为文件，目标类型为目录，则为剪切移动 ​ E. 例：创建一个myDocument目录和一个Document文件，将Document文件移动到myDocument目录下，最后修改myDucument目录为test ​ mkdir myDocument （创建目录） touch Document （创建文件） mv Document myDocument （移动）​ cd myDocument （进入到myDocument目录下） ​ ls （查看） ​ mv Document test （改名） ​ ls (7) dd命令： ​ A. 格式：dd if=/dev/zero of=新文件名 bs=块大小 count=块个数 ​ B. 作用：制作生成指定容量，内容为全数字0的大文件 ​ C. 例： cd / ​ dd if=/dev/zero of=kong.txt bs=50MB count=2 ​ stat kong.txt （相当于属性，有容量了） ​ 再来一个：dd if=/dev/zero of=loop.cfg bs=1G count=5 ​ D. /dev/zero ：是一个特殊的设备文件，可以输出无穷个数字0，其本身又不占空间，用于制作大文件来覆盖旧文件，防止恶意恢复，也可以制作大文件来作为分区使用 ​ E. 例：dd if=/dev/zero of=kong.txt bs=10MB count=5 ​ （制作50MB的大文件） ​ 做完后删除：rm -f kong.txt 文件属性查看命令 (1) file命令： ​ A. 格式：file -参数 文件名 ​ B. 作用：查看文件类别 ​ C. 类型： ​ (a) empty ：空文件 ​ (b) ASCLL text ：ASCLL码文件（文本） ​ (c) directory ：目录文件 ​ (d) block special ：块设备文件（高速设备） ​ (e) character special ：字符设备文件（低速设备） ​ (f) symbolic link ：链接文件（快捷方式） ​ (g) socket ：接口文件 (2) cat命令： ​ A. 格式：cat -参数 文件名 ​ B. 作用：输出文件内容到设备上（默认为显示器） ​ C. 参数： ​ (a) -b ：文件中所否非空行增加行号，从1开始编号 ​ (b) -n ：文件中所有行增加行号 ​ (c) 例： touch k1.txt ​ echo “hello” &gt; k1.txt ​ cat k1.txt ​ touch k2.txt ​ echo “world” &gt; k2.txt ​ cat k2.txt ​ touch k3.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ cat k3.txt ​ D. 特殊功能： ​ (a) 文件内容合并： ​ touch k1.txt k2.txt k3.txt ​ echo “hello” &gt; k1.txt ​ eEcho “world” &gt; k2.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ （查看两个文件内容输出到新文件中） ​ cat k3.txt ​ (b) 倒序查看内容：tac 文件名 ​ E. 注意：由于无翻页功能，适用于内容较少的文本文件查看 (3) more命令： ​ A. 格式： more 文件名 ​ B. 作用：可翻页查看文件内容 ​ C. 方法： ​ (a) 空格：翻页查看 ​ (b) 回车：每行查看 ​ (c) q ：退出 (4) less命令： ​ A. 同more命令 ​ B. 点击j键下一行，k键上一行 (5) head命令： ​ A. 格式：head -参数 文件名 ​ B. 作用：查看文件的前几行内容 ​ C. 参数：-n 行数 ​ D. 例：head -n 5 /etc/passwd （前5行） (6) tail命令： ​ A. 格式：tail -参数 文件名 ​ B. 作用：查看文件后几行或持续刷新内容 ​ C. 例：head -n 5 /etc/passwd （后5行） ​ head -f /etc/passwd （动态刷新内容） (7) wc命令： ​ A. 格式：wc -参数 文件名 ​ B. 作用：统计文件的单词书、行数、容量 (8) stat命令： ​ A. 格式：stat -参数 文件名 ​ B. 作用：查看文件属性 ​ C. 属性： ​ (a) access ：最近访问时间 ​ (b) modify ：最近更改时间 ​ (c) change ：最近改动时间 文件查询命令： (1) find命令： ​ A. 作用：按照文件名、类型、属性等参数检索文件 ​ B. 格式：find 查找路径 查找条件 操作 ​ C. 查找路径：一般为绝对路径 ​ D. 查找条件： ​ (a) -name 文件名 ：按照文件名检索 ​ (b) -user 账户名 ：按照拥有者检索 ​ (c) -group 工作组 ：按照工作组归属检索 ​ (d) –type b/d/c/l ：按照文件类型检索 ​ (e) –size +50k （-50k）:按照大于（小于）50k容量检索 ​ (f) -newer f1 ! f2 ：匹配比文件f1新却比f2旧的文件 ​ (g) 通配符： ​ ◆ * ：任意内容、任意个数 ​ ◆ ? ：任意内容、1个字符 ​ (h) 并且： -a 或： -o 不是（取反）： -not ​ E. 例：find / -name host ​ find /etc -name a. （a开头文件） ​ find / -name ?b. （第二个字母为b的文件） ​ find / -name *.cfg （检索所有的日志文件） ​ find / -user YLX（普通账户YLX的所有文件，如 果不知道就cat /etc/passwd） ​ find /dev -type b （检索块设备文件） ​ find ~ -size -10k （检索小于10k的文件） ​ find / -type b | wc （统计块设备文件个数） ​ find / -name *.c &gt; f.txt （检索c类型文件并 备份到f文件中） ​ 自己查：ip地址 IP ​ 子网掩码 NETMASK ​ 网关地址 GATEWAY ​ 域名解析 DNS （正向/反向） ​ 超文本传输控制协议 （HTTP/HTTPS） (2) grep命令： ​ A. 格式：grep -参数 查找条件 文件名 ​ B. 作用：在文件中按照条件检索内容 ​ C. 参数 ​ (a) -n ：显示符合要求的行的行号 ​ (b) -v ：显示不符合要求的行 ​ (c) -i ：忽略字母的大小写 ​ (d) -c ：显示符合要求的行数 ​ (e) -A数字 ：如-A2表示显示符合要求的行及下面2行 ​ (f) -B数字 ：如-B5表示显示符合要求的行及上面5行 ​ (g) -C数字 ：如-C3表示显示符合要求的行及上下各3行 D. 例： ​ (a) grep -n “root” /etc/passwd 检索包含root ​ (b) Grep -n “/sbin/nologin” /etc/passwd ​ （不允许登陆的账户信息） ​ (c) grep -nv “/sbin/nologin” /etc/passwd ​ （允许登录的账户信息） ​ (d) grep -nA3 “ftp” /etc/passed ​ （检索包含ftp的行及下面3行） ​ (e) Grep -n “halt” /etc/passwd &gt; grep1.txt ​ （使用文件保存检索结果） E.正则表达式 ​ (a) 作用：用于按照指定条件过滤大量文本，是一种表示条 件的规则和方法 ​ (b) 正则与通配符的区别 ​ ◆ 通配符：按照文件名进行检索，一般多数命令都支持 ​ ◆ 正则：在文本中过滤字符串，一般多数语言、脚本等 程序都支持 ​ (c)按照 [ ] 字符集进行过滤 ​ ◆ [ab] ：表示检索包含a或者包含b的信息，括号中 多个内容只表示一个信息 ​ grep -n [dD] /etc/passwd 过滤包含d或D ​ grep -n [oo] /etc/passwd 过滤包含o ​ ◆ [^] ：表示反色显示不包含条件的内容 ​ grep -n [^r] /etc/passwd 反色显示不包含r的字 符串 ​ grep -n [^r]oo /etc/passwd 过滤不以r开头且包 含oo的行 ​ ◆ [0-9] ：表示过滤包含数字的内容 ​ grep -n [0-9] /etc/passwd 过滤包含数字的内容 ​ -grep -n [^7-9] /etc/passwd 反色显示不包含7-9 的内容 ​ ◆ [a-z] [A-Z] [a-zA-Z] ：表示过滤小写字母、大写字 母、字母 ​ grep -n [A-Z] /etc/passwd 过滤包含大写字母的内 容 ​ ◆ 注意：字符集：[] [^] [-] 区别 ​ (d) 过滤行首或行尾 ​ ◆ ^ ：过滤行首以谁开头的内容 ​ grep -n ^n /etc/passwd 过滤行首以n开头的内容 ​ grep -n ^[A-Z] /etc/passwd 过滤行首以大写字母 开头的内容 ​ ◆ $ ：过滤行尾以谁结尾的内容 ​ grep -n $”]” /etc/sos.conf ​ （注意：[]表示字符集，若想表示中括号的作用，必须使用””进行转义） ​ grep -n $”[0-9] /etc/sos.conf” 以数字结尾的内容 ​ ◆ 检索空白行：grep -n ^$ /etc/sos.conf (e) 正则表达式的通配符 ​ ◆ 一个任意字符： . ​ ◆ 重复前面0个或多个任意字符： * ​ ◆ 例： ​ grep -n r..t /etc/passwd 检索以r开头t结尾中 间有两个任意字符的字符串 ​ grep -n o* /etc/passwd 检索不包含或包含o 的内容 ​ grep -n oo* /etc/passwd 检索至少包含o的内 容 ​ grep -n ooo* /etc/passwd 检索至少包含oo的 内容 ​ ◆ 注意： .*表示所有内容 (f) 转义字符及区间字符 ​ ◆ \ ：转义字符，即去掉其后字符附加功能，恢复到 本身功能 ​ grep -n ]$ /etc/sos.conf ​ ◆ 区间字符：{n1,n2}，表示重复n1到n2次前面字 符，n1&lt;n2 ，n2可以省略，{n1}表示大于等于n1次 ​ （注意：{}必须使用\进行转义） ​ grep -n o”{2}” /etc/passwd 检索至少包含两个o 的内容 (3) tr命令： ​ A. 作用：替换文本文件中的字符 ​ B. 格式：tr 原始字符 结果字符 ​ C. 例：cat /etc/passwd | tr [a-z] [A-Z] ​ （显示passwd内容并将其小写字母改为大写） ​ cat /etc/sos.conf | tr # % ​ （#和%需要转义） ​ D. 注意：tr命令一般不直接使用，即不推荐直接更改文件内 容，应显示文件内容并更改 打包压缩命令 (1) 作用：打包、压缩、解压缩文件 (2) 常用格式： ​ A. .tar ：由tar打包程序打包的文件（无压缩功能） ​ B. .tar.gz ：先由tar打包，再由gzip压缩 (3) 格式：tar -参数 压缩文件名 被打包压缩的文件 (4) 参数： ​ A. 打包压缩： ​ (a) -c ：压缩 ​ (b) -z ：使用gzip进行压缩 ​ (c) -v ：显示过程 ​ (d) -f ：目标文件名 ​ (e) 常用：-czvf ​ B. 解压缩 ​ (a) -x ：解压缩 ​ (b) 常用：-xzvf (5) 例：打包压缩/root目录后解压缩（备份） ​ A. cd ~ ​ B. tar -czvf t1.tar.gz /root ​ C. cd / ​ D. mkdir t2 ​ E. cd t2 ​ F. tar -xzvf /root/t1.tar.gz ​ G. ls (6) 注意： ​ A. 压缩文件使用“红色”表示 ​ B. -c与-x不能同时使用 管道符与重定向命令 (1) 输入输出重定向 ​ A. 作用：将默认的输入输出端进行改变 ​ B. 符号： ​ (a) &gt; ：输出重定向，将输出内容重定向到文件 ​ (b) &gt;&gt; ：输出重定向，追加输出 ​ C. 重定向保存错误提示： ​ (a) 格式：命令 2&gt;文件名 ​ (b) 例：ls -l temp 2&gt;err.txt (2) 管道符 ​ A. 格式：命令1 | 命令2 | 命令3…… ​ B. 作用：将前一个命令的结果作为后一个命令的数据源 ​ C. 例：统计包含root的行数 ​ grep “root” /etc/passwd | wc 常见的环境变量 (1) 环境变量 ​ A. 作用：表示bash命令解释器的命令程序存储路径 ​ B. 显示：echo $PATH ​ C. 命令程序：/usr/bin ​ (2) 常见变量 ​ A. HOME：用户的家目录 ​ B. SHELL：SHELL程序目录 ​ C. HISTSIZE：历史命令记录条数 ​ D. PATH：执行文件的默认路径 ​ E. MAIL：邮箱文件存储路径 ​ (3) 注意：使用$运算符显示变量的值 常见Linux文件类型 (1) 普通文件： ​ A. 文本文件：存储ASCLL ​ B. 二进制文件 ​ C. 注意：代号为-，白色 (2) 目录： ​ A. 作用：相当于Windows中的“文件夹” ​ B. 注意：代号为d，蓝色 (3) 链接文件： ​ A. 作用：相当于Windows的“快捷方式”，是一种指向式文件 ​ B. 注意：代号l，绿色 (4) 设备文件： ​ A. 作用：Linux中一切数据皆文件，设备也是一种文件，可编辑 ​ B. 注意：代号（b c 等），黄色]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 三、常用Linux命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令提示符的意义 （1）[root@localhost ~] ​ A. root:表示当前登录账户名称 ​ B. @：表示分隔符 ​ C. localhost：表示主机名 ​ D. ：表示此位置是当前工作路径，相当于/root （2）#：表示以root账户登录，$：表示以普通用户登录 常见命令 （1）命令书写格式：命令名称 + 空格 + 参数 + 空格 + 目标 （2）参数： ​ A.长格式（全称）：–参数 ​ B.短格式：-参数 ​ C.例：man –help ​ man -h （3）目录查看命令 A.格式：pwd B.作用：查看当前工作目录的绝对路径（4）目录切换命令： A.格式：cd 路径 B.作用：切换工作目录 C.路径：​ (a) 绝对路径：从/开始向下遍历 ​ (b) 相对路径：从当前工作目录开始向下遍历（不包含当前工作目录） ​ D.特殊路径 (a) cd / ：切换根目录 (b) cd .. ：返回上级目录 (c) cd ~ ：切换root家目录 (d) cd /root：同上 (e) cd /home/普通账户名 ：切换普通账户的家目录（5）目录浏览命令： A.格式：ls -参数 B.作用：查看目录中的内容 C.参数：​ (a) -a ：查看隐藏文件（以点开头的为隐藏文件） ​ (b) -l ：查看目录中的详细信息 ​ (c) -d ：查看当前目录 D.注意：​ (a) 翻页查看：ls | more ​ (b) 查看目录内的详细信息（等同于ll命令）：ls -l ​ (c) 查看当前目录的详细信息：ls -dl E. ls命令查看的颜色意义：​ (a) 白色：表示普通文件 ​ (b) 蓝色：表示目录 ​ (c) 红色：压缩文件 ​ (d) 黄色：设备文件 ​ (e) 绿色：链接文件 ​ 演示： cd /dev ​ cd / ​ Ls （6）date命令： ​ A. 格式：date [选项] [“+显示时间格式”] ​ B. 注意：按照指定格式显示日期时间 ​ C. 参数： ​ (a) -s ：设定系统的日期时间 ​ (b) -d ：显示指定描述的日期时间（几天前/后） ​ D. 日期格式： ​ (a) %Y ：显示完整的年份 ​ (b) %m ：显示月份 ​ (c) %d ：显示日（1-31） ​ (d) %a ：星期几 ​ (e) %j ：一年中的第几天（1-366） ​ (f) 例：显示年月日：date “+%Y-%m-%d” ​ date “+%j” （数字越大，文件越新） ​ date “+%Y-%m-%d %a” ​ E. 时间格式： ​ (a) %H ：小时（00-23） ​ (b) %M ：分钟（00-59） ​ (c) %S ：秒（00-60） ​ (d) %t ：相当于tab键（4个空格） ​ (e) 例：date “+%H:%M:%S” ​ date “+%Y-%m-%d%t%H:%M:%S” ​ F. 其它： ​ (a) %p ：显示本地AM或PM（上午或下午） ​ (b) %Z ：显示时区 ​ (c) %j ：一般用于备份文件或日志文件，增加此参数，数字越大，文件越新 ​ G. date -s “2020-9-5 18:35:40” 设置系统新的日期时间 ​ H. date -d “+2 day” “+Y-%m-%d” 设置系统的日期为2天后 （减号为几天以前） （7）cal命令： ​ A. 格式： cal -参数 ​ B. 作用：显示日历 ​ C. 例： ​ (a) cal 显示本月 ​ (b) cal -2019 显示全年的日历 （8）echo命令： ​ A. 格式：echo -参数 ​ B. 作用：将字符串输出到屏幕或文件中，显示变量的值 ​ C. 例：echo “HELLO” ​ echo “hello” &gt; 文件名 （9）history命令： ​ A. 格式：history -参数 ​ B. 作用：显示命令历史记录 ​ C. 配置文件：/etc/profile ​ D. 默认记录1000条历史命令 ​ E. 修改历史命令记录条数： ​ (a) vim /etc/profile ​ (b) HISTSIZE=1000 将1000改为指定数字 ​ (c) reboot 重启 ​ F. 清空历史命令记录：history -c 系统检测命令 （1）ps命令： ​ A.格式：ps -参数 ​ B.作用：显示进程的参数 ​ C.参数： ​ (a) -a：显示所有进程 ​ (b) -u：用户及其他详细信息 ​ (c) -x：显示没有控制终端的进程 ​ D.常用：ps -au ​ E.注意：只要关注%CPU（cpu占用率）及%MEM（内存使用率） （2）top命令： ​ A.作用：动态检测系统的活动与负载，相当于强化版的“任务管理器” ​ B.top命令显示的表头解释： ​ (a) 第一行： ​ ◆ 系统时间 ​ ◆ 运行时间 ​ ◆ 登录的终端数 ​ ◆ 系统负载：1分、5分、15分钟平均值（三个值越小，系统负载越低） ​ (c) 第二行：进程总数、运行进程数、睡眠数、停止数、僵死数 ​ (d) 第三行： ​ ◆ 用户资源占用百分比 ​ ◆ 系统内核占用资源百分比 ​ ◆ 改变过优先级的进程资源百分比 ​ ◆ 空闲的资源百分比等 ​ (e) 第四行： ​ ◆ 物理内存总量 ​ ◆ 内存使用量 ​ ◆ 内存空闲量 ​ ◆ 作为内核缓存的内存量 ​ (f) 第五行： ​ ◆ 虚拟内存量 ​ ◆ 虚拟内存使用量 ​ ◆ 虚拟内存空闲量 ​ ◆ 已被提前加载的内存量 ​ D. 点击q键退出 （3）ifconfig命令： ​ A.作用：查看本机网卡信息 ​ B.信息： ​ (a) ens32为本机物理网卡 ​ (b) inet：本机IP ​ (c) netmask：本机子网掩码 ​ (d) RX：发送数据包个数 ​ (e) TX：接收数据包个数 （4）uname命令： ​ A.格式：uname -a ​ B.作用：显示系统的版本信息 （5）free命令： ​ A.格式：free -h ​ B.作用：显示内存及虚拟内存的容量、剩余量等信息 （6）who命令： ​ A.作用：显示系统登录信息 ​ B.信息： ​ (a) 账户 ​ (b) 方式 ​ ◆ :0 表示图形化界面 ​ ◆ tty2 命令行界面 ​ ◆ pts/0 远程登录界面 ​ (c） 日期时间 （7）last命令：显示系统登录或退出的详细信息，是强化版的who]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 二、Linux的安装与部署]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%8C%E3%80%81Linux%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[二、Linux的安装与部署 VMware虚拟机的安装 (1) .增强型键盘驱动需要打勾 (2) .虚拟机的新建及设置 ​ A. 稍后安装操作系统 ​ B. 选择客户机系统：centos7 64 位，其目的是匹配系统，选择更适合的VMware tools 工具包 ​ C. 命名虚拟机 ​ (a).虚拟机名称：默认 ​ (b).放在非C盘路径，与其他虚拟机名称要有区别 ​ D. 磁盘容量 ​ (a).大小：20GB，动态分配，使用多少分配多少，最大为20GB ​ (b).将虚拟磁盘文件存储为单个文件：存储速度快，不易于迁移 ​ (c).将虚拟磁盘存储为多个文件：存储速度相对较慢，利于虚拟机迁移 ​ E. 自定义硬件 ​ (a).内存：1：4关系，1G虚拟机内存对应4G物理内存 ​ (b).CPU：1颗，4核 ​ (c).新CD/DVD：点击“选择ISO镜像文件”选项，点击“浏览”，设置下载的镜像文件路径 ​ (d).网络适配器： ​ ◆ 桥接模式：将物理机网卡当作桥梁，建立虚拟机与互联网的连接关系，适用于不频繁变动的网络 ​ ◆ NAT模式：（NAT：网络地址转换器）将物理当作路由器，通过“路由器”建立网络连接，适用于经常变换网络环境的情况下使用（VMnet 8） ​ ◆ 仅主机模式：仅当前虚拟机与物理机连接，无法连接互联网（VMnet 1） ​ (e).移除不必要的设备：USB、声卡、打印机设备 (3).虚拟机的功能配置 ​ A.虚拟机移除 ​ (a).虚拟机左侧“库”侧边栏中选中虚拟机文件，单右，移除 ​ (b).定位虚拟机在Windows中的存储位置，选中文件夹删除 ​ B.快照制作 ​ (a).作用：将系统状态参数等信息冻结保存为镜像，以便于系统崩溃后进行恢复 ​ (b).方法：虚拟机菜单-&gt;快照-&gt;拍摄快照（注意左下角进度比率） ​ C.虚拟网络编辑器 ​ (a).作用：显示及配置网卡的地址参数 ​ (b).方法：编辑菜单-&gt;虚拟网络编辑器 ​ (c).注意：右下侧是否有黄色感叹号三角，若有说明虚拟机没有以管理员权限打开 Linux系统部署 （1）软件选择：带有GUI的服务器 （2）安装位置（分区）： ​ A. 我要配置分区-&gt;完成-&gt;点击“+”添加分区-&gt;设置挂载点及期望容量-&gt;完成-&gt;接受更改 ​ B. 分区原则（最少三个分区）： ​ (a) . /boot：系统启动分区，400MB ​ (b) swap：交换分区（虚拟内存），4GB ​ (c) /：根分区，剩余容量（不填） （3）关闭KDUMP（内存崩溃保护机制）以节省内存 ​ A. 设置root高级管理员密码，设置普通账户名（大写）及密码 ​ B. 初次进入系统的设置 ​ a.登录：点击“未列出”-&gt;root-&gt;密码:123456 ​ b.系统自带的六个终端 ​ ◆ 方法：ctrl+alt+F1~F6 ​ ◆ F1对应图形化界面 ​ ◆ F2~F6对应5个命令行界面 ​ c.清屏 ​ ◆ ctrl+l ​ ◆ 命令：clear ​ d.查看本机IP地址：ip addr（查看ens33） ​ e.配置网卡： ​ (a)cd /etc/sysconfig/network-scripts ​ (b)vim ifcfg-ens32 ​ (c)点击键盘i键，进入编辑状态，定位ONBOOT=no，将no删除编为yes ​ (d)点击esc键 ​ (e)点击shift+: ​ (f)输入wq后保存退出 ​ (g)重启网卡：service network restart ​ (h)检测：ping www.baidu.com ​ (i) ctrl+c 终止ping操作 ​ f.快照制作：虚拟机-&gt;快照-&gt;拍摄快照-&gt;命名（见名知意） （4）远程登录putty的使用： ​ A. Hosts name（or IP address）：输入Linux的IP地址 ​ B. Saved sessions：输入新名称后点击save ​ C. 点击open ​ D. Login as：输入root ​ E. 输入密码 ​ F. 字体、字号调整：定位标题栏-&gt;单击右键-&gt;change settings-&gt;Appearance-&gt;点击右键“change”按钮-&gt;设置 “粗体”，18号-&gt;确定-&gt;Apply 系统YUM源的配置 （1）yum配置文件目录：cd /etc/yum.repos.d （配置文件扩展名为.repo） （2）替换yum源： ​ A. 删除自带yum配置文件： cd /etc ​ rm -rf yum.repos.d （删除目录） ​ mkdir yum.repos.d （新建同名目录） ​ cd yum.repos.d （进入目录） ​ B. 下载网易yum配置文件：http://mirrors.163.com/.help/CentOS7-Base-163.repo cd /etc/yum.repos.d wget &lt;http://mirrors.163.com/.help/CentOS7-Base-163.repo&gt;（3） 建立新的yum缓存 ​ yum clean all （清理旧yum缓存） ​ yum makecache （新建缓存） （4）更新系统yum update kernel （5）更新所有软件：yum update 第二种方法（不用yum）,cmatrix实例的安装： （1) wget http://archive.ubunntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orug.tar.gz (下载软件) （2）Tar xvf cmatrix_1.2a.orig.tar.gz (解压缩) （3）Cd cmatrix-1.2a (进入解压缩后的目录) （4） yum install ncurses-devel (安装依赖软件) （5）yum install gcc -y ( 安装依赖软件) （6） ./configure &amp;&amp; make &amp;&amp; make install (编译安装) （7）任意目录下输入：cmatrix （按Q退出） 修改root账户密码 （1）重启：reboot （2）内核选择界面点击上下键，使其停留在该界面 （3）点击键盘 e 键 （4）定位Linux16所在行，找到ro后删除，同位置添加 ​ rw init=/sysroot/bin/bash （5）点击 ctrl+x （6）输入： hroot /sysroot （7）输入:passwd （8）输入2次新密码 （9）输入 touch /.authorelabel （10）点击键盘ctrl+d （11）输入reboot重启 关机重启 （1）重启： reboot 或shutdown -i now （2）关机 : shutdown now 或 halt 14.常用的快捷键 ​ （1）清屏 ctrl+l ​ （2）终止命令 ctrl+c ​ （3）单词补全 tab ​ （4）调出历史命令 : 键盘上下键 ​ （5）终止进程：ctrl+z]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 一、Linux环境简介]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%80%E3%80%81Linux%E7%8E%AF%E5%A2%83%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、Linux环境简介 说明： VMware 14密钥 ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 ZC5XK-A6EOM-080XQ-04ZZG-YF08D 网易开源镜像（http://mirrors.163.com） 阿里开源镜像（https://opsx.alibaba.com/mirror） 熟练掌握常见命令（80个左右） 熟练掌握软件包安装 （初级阶段） 熟练掌握系统结构和运行原理 熟练搭建各种常见服务器 熟悉网络安全并能配置服务器安全策略 （中级阶段） 熟悉掌握Linux下磁盘存储管理、用户权限管理、内存管理、文件系统管理、进程管理等 熟悉掌握系统故障排查方法并进行调优 Linux系统的构成 (1) .Linux本质是一个内核（kernel） (2) .Linux发行套件：将kernel与辅助软件、工具软件、文件系统等组成一个大型软件包，从而形成Linux发行套件 Linux发行版本介绍 (1) .RHEL：红帽企业版，具有完整的Linux功能，企业首选 (2) .Centos：社区企业操作系统，是RHEL免费版，学习首选 (3) .Ubuntu：乌班图，是Linux桌面版操作系统 Linux发行套件的版本构成 (1) .DVD版本：以标准DVD容量（4.8G）进行发行的商业版本，具有基本组件（常用） (2) .Everything版本：完整版，具有全部功能组件，10G容量 (3) .Minimal版本：最小化安装版（920MB），具有操作系统最小功能 (4) .Netinstall版本：网络安装版，批量化LAN安装 (5) .X86_64：使用平台为64系统]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端form表单]]></title>
    <url>%2F2019%2F07%2F14%2FWEB%E5%89%8D%E7%AB%AFform%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[input属性 name：名字，类似id，可以用js取值和分类，后台用的较多 value：表单提交项的值(不同类型的input，value的作用也不尽相同) placeholder(文本类)：文本输入提示(css3新增属性，用来提示文本输入) checked(选择类)：页面加载时默认选定的 input 元素 readonly(文本类)：只读的文本输入元素 disabled：规定禁用的 input 元素 type：input的种类 文本类：text——文本框；password——密码 选择类：radio——单选；checkbox——复选 按钮类：submit/image——提交/图片提交；reset——重置；button——按钮 特殊类：file——上传 有点懵…不要着急，让我一个个举例~ 文本类 1234567&lt;!-- 后台数据库通过name值找到value（值） --&gt;&lt;!-- 可输入的文本框 --&gt;&lt;input type="text" value="我是值" name="user" /&gt;&lt;!-- 密码文本框 --&gt;&lt;input type="password" placeholder="密码" name="password" /&gt;&lt;!-- 只读不可输入的文本框 --&gt;&lt;input type="text" value="我是只读的" readonly /&gt; 选择类 单选框 123&lt;!-- 设置name="sex"使单选框生效，不能多选 checked表示默认选项 --&gt;&lt;input type="radio" name="sex" checked /&gt;男&lt;input type="radio" name="sex" /&gt;女 多选框 123&lt;input type="checkbox" name="hobby" /&gt;足球&lt;input type="checkbox" name="hobby" /&gt;篮球&lt;input type="checkbox" name="hobby" /&gt;羽毛球 按钮类 123456&lt;!-- 提交按钮 --&gt;&lt;input type="submit" /&gt;&lt;!-- 按钮 --&gt;&lt;input type="button" value="→" disabled /&gt;&lt;!-- 重置 --&gt;&lt;input type="reset" /&gt; 特殊类 12 &lt;!-- 上传文件 --&gt;&lt;input type="file" /&gt; 表单元素的专用伪类选择器：focus—-获得焦点举个简单的例子，比如这里有一个按钮：&lt;input type=&quot;button&quot; value=&quot;按钮&quot; class=&quot;button&quot; /&gt;，那么如何获取焦点呢？很简单，就是在css样式里设置： 12345input:focus&#123; /* 这里的样式自定义 */ border: none; border-bottom: 1px red dashed;&#125; 获取焦点后，表单的按钮类元素在鼠标移入时不会显示为可以点击的手型，可以用cursor的样式改变其效果(可以用在其他元素上)，鼠标在移入某元素上时的鼠标样式，这里有5种 可以点击的手型 123.button&#123; cursor: pointer;&#125; 禁用手型（不可以被点击） 123.button&#123; cursor: not-allowed;&#125; 可以任意拖动 123.button&#123; cursor: move;&#125; 提供帮助（在浏览器中显示为？，表示帮助） 123.button&#123; cursor: help;&#125; 等待（加载中的状态） 123.button&#123; cursor: wait;&#125; 绑定焦点：label(内联元素)作用：绑定input元素定义标注，并帮助input元素获取焦点，也就是说当点击选择按钮后面的文字时，也能被选中 写法1：label嵌套成input的父元素两个标签分开写，需要给文字加上span标签 以上面的单选代码为例： 123456789&lt;label&gt; &lt;input type="radio" name="sex" checked /&gt; &lt;span&gt;男&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type="radio" name="sex" /&gt; &lt;span&gt;女&lt;/span&gt;&lt;/label&gt; 写法2：label的for属性的值=input的id值，需要给input加上id值 以上面的多选代码为例： 12345678&lt;input type="checkbox" name="hobby" id="football" /&gt;&lt;label for="football"&gt;足球&lt;/label&gt;&lt;input type="checkbox" name="hobby" id="basketball" /&gt;&lt;label for="basketball"&gt;篮球&lt;/label&gt;&lt;input type="checkbox" name="hobby" class="ball" /&gt;&lt;label for="ball"&gt;羽毛球&lt;/label&gt; form属性1.method：表单的提交方式（POST和GET） 一般浏览器通过哪种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method (方法)属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，之后浏览器会按分段传输的方法将数据发送给服务器；在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，读到参数后，会在应用程序能够使用这些表单值以前，对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数 GET 方法，浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔 GET、POST的区别：get在url里传送数据：安全性低、容量小，便于分享(商品地址和url有关)，适合获取，且会缓存；post安全性一般、容量几乎无限，更适合上传(图片等) action：表单处理服务器 注意：凡是用户与服务器交互的表单标签应全部放在form标签内；form内的提交按钮提交的是整个form表单 举个表单提交的例子~做一个天猫商城网站搜索商品的搜索框 HTML： 1234&lt;form action="https://list.tmall.com/search_product.htm" method="GET"&gt; &lt;input type="text" placeholder="搜索天猫商品" name="q" /&gt; &lt;input type="submit" value="搜索" /&gt;&lt;/form&gt; 然后在浏览器中打开，在文本框随便搜索什么东西，都能跳转到天猫商城的对应商品页 其他表单元素 select/option：下拉选框/下拉选框的选项 对高度的支持不兼容 size(select属性)：用来设置同时显示选项的数量 selected(option属性)：用来设置下拉框的默认选项 举个例子~做一个下拉选框，要求有北京、上海、广州，设置广州为下拉框的默认选项，同时显示2个选项 12345&lt;select name="" id="" size=2&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="guangzhou" selected&gt;广州&lt;/option&gt;&lt;/select&gt; textarea：文本域，即自定义文本框的宽高 各个浏览器下的默认滚动条显示不兼容 cols/rows属性：列数/行数 css3新增 resize 自由缩放样式 resize: none;(禁用缩放)；both水平垂直都可以缩放；horizontal：只有水平方向可以缩放；vertical 只有垂直方向可以缩放。注意：一定要配合overflow:auto 一块使用 举个例子~ 设置一个列数为30行数为10的文本框 1234&lt;!-- 文本框：不能改变宽高 --&gt;&lt;input type="text" /&gt;&lt;!-- 文本域：可以通过设置列数和行数来更改宽高 --&gt;&lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; 设置一个150*150背景为红色的div盒子，用自由缩放样式可以拖动div盒子的右下角以改变大小 HTML部分： 1&lt;div&gt;&lt;/div&gt; CSS部分： 12345678div&#123; width: 150px; height: 150px; background-color: red; /* 水平垂直都可以缩放 ，一定要配合overflow: auto;使用*/ resize: both; overflow: auto;&#125;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端定位和居中]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[定位详解 position: static;无定位（默认值） 元素出现在正常的流中(忽略 top, bottom, left, right 或者 z-index声明)。 当你没有为一个元素指定定位方式时，默认为static，也就是按照文档的流式(flow)定位，将元素放到一个合适的地方。 在不同的分辨率下，采用流式定位能很好的自适合，取得相对较好的布局效果。 position: inherit;继承父元素的定位方式 position: relative;相对定位 不影响元素本身特性，没有定位偏移量时对元素无影响 相对定位的元素仍然在文档流中，仍然占据 着它本来占据的未知空间（虽然它已经不在本来的位置了） 相对于其正常位置进行定位，元素的位置通过偏移值：“left”、”top”、”right”、”bottom”进行规定 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: absolute;绝对定位 使元素从文档流中被删除，结果就是钙元素原本占据的空间被其他元素所填充 使内联元素在设置宽高时支持宽高，区块元素在未设置宽度时由内容撑开宽度（改变元素的特性） 相对于 static 定位以外的第一个祖先元素进行定位(其父元素没有定位则逐层上找，直到document)。元素的位置通过偏移值进行规定。（所以一般对其父元素也要设置定位） 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: fixed;固定定位 元素的表现类似于将 position 设置为 absolute，不过其包含块是视窗(window)本身，也就是说下拉滚动条时包含块始终在窗口中。 定位效果类似之前学过的固定背景，元素与视窗始终相对静止。元素的位置通过偏移值进行规定。 提升层级，用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 z-index: 99;z轴的顺序 当网页上出现多个定位所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面 x轴和y轴决定网页平面，z轴则是垂直于屏幕的虚拟坐标轴，浮动层在这个坐标轴上的顺序号就决定了谁上谁下。 定位才可以触发z-index属性，它没有单位，并可拥有负的属性值。默认值为0 position:relative和-margin都可以使元素位置发生偏移，有什么区别？ 相对定位可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他元素的位置不会发生变化 通过负margin偏移的元素会放弃偏移前占据的空间，后面的其它元素就会“流”过来填充，所以它们位置发生了变化。 元素的居中 行内块级元素 基本思想：使用display: inline-block; vertical-align: middle; 以及一个伪元素让内容块垂直居中于容器中央 123456789.parent::after, .son&#123; display:inline-block; vertical-align:middle; &#125; .parent::after&#123;display:inline-block; content:''; height:100%; &#125; 如果“margin-left”和“margin-right”都是“auto”，那么它们的使用值是相等的。它将元素相对于包含块的边缘水平居中(要求子元素比父元素小，且只能做水平方向的居中)。 1.son&#123;margin:0 auto;&#125; 使用CSS3中新增的transform属性, 支持水平和垂直居中，子元素设置如下: 12345.son&#123; position:absolute; left:50%; //top:50%; transform:translate(-50%,0); //transform:translate(0,-50%);&#125; transform是css3的变形，在后面会详细说明 使用绝对定位方式, 以及负值的margin, 支持水平和垂直居中，（适用于子元素宽度大于父元素宽度的特殊情况，是最优的水平垂直居中方法）子元素设置如下: 123456.son&#123; position:absolute; width:固定宽; //height:固定高; left:50%; //top:50%; margin-left:-0.5固定宽; //margin-top:-0.5固定高 &#125; 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; —支持水平和垂直居中，（缺点：子元素宽度必须小于父元素宽度）子元素设置如下: 1234567.son&#123; position:absolute; width:固定宽; //height:固定高 left:0; //top:0; right:0; //bottom:0; margin:0 auto; //margin:auto 0; &#125; 6. 同时支持水平和垂直居中最好的方案是：transform(变形)（后面会说到）、绝对定位 （相对定位只能做水平居中）和移动端阶段学习的弹性盒模型的几个方案 说那么多…做个练习吧！！！！ ​ 1. 定位练习 ​ 题目：做一个宽高300背景为红色的div块，将4个75*75像素背景为黑色的小div块定位在它的四个角 ​ （注：给子元素设置绝对定位时要记得给父元素设置相对定位） HTML部分： 123456&lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021222324.parent&#123; width: 300px; height: 300px; background-color: red; position: relative;&#125;.parent&gt;div&#123; width: 75px; height: 75px; background-color: black; position: absolute;&#125;.parent&gt;div:nth-of-type(2)&#123; right: 0; top: 0;&#125;.parent&gt;div:nth-of-type(3)&#123; left: 0; bottom: 0;&#125;.parent&gt;div:nth-of-type(4)&#123; right: 0; bottom: 0;&#125; 2. 居中练习 题目：做一个宽高为300背景为灰色的div块，固定定位在页面右下角，并为其设置一个子元素son，绝对定位在其正中心 HTML部分： 123&lt;div class="parent"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021body&#123; height: 2000px;&#125;.parent&#123; width: 300px; height: 300px; background-color: gray; position: fixed; right: 0; bottom: 0;&#125;.parent .son&#123; width: 150px; height: 150px; background-color: blue; position: absolute; left: 50%; margin-left: -75px; top: 50%; margin-top: -75px;&#125; 注：CSS部分给body设置高度是为了验证固定定位的特点，即下拉滚动条时没有改变位置]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端布局和HTML5新标签]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%92%8CHTML5%E6%96%B0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[做一个页面布局 大多数网站会把内容安排到多个列中(就像杂志或报纸那样) 开始使用布局的时候尽量通过ps等画图工具进行设计 早期的网站使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具 如今大多数网站使用等元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局 学习布局时需要完成下面的步骤 第一步：创建一个新项目，用index.html作为主页 第二步：按照ui设计画布局图 第三部：按照布局图布局HTML结构(必须与布局图相同) 第四部：在PS中精确测量出ui设计中每个区域的样式并在css中赋值(注意用内部或外链样式表) HTML5 在W3C经历了严格的标签XHTML、css和XHTML的过渡版之后HTML5的标准出现了。它的出现是为了解决Web各种浏览器之间的兼容性低；文档结构不够明确，不够语义化；应用程序功能受限，需要很多额外的插件(如flash) 目前知名浏览器厂商(微软、Google、苹果等)都对HTML5支持(但是目前还有没正式版本，部分内容不完全支持或兼容有问题) HTML5的声明：；元数据标签设置： 当元素去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于SEO(搜索引擎优化)，语义化标签可以和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息——爬虫依赖于标签来确定上下文和各个关键字的权重 方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化 在html5之前只能使用div作为结构元素，而html5新增了很多带有语义的标签 常用HTML5的结构标签 header(双标签)：页眉，用于页面的头部的信息介绍或者板块头部 footer(双标签)：页脚，用于页面的底部或者版块底部 section(双标签)：版块，用于划分页面上的不同区域，或者划分文章里不同的节，属于article的一个部分 hgroup(双标签)：页面上的一个标题组合，一个标题和一个子标题，或者标语的组合 nav(双标签)：导航，包含链接的的一个列表 article(双标签)：用来在页面中表示一套结构完整且独立的内容部分，可以用来呈现论坛的一个帖子，杂志或报纸中的一篇文章，一篇博客，用户提交的评论内容，可互动的页面模块挂件等可以用header/footer/section等来做头部/脚部/部分 aside(双标签)：元素标签可以包含与当前页面或主要内容相关的引用、侧边栏、广告、nav元素组，以及其他类似的有别与主要内容的部分，aside 的内容应该与 article 的内容相关 被包含在article中作为主要内容的附属信息部分，其中的内容 以是与当前文章有关的引用、词汇列表等 在article之外使用，作为页面或站点全局的附属信息部分；最典型的形式是侧边栏(sidebar)，其中的内容可以是友情链接、附属导航或广告单元等]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端样式的初始化和css样式的补充]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8Acss%E6%A0%B7%E5%BC%8F%E7%9A%84%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[浏览器的默认样式 同一个标签在不同的浏览器中有不同的默认样式，为了让样式在所有浏览器中统一，并设置一些预定义样式，我们应该做浏览器默认样式的初始化 默认样式的检查方式：可以用border+浏览器开发者工具来查看是否有默认样式 常见的浏览器默认样式 文字斜体和加粗等字体样式：font-weight:normal;font-style:normal; body、ul等区块元素的填充和边距：margin:0; padding:0; li的列表样式：list-style:none; a标签和其状态性伪类的字体颜色和下划线样式： 12345a&#123;text-decoration:none; color:#000; border:0;&#125;a:link&#123;text-decoration:none; color:#000;&#125;a:visited&#123;text-decoration:none; color:#000;&#125; a:hover&#123;text-decoration:none; color:#000;&#125;a:active&#123;text-decoration:none; color:#000;&#125; 设置盒模型的样式：box-sizing:border-box; 也就是说，每写一个网页就要清一次样式，是不是很麻烦呢？别着急，这里准备了一个common.css，每次写网页直接引用就可以啦~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@charset "utf-8";/* CSS Document */*&#123; box-sizing:border-box; color:#000;&#125;body&#123; font-size:14px; font-family:Arial,Verdana,Tahoma,"微软雅黑","黑体"; line-height:1.2em; background:#fff; margin:0; overflow-x:hidden;&#125;p,h1,h2,h3,h4,h5,h6,ul,ol,dl,li,form,table&#123; margin:0; padding:0;&#125;img&#123; vertical-align:middle;&#125;li&#123; list-style:none;&#125;i,em&#123; font-style:normal;&#125;a&#123; text-decoration:none; color:#000000;&#125;a:link&#123; text-decoration:none; color:#000000;&#125;a:visited&#123; text-decoration:none; color:#000000;&#125;a:hover&#123; text-decoration:none; color:#000000;&#125;a:active&#123; text-decoration:none; color:#000000;&#125;.clearfix:after&#123; display:block; content:""; clear:both;&#125;.clearfix&#123; *zoom:1;&#125; CSS样式的补充 改变元素的透明度 12opacity: 0.9; /* 赋值0-1，从透明到完全不透明 */filter: alpha(opacity=90); /* 为了兼容低版本IE浏览器的滤镜 */ 如果是背景颜色需要加透明度就是background-color: rgba(255,255,255,0.5); 隐藏元素 12visibility: hidden/visible; /* 隐藏元素但是依然占位 */display: none/block; /* 隐藏元素但是不占位 */ 注意：虽然visibility: hidden的隐藏元素依然占位，但是它与透明度为0有区别，透明度为0的元素我们依然可以摸到，但是visibiity: hidden的元素却无法摸得到 举个例子： html部分： 123456 &lt;div class="box1"&gt;div1&lt;/div&gt; &lt;div class="box2"&gt;div2&lt;/div&gt; &lt;div class="box3"&gt;div3&lt;/div&gt; &lt;div class="box4"&gt;div4&lt;/div&gt;&lt;!-- 元素透明和visibility隐藏，元素的位置依然保留；而display的none方法，元素的位置消失 --&gt;&lt;!-- 元素透明opacity看得见摸得着，而visibility和display看得见摸不着 --&gt; css部分： 1234567891011121314151617181920212223 div&#123; width: 150px; height: 150px; background-color: red; font-size: 50px; color: white; &#125; /* 设置box1的透明度为0 */ .box1&#123; opacity: 0; &#125; /* 当鼠标点击时box1变为不透明，即可以显示 */.box1:hover&#123; opacity: 1; &#125; /* 设置box2元素为隐藏元素 */ .box2&#123; visibility: hidden; &#125; /* 当鼠标点击时box2不能显示 */ .box2:hover&#123; visibility: visible; &#125; overflow：溢出的部分应该如何显示 12345678overflow-x:hidden; /*水平方向溢出*/overflow-y:auto; /*垂直方向溢出*/overflow:inherit; /*两个方向溢出*/visible：默认值。溢出的内容不会被修剪，会呈现在元素框之外；hidden：溢出的内容会被修剪，并且其余内容是不可见的；(如上面的初始化默认样式中的overflow-x:hidden;，让body的内容在水平方向溢出时裁切，不显示滚动条)scroll：溢出的内容会被修剪，浏览器会显示滚动条以便查看其余的内容；auto：如果溢出的内容被修剪，则浏览器会显示滚动条以便查看其余的内容；inherit：规定应该从父元素继承 overflow 属性的值 百分比单位： 字体的行高使用了百分比，表示字体大小的百分之多少； 盒子模型子元素的宽高百分比=父元素宽高的百分比*子元素的宽高百分比； 子元素的padding和margin设置百分比时却不是对应父元素的内填充和外边距，而是子元素的padding和margin=父元素的宽*子元素的padding和margin的百分比(后面的left和top也是父元素的宽高，需要注意) 背景定位的X/Y=（父元素宽/高-图片宽/高）*背景定位的百分比 最大最小宽高：可以配合上面的百分比宽高一起使用，做一个变化带有范围的效果： 最大宽：max-width: ; 最小宽：min-width: ; 最大高：max-height: ; 最小高：min-heihgt: ; 注：设置最小高度时，当文字超过最小高度的大小时高度会随文字的增多而变高 轮廓线outline（了解）：它是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，它不会占据空间，也不一定是矩形。 1234outline-color:; /*轮廓线颜色*/outline-style:; /*轮廓线样式*/outline-width:; /*轮廓线宽度*/outline-offset:; /*轮廓线扩张*/ 注：写成集合样式outline，如果不设置其中的某个值，也不会出问题，比如 outline:solid #ff0000; 也是允许的 列表元素 列表元素有dl(定义列表)、dt(定义名)、dd(详情)、ul(无序列表)、ol(有序列表)、li(列表的项) 当我们需要把一系列类似的项在页面中展示的时候就要用到列表，比如名词解释(定义列表)、商品列表或导航(无序列表) 它们是一种绑定关系，其中dt和dd必须是dl的子元素，dl也只能用dt和dd作为子元素；li是ul和ol的子元素，ul和ol也只能用li做子元素 ol(有序列表)有一个type属性，可以把值设为1(默认值，数字序列)、A(大写字母序列)、a(小写字母序列)、I(大写罗马数字序列)、i(小写罗马数字序列)，若已经将li的list-style设置为none则样式都会丢失]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装及基本使用]]></title>
    <url>%2F2019%2F07%2F06%2Fgit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[准备工作 下载git 注册github 将git和github连接起来 获取ssh秘钥 id_rsa.pub github里，找到settings，填入秘钥 正式开始 1、确定git和github已经连接 12git initgit remote add origin 仓库地址 2、本地文件推到github上 将新建的文件添加到git的缓存区 1234添加具体名称文件git add index.html添加全部文件git add . 给提交的文件添加描述 1git commit -m &apos;demo&apos; 汇总到总分支上 1git pull origin master --allow-unrelated-histories 退出 1:wq 文件推到远程仓库 123 git push origin mastergit push -u origin master 输入用户名(如果设置了SSH密匙的话就不用输入密码了) 1输入OpenSSH：输入密码 ==如果出现错误== 1git config --global user.email &quot;you@example.com&quot; 一般在push的时候会出现错误1234hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法 先执行git pull origin master 在执行git push origin master==这个时候又可能出现错误== 1fatal: refusing to merge unrelated histories 不用慌，我在网上搜好多方法，都说使用如下指令 12git pull origin master --allow-unrelated-histories git pull --allow-unrelated-histories 但是输入这些指令之后会跳出来另外一个界面然后从新pull就行了 我的解决方法重新在原文件下Git Brush Here然后重新开始就可以解决 无论使用git pull 出不出现错误只要出现刷新github文件就推过来了学习相关git的操作git的学习 廖雪峰的官方网站]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内联块和浮动问题]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%86%85%E8%81%94%E5%9D%97%E5%92%8C%E6%B5%AE%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[内联块和浮动都是为了使区块元素在一行显示 内联块（inline-block） 设置：很简单，直接在css样式中加上display: inline-block;即可 特点： 可以和非区块元素在一行显示 支持所有的样式 不设置宽高时由内容（文字图片等）撑开 换行符会被解析（缺点） 那么，如何去掉内联块之间的空格（换行符）呢？这里有四种方法哦~ a.第一种方法：将后面的内联块设置左外边距为负值，值为父元素大小的0.25倍 举个例子，假设有两个内联块，直接给后面的内联块（第二个）的css样式设置为margin-left:-0.25m; b.第二种方法：用注释去掉换行符 这个方法可能有点不好理解，前面说了，使用内联块换行符会被解析，那么如果给换行符加上注释会不会解决这个问题呢？答案是肯定的~ 举个例子~ 12&lt;div&gt;&lt;/div&gt;&lt;!--加上注释--&gt;&lt;div&gt; &lt;/div&gt; c.第三种方法：设置字间距（letter-spacing）为-0.25倍 也就是css样式里加上letter-spacing:-0.25em; d.第四种方法：将父元素的字体大小设置为0，在子元素里重新设置字体大小 这个方法很容易理解，这里就不举例啦！！ 我们可以发现，使用内联块实现区块元素并排显示其实非常麻烦，那么有没有更加方便的方法呢？ 浮动元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住：float：left/right/none(默认值)，由于子元素脱离文档流，结果会使父元素高度崩塌，解决浮动元素脱离文档流不占位的方法 我们可以看到，浮动会使父元素高度崩塌。Therefore，解决父元素高度崩塌的方法来啦~ 方法1：给父元素设置高度 ​ 局限性：（1）不确定高度时无法使用；（2）在内容、数量不确定时也无法使用 方法2：将父元素设置为BFC盒子，也就是说不能用浮动方法，要在父元素的css样式里写为overflow:hidden; ​ 局限性：在父元素有溢出部分时无法使用 方法3：为所有浮动元素后面设置一个空元素，在里面设置清除浮动clear:both 举个例子：div元素需要左浮动，我们需要在div元素后面设置空元素span 12345678910&lt;style&gt; div&#123; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;span syyle="display:block; clear:both;"&gt;&lt;/span&gt;&lt;/body&gt; ​ 局限性：创建了一个没有任何意义的空标签 方法4：为父元素设置after伪元素，在该元素上设置清除浮动clear:both; ​ 局限性：低版本的IE浏览器不识别 解决办法：用.cearfix{*zoom:1}来兼容 也就是说这个方法几乎没有缺点，是最优方法 好啦让我们来举例叭 假设有4个div元素，其中一个类名为parent元素是父元素（边框为2px black solid），为这三个div元素设置浮动并清除 123456789101112131415161718192021222324&lt;style&gt; .parent&#123; border:2px black solid; &#125; /*设置伪元素，清除浮动*/ .parent::after&#123; display:block; content:""; clear:both; &#125; .parent&gt;div&#123; width:100px; height:100px; background-color:red; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的选择器扩展]]></title>
    <url>%2F2019%2F07%2F01%2Fcss%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分组选择器：注：以下两种书写方式一般没有区别，但也有特殊情况。假设p标签也有一个类名为class，地址名为id的元素，就必须要在最前面加上标签名 12.class,#id /*选择类名为class的所有选择和地址名为id的元素*/div.class,#id /*选择div的所有后代中类名为.class的元素和地址名为id的元素*/ 多条件选择器：同时满足类名为box1和box2的元素 1.box1.box2 /*既有类名为box1的元素同时也有类名为box2的元素*/ 子元素选择器：1div&gt;.class /*选择div元素的所有子元素中有类名为class的元素*/ next选择器：1div+p /*选择div元素的下个同级元素且标签为p的元素*/ 伪类选择器（状态性伪类）：注：以下的标签a的4个伪类必须按照lvha的顺序书写，否则可能会出错 1234 a:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接（正在击中）*/ 举个状态性伪类的例子：设计一个div盒子（宽200px高200px、红色），要求：当鼠标移动该盒子上时盒子变为蓝色，当鼠标点击该盒子时盒子的宽和高分别为500px和150px 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;状态性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:200px; height:200px; background-color:red; &#125; div:hover&#123; background-color:blue; &#125; div:active&#123; width:150px; height:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器（结构性伪类）：注：before 和after中必须设置content(内容)和display(种类)两个样式，否则无法正确显示 1234p::before /*在每个p元素的内容之前插入内容*/p::after /*在每个p元素的内容之后插入元素*/display /*用来修改元素种类，分别有block（区块元素）、inline(内联元素)、inline-block（内联块元素）、none（隐藏元素，不占用物理空间）*/content:"" /*引号里写要显示的内容，如果没有要显示的内容就空着*/ 举个伪元素选择器（结构性伪类）的例子：写一个div元素(300,300)，为它设置before伪元素（区块元素 150px,150px），当你的鼠标移入div时让伪元素背景颜色发生变化，在div上击中时，伪元素隐藏 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;结构性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:300px; height:300px; background-color:brown; &#125; /*先把div元素转换为伪元素*/ div::before&#123; content:""; display:block; width:150px; height:150px; background-color:chartreuse; &#125; /* 鼠标移伪元素时改变颜色 * 格式：div:hover::befere */ div:hover::before&#123; background-color:cornflowerblue; &#125; div:active::before&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于表格的一些基础知识~]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%85%B3%E4%BA%8E%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先让我们认识一些表格标签12345678&lt;table&gt; &lt;!-- 定义表格（必不可少） --&gt;&lt;caption&gt; &lt;!-- 表格标题（默认居中） --&gt;&lt;thead&gt; &lt;!-- 表格表头 --&gt;&lt;tbody&gt; &lt;!-- 表格正文（必不可少） --&gt;&lt;tfoot&gt; &lt;!-- 表格页脚 --&gt;&lt;th&gt; &lt;!-- 表头单元格（加粗黑体） --&gt;&lt;tr&gt; &lt;!-- 表格行 --&gt;&lt;td&gt; &lt;!-- 表格单元格 --&gt; 举个例子： 123456789101112131415&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;我是第一列表头单元格&lt;/th&gt; &lt;th&gt;我是第二列表头单元格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;我是第一列&lt;/td&gt; &lt;td&gt;我是第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 这是一张2行2列的表格，第一行是表头单元格，第二行是表格正文。在浏览器运行后会发现，不仅单元格间有间隙，表格内边距也有。为了解决这个问题，表格属性来啦1234567891011- ##### 表格属性 ```css cellspacing ------单元间间隙(用于table标签) cellpadding ------表格内边距(用于table标签) colspan=&quot;2&quot; ------横向合并单元格(用于td标签)，2代表两个单元格合并 rowspan=&quot;2&quot; ------纵向合并单元格(用于td标签) ```再试一下，在table标签里加入了cellspacing=&quot;0&quot;，cellpadding=&quot;0&quot;后就不存在这样的问题了 表格样式：为表格和单元格设置border等样式，否则无法看到表格边框，除此外table的border-collapse样式，可以用来合并相邻单元格的边框 1border-collapse:collapse; /* 用于table标签中，注：使用该样式时要把单元间间隙（cellsapcing）设为0 */ 以上就是最简单的表格的制作啦~~ 接下来再举一个小例子：（加上css样式和合并单元格）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;简单的表格制作&lt;/title&gt; &lt;style&gt; table,td,th&#123; border:1px black solid; &#125; table&#123; border-collapse:collapse;/*合并相邻的单元格边框*/ &#125; td,th&#123; width:100px; height:30px; text-align:center; /*所有文字居中*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspancing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--第一行的第一列和第二列合并--&gt; &lt;th colspan="2"&gt;第一行第一列表头单元格&lt;/th&gt; &lt;!--&lt;th&gt;第一行第二列表头单元格&lt;/th&gt;*/--&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;td rowspan="2"&gt;我是第二行第一列&lt;/td&gt; &lt;td&gt;我是第二行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;!--&lt;td&gt;我是第三行第一列&lt;/td&gt;--&gt; &lt;td&gt;我是第三行第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 最后来说一下table表格的缺点~ 太深的嵌套，如table&gt;tbody&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了代码量 灵活性差，比如要将tr设置border等属性，是不行的，得通过td 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱 table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间 不够语义，无论是计算机还是阅读代码的人在阅读时都觉得非常困难]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和css知识点]]></title>
    <url>%2F2019%2F06%2F21%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[HTML部分知识点总结 块元素（将内容分块显示）：特立独行，不在一行中显示 eg：h1,h2,…,h6,p,blockquote . 块元素在内容前后分别有一个默认的换行内联元素（显示在所在的段落中）：随波逐流 eg：q,a,em link：利用外部样式表为本页面增加样式（不再需要style） eg：新建一个lounge.css文件1&lt;link type="test/css" rel="stylesheet" href="lounge.css"&gt; em ：斜体；strong：加粗；b：加粗（强调文本）1&lt;em&gt;我是一个斜体标签&lt;/em&gt; q：短引用（段落中的引用）；blockquote：长引用（引用独立的文字） 12&lt;q&gt;千里之行，始于足下&lt;\q&gt;&lt;blockquote&gt;我是一个长引用&lt;/blockquote&gt; br：换行 code：显示计算机程序代码 li：列表元素；ol：有序列表；ul：无序列表（不与p标签写在一起，都是块元素）123456&lt;ol&gt; &lt;li&gt;Walla, WA&lt;/li&gt; &lt;li&gt;Magic city, ID&lt;/li&gt; &lt;li&gt;Bountiful, UT&lt;/li&gt; &lt;li&gt;Last chance, CO&lt;/li&gt;&lt;/ol&gt; StarBuzzCoffee.com是域名（范围大）；www.StarBuzzCoffee.com是网站名（范围小） 链接页面的方式：a.相对路径：只能链接同一网站的页面 b.URL：通常用来链接其他网站 为链接增加标题以便访问：a herf=”” title=”” 当鼠标移到链接上，停留一秒，就可以看到这个工具提示1Read the &lt;a href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt;. 使用id属性为超链接a创建目标 用id链接到元素：要链接到页面中的一个特定目标，只需在链接最后加一个#，再加上目标标志符1&lt;a href="index.html#chai"&gt;See Chai Tea&lt;/a&gt; 使用target打开新窗口 1&lt;a target="_blank" href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt; 调整图像大小：width和heightsrc：引入和替代 href：引用和链接 alt：当图片无法识别时的提示 title：鼠标点击图片时的提示 target=”_black”：在新窗口打开新页面 target=”_self”：在原来的窗口打开页面 1&lt;img src="../images/red.jpg" alt="" width="200" height="200"&gt; W3C验证工具：http://validator.w3.org 绝对路径：相对于计算机的路径 相对路径：一般使用 背景定位常用指令：水平方向Left center right；垂直方向top center bottom css知识点汇总注：在CSS中，不需要给元素两边加尖括号&lt;&gt;，所有元素都叫做选择器 把css放入html：在head元素中增加开始和结束style标记，css规则要放在style里 margin-left, margin-right：左右外边距，占页面的20% 12margin-left: 20%;margin-right: 20%; border：定义页面主体周围的边框 虚线：dotted，实线：solid，颜色为黑色 1border: 2px dotted black; padding：在页面主体周围创建一些内边距 1padding:10px 10px 10px 10px; font-family：定义文本使用的字体1font-family: sans-serif; color：设置文字颜色1color:red; border-bottom：加下划线 eg：在h1标题下加下划线123h1&#123; border-bottom: 1px solid black; &#125; 盒子模型=内容+内填充+外边距+边框]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Operation Of Hexo]]></title>
    <url>%2F2019%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment The Step Of Upload12345$ hexo s$ hexo clean$ hexo g$ hexo s$ hexo d]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目： 使用冒泡排序编写程序，实现对数组{25,24,12,76,101,96,28}的排序 2.源代码： 123456789101112131415161718192021222324252627package interest;public class pubble &#123; public static void main(String[] args) &#123; int[] arr=&#123;25,24,12,76,101,96,28&#125;; for(int i=0;i&lt;arr.length-1;i++) &#123; for(int j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println(&quot;冒泡排序的结果是：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非负十进制整数转换为b进制数]]></title>
    <url>%2F2019%2F06%2F07%2F%E9%9D%9E%E8%B4%9F%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BAb%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目名称 将非负十进制整数n转换成b进制。（其中b=2~16） 2.算法构造 （1）递归： 十进制数对b进制取余，若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示。然后利用递归模型返回十进制数和b进制的值，最后利用StringBuilder实现逆序输出字符串 递归模型：duigui(n,b)= duigui(n/b,b) n&gt;=0 递归出口：n&lt;b (其中为是十进制数，b为进制数) （2）非递归： 当十进制数不为0时，十进制数对b进制取余，十进制数变为原来的十进制数/b进制。若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示，最后利用StringBuilder实现逆序输出字符串 5.经验归纳 5.1遇到的问题 &lt;1&gt;刚开始用的是数组，结果发现不用循环很难把字符赋给数组 &lt;2&gt;逆序输出那里考虑不周全 &lt;3&gt;用递归树或者递归栈描述调用过程 5.2心得体会 这次的基本要求没有什么难点，主要就是递归函数的建立，非递归比递归简单一些，就是在最后的逆序输出那里会遇到问题，上网查了一下，说是可以用StringBuffer来实现，所以基本上没什么大问题。对了~画出递归树或者递归栈的调用过程这里也是问题，第一次画，对这个概念不是很熟悉。 附：源代码 1.Test0类（主方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;import java.util.Scanner;public class Test0 &#123; static int n; static int b; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); TwoMethods t=new TwoMethods(); System.out.println(&quot;请输入一个非负整数：&quot;); n=sc.nextInt(); while(true) &#123; if(n&lt;0) &#123; System.out.println(&quot;Error！请输入一个非负整数：&quot;); n=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); while(true) &#123; if(b&lt;1||b&gt;16) &#123; System.out.println(&quot;Error！请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;你想使用哪种方法进行运算？1.递归 2.非递归（1/2）：&quot;); int x=sc.nextInt(); switch(x) &#123; case 1: //调用递归方法 t.digui(n,b); break; case 2: t.feidigui(n,b);//调用非递归方法 break; &#125; sc.close(); &#125;&#125; 2.两种方法实现转换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;public class TwoMethods &#123; static String a=&quot;&quot;; //定义一个字符串，用来存储b进制 static int num; //b进制数 public static void feidigui(int n,int b) //非递归 &#123; while(n&gt;0) //当十进制数不为0时 &#123; num=n%b; //十进制数对b进制取余 n=n/b; //十进制数变为原来的十进制数/b进制 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; &#125; System.out.println(&quot;用非递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; public void digui(int n,int b) //递归 &#123; if(n!=0) &#123; num=n%b; //十进制数对b进制取余 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; digui(n/b,b); //利用递归模型返回十进制数和b进制的值 &#125; else &#123; System.out.println(&quot;用递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的递归程序]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目名称 &lt;1&gt;赶鸭子问题：一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？ &lt;2&gt;角谷定理：输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。 如：输入22， 输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 STEP=16 2.题目分析 &lt;1&gt;赶鸭子问题：假设一共有sum只鸭子，而sum=one(n)，n表示村子数，每经过一个村子就卖出one(n)/2+1只鸭子，剩下的就是下一个村子的鸭子数，也就是one(n+1)，那么鸭子总数one(n)=(one(n)/2+1)+(one(n+1))，经过运算得出鸭子总数one(n)=(one(n+1)+1)_2；题目说这个人经过七个村子后还剩两只鸭子，也就是在第8个村子的时候还有两只鸭子，也就是one(8)=2 &lt;2&gt;角谷定理：这个题的递归出口是固定的，即当得到自然数值1的时候递归结束。假设经过了sum=one(x)次操作后得到自然数1，输入的自然数一共分为3种情况，第一种是x=1，这种情况很特殊，直接sum+1输出即可；第二种情况是x为偶数，按照题目要求，将这个数有限次除以2，也就是one(x/2)，并使sum递加；第三种情况是x为奇数，将这个数有限次乘以3再加1，也就是one(x_3+1)，并使sum递加 3.算法构造 4.心得体会 递归问题主要还是数学思维，我觉得第一个题用递归方法偏难一点，但是算法构造出来实现就简单了，这两个题学C语言的时候有接触过，所以还有印象。这两道题相对以前的作业简单很多~ 附：源代码： &lt;1&gt;赶鸭子问题： 123456789101112131415161718192021222324252627282930package DuckSale;public class 卖鸭子递归 &#123; static int sum; public static void main(String[] args) &#123; int n=1; int num;//每个村子卖出的鸭子数 int sum=one(n); //刚开始的鸭子数,n个村子 System.out.println(&quot;刚开始有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++)//循环输出经过每个村子卖出的鸭子数 &#123; num=sum/2+1; sum-=num; //剩余鸭子数 System.out.println(&quot;经过第&quot;+i+&quot;个村子卖出了&quot;+num+&quot;只鸭子,还剩下&quot;+sum+&quot;只鸭子&quot;); &#125; &#125; public static int one(int n) &#123; if(n&lt;8) &#123; return 2*(one(n+1)+1); &#125; else if(n==8) &#123; return 2; &#125; return n; &#125;&#125; ②非递归实现： 1234567891011121314151617181920package DuckSale;public class 卖鸭子非递归&#123; static int sum=2;//鸭子总数 public static void main(String[] args) &#123; int num; for(int i=1;i&lt;8;i++) &#123; sum=(sum+1)*2;//循环计算出鸭子总数 &#125; System.out.println(&quot;一共有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++) &#123; num=sum/2+1; sum-=num; System.out.println(&quot;经过第&quot;+i+&quot;个村子卖了&quot;+num+&quot;只鸭子，还剩&quot;+sum+&quot;只鸭子&quot;); &#125; &#125;&#125; &lt;2&gt;角谷定理： ①递归实现： 12345678910111213141516171819202122232425262728293031323334353637package JiaoGuTheory;import java.util.Scanner;public class 角谷定理递归 &#123; static int sum=0; //计算次数 public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); int sum=one(x); System.out.println(); System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125; public static int one(int x) &#123; if(x==1) //输入的自然数为1 &#123; System.out.print(x+&quot; &quot;); sum++; &#125; else if(x%2==0) //输入的自然数为偶数 &#123; System.out.print(x+&quot; &quot;); one(x/2);//将这个数有限次除以2 sum++; &#125; else if(x%2!=0) //输入的自然数为奇数 &#123; System.out.print(x+&quot; &quot;); one(x*3+1); //将这个数有限次乘以3再加1 sum++; &#125; return sum; &#125;&#125; ②非递归实现： 1234567891011121314151617181920212223242526272829303132333435package JiaoGuTheory;import java.util.Scanner;public class 角谷定理非递归 &#123; static int sum=0; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); while(x&gt;=1) &#123; if(x==1) &#123; sum++; System.out.println(x); break; &#125; else if(x%2==0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x/2; &#125; else if(x%2!=0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x*3+1; &#125; &#125; System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟肯德基快餐店的收银系统]]></title>
    <url>%2F2019%2F05%2F10%2FJava%E6%A8%A1%E6%8B%9F%E8%82%AF%E5%BE%B7%E5%9F%BA%E5%BF%AB%E9%A4%90%E5%BA%97%E7%9A%84%E6%94%B6%E9%93%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1.题目名称 模拟肯德基快餐店的收银系统 要求：结合设计模式（2种以上）至少实现系统的以下功能： 1.正常餐品结算和找零。 2.基本套餐结算和找零。 3.使用优惠劵购买餐品结算和找零。 4.可在一定时间段参与店内活动（自行设计或参考官网信息）。 5.模拟打印小票的功能（写到文件中）。 2.算法构造 这个系统需要用到两种设计模式，分别是工厂方法模式和抽象工厂模式。 &lt;1&gt;工厂方法模式：在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口。 抽象工厂(IKfcFactory)：给出具体工厂必须实现的接口； 具体工厂(ChinaKfcFactory)：在该工厂中指明生产各种抽象食物的方法：生产汉堡、薯条、鸡翅、饮料、套餐1、套餐2； 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：负责输出用户的订单信息 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：这个工厂需要生产具体的食品：麻辣奥尔良烤堡、奥尔良烤翅、普通霸王薯条、可乐饮料。 &lt;2&gt;抽象工厂模式：抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 抽象工厂(AbstractBaseFood) 具体工厂(ChinaKfcFactory) 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：相当于产品等级 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：相当于产品族，生产出具体的食物 客户类(Customer)：向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 3.类图 4.调试及运行结果 4.1调试结果 4.2运行结果 1.选择单点： 2.选择套餐 4.文件里的账单（在eclipse中打开.txt文件） 5.经验归纳 5.1遇到的问题 &lt;1&gt;将账单写入文件后.txt文件里什么都没有~ &lt;2&gt;不熟悉抽象工厂模式，将工厂方法模式和抽象方法模式混在一起了 &lt;3&gt;单品的种类太少，抽象工厂模式运用的不全面 &lt;4&gt;该系统还存在一些不足，打算后期进行优化 5.2心得体会 这个系统中，最核心的就是设计模式的选择与应用了！个人感觉我做的系统用的工厂方法模式比抽象工厂模式全面一些，因为每一种食品只有一种，没有分很多种，所以产品族的产品对象是不全面的。 还有一个很大的问题，就是账单没有办法写入文件中。我选择的是FileWriter方法将账单写入文件的，然而文件中却什么都没有。后来我发现在eclipse中打开.txt文件，账单是在文件里的，所以我没有用记事本打开.txt文件，而是选择了eclipse。 其实我觉得界面可以用Java的图形图像处理来实现，还涉及到数据库，打算考完试实现一下~~ 附：源代码 1.AbstractBaseFood接口 1234567891011121314151617package inter.KFC;//食物基类 public abstract class AbstractBaseFood &#123; //类别 protected String kind; //数量 protected int num; //价格 protected int price; //合计 public int totalPrice() &#123; return this.num * this.price; &#125;&#125; 2.抽象食物接口IFood 123456789package inter.KFC; //抽象食物接口 public interface IFood &#123; //打印输出食物信息 void printMessage();&#125; 3.肯德基抽象工厂接口IKfcFactory 12345678910111213141516171819202122232425package inter.KFC;//肯德基抽象工厂 public interface IKfcFactory &#123; //生产汉堡 public Hamburg createHamburg(int num); //生产薯条 public FrenchFries createFrenchFries(int num); //生产鸡翅 public ChickenWings createChickenWings(int num); //生产饮料 public Beverage createBeverage(int num); //生产套餐1 public TaoCan1 createTaoCan1(int num); //生产套餐2 public TaoCan2 createTaoCan2(int num);&#125; 4.肯德基具体工厂ChinaKfcFactory继承接口IKfcFactory 123456789101112131415161718192021222324252627282930313233343536package inter.KFC;//肯德基具体工厂public class ChinaKfcFactory implements IKfcFactory&#123; //生产汉堡 public Hamburg createHamburg(int num) &#123; return new ChinaHamburg(num); &#125; //生产薯条 public FrenchFries createFrenchFries(int num) &#123; return new ChinaFrenchFries(num); &#125; //生产鸡翅 public ChickenWings createChickenWings(int num) &#123; return new ChinaChickenWings(num); &#125; //生产饮料 public Beverage createBeverage(int num) &#123; return new ChinaBeverage(num); &#125; //生产套餐1 public TaoCan1 createTaoCan1(int num) &#123; return new RealTaoCan1(num); &#125; //生产套餐2 public TaoCan2 createTaoCan2(int num) &#123; return new RealTaoCan2(num); &#125; &#125; 5.客户类Customer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package inter.KFC;//客户类public class Customer &#123; //抽象工厂 private IKfcFactory kfcFactory; //构造方法将抽象工厂作为参数传入 public Customer(IKfcFactory kfcFactory)&#123; this.kfcFactory = kfcFactory; &#125; //订购食物 //订购麻辣鸡腿汉堡 public int orderHamburg(int num)&#123; //获得奥尔良烤堡 Hamburg hamburg = kfcFactory.createHamburg(num); //输出订购信息 hamburg.printMessage(); //返回总价 return hamburg.totalPrice(); &#125; //订购奥尔良烤翅 public int orderChickenWings(int num)&#123; //获得奥尔良烤鸡翅 ChickenWings chickenWings = kfcFactory.createChickenWings(num); //输出订购信息 chickenWings.printMessage(); //返回总价 return chickenWings.totalPrice(); &#125; //订购薯条 public int orderFrenchFries(int num)&#123; //获得霸王薯条 FrenchFries frenchFries = kfcFactory.createFrenchFries(num); //输出订购信息 frenchFries.printMessage(); //返回总价 return frenchFries.totalPrice(); &#125; //订购可乐 public int orderBeverage(int num)&#123; //获得可乐 Beverage beverage = kfcFactory.createBeverage(num); //输出订购信息 beverage.printMessage(); //返回总价 return beverage.totalPrice(); &#125; //订购套餐1 public int orderTaoCan1(int num)&#123; //获得套餐1 TaoCan1 taocan1=kfcFactory.createTaoCan1(num); //输出订购信息 taocan1.printMessage(); //返回总价 return taocan1.totalPrice(); &#125; //订购套餐2 public int orderTaoCan2(int num)&#123; //获得套餐2 TaoCan2 taocan2=kfcFactory.createTaoCan2(num); //输出订购信息 taocan2.printMessage(); //返回总价 return taocan2.totalPrice(); &#125;&#125; 6.汉堡基类Hamburg 1234567891011package inter.KFC;//汉堡基类 public abstract class Hamburg extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;奥尔良烤堡，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 7.汉堡子类(具体产品实现)ChinaHamburg 12345678910111213package inter.KFC;//奥尔良烤堡//具体产品public class ChinaHamburg extends Hamburg&#123; public ChinaHamburg(int num) &#123; this.kind = &quot;麻辣&quot;; this.price = 28; this.num = num; &#125;&#125; 8.薯条基类(抽象产品)FrenchFries 123456789101112package inter.KFC;//薯条基类//抽象产品public abstract class FrenchFries extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;霸王薯条，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 9.薯条子类(具体产品实现)ChinaFrenchFries 123456789101112package inter.KFC;//薯条实现类//具体产品public class ChinaFrenchFries extends FrenchFries&#123; public ChinaFrenchFries(int num) &#123; this.kind = &quot;普通&quot;; this.price = 8; this.num = num; &#125;&#125; 10.鸡翅基类(抽象产品)ChickenWings 1234567891011package inter.KFC;//鸡翅基类public abstract class ChickenWings extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;烤翅，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 11.鸡翅子类(具体产品实现)ChinaChickenWings 123456789101112package inter.KFC;//鸡翅实现类 //具体产品public class ChinaChickenWings extends ChickenWings&#123; public ChinaChickenWings(int num) &#123; this.kind = &quot;奥尔良&quot;; this.price = 5; this.num = num; &#125;&#125; 12.饮料基类(抽象产品)Beverage 1234567891011package inter.KFC;//饮料基类 public abstract class Beverage extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;饮料，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 13.饮料子类(具体产品实现)ChinaBeverage 1234567891011package inter.KFC;//可乐实现类public class ChinaBeverage extends Beverage&#123; public ChinaBeverage(int num) &#123; this.kind = &quot;可乐&quot;; this.price = 10; this.num = num; &#125;&#125; 14.套餐1基类(抽象产品)TaoCan1 12345678910package inter.KFC;//套餐1基类public abstract class TaoCan1 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐1，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 15.套餐1子类(具体产品实现)RealTaoCan1 1234567891011package inter.KFC;//套餐1实现类public class RealTaoCan1 extends TaoCan1&#123; public RealTaoCan1(int num) &#123; this.kind = &quot;超值&quot;; this.price = 50; this.num = num; &#125;&#125; 16.套餐2基类(抽象产品)TaoCan2 12345678910package inter.KFC;//套餐2基类public abstract class TaoCan2 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐2，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 17.套餐2子类(具体产品实现)RealTaoCan2 1234567891011package inter.KFC;//套餐2实现类public class RealTaoCan2 extends TaoCan2&#123; public RealTaoCan2(int num) &#123; this.kind = &quot;超值&quot;; this.price = 40; this.num = num; &#125;&#125; 18.菜单类MainMenu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package inter.KFC;import java.util.Scanner;import java.io.*;import java.io.FileWriter;//菜单public class MainMenu &#123; //定义一个肯德基（IKfcFactory类型） IKfcFactory kfcFactory = new ChinaKfcFactory(); //创建客户 Customer customer = new Customer(kfcFactory); Scanner sc=new Scanner(System.in); public int a; public int num1; public int num2; public int num3; public int num4; public int num5; public int num6; int hamburgMoney=customer.orderHamburg(num1); int chickenWingsMoney = customer.orderChickenWings(num2); int frenchFriesMoney = customer.orderFrenchFries(num3); int singleMoney = customer.orderBeverage(num4); int taocan1Money =customer.orderTaoCan1(num5); int taocan2Money =customer.orderTaoCan2(num6); public int price; public String b; public int c; public int d; //用户付款金额 public int e; //找零 public void menu() &#123; System.out.println(&quot;* * * * * 欢迎进入肯德基炸鸡店 * * * * *&quot;); System.out.println(&quot;* 您可以选择：1.单点 2.套餐 *&quot;); System.out.println(&quot;* 请您选择：&quot;); a=sc.nextInt(); switch(a) &#123; case 1: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;1.汉堡类：奥尔良烤堡_28元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;2.鸡翅类：奥尔良烤翅_5元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;3.小食类：霸王薯条_8元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;4.饮料类：可乐_10元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择奥尔良烤堡的数量：&quot;); num1=sc.nextInt(); hamburgMoney = customer.orderHamburg(num1); System.out.print(&quot;请您选择奥尔良烤翅的数量：&quot;); num2=sc.nextInt(); chickenWingsMoney = customer.orderChickenWings(num2); System.out.print(&quot;请您选择霸王薯条的数量：&quot;); num3=sc.nextInt(); frenchFriesMoney = customer.orderFrenchFries(num3); System.out.print(&quot;请您选择可乐的数量：&quot;); num4=sc.nextInt(); singleMoney = customer.orderBeverage(num4); price=hamburgMoney+chickenWingsMoney+frenchFriesMoney+singleMoney; System.out.println(&quot;总计：&quot;+price); break; case 2: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐1：奥尔良烤堡+霸王薯条+可乐_50元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐2：香辣鸡腿堡+麻辣烤翅+可乐_40元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择套餐1的数量：&quot;); num5=sc.nextInt(); taocan1Money =customer.orderTaoCan1(num5); System.out.print(&quot;请您选择套餐2的数量：&quot;); num6=sc.nextInt(); taocan2Money =customer.orderTaoCan2(num6); price=taocan1Money+taocan2Money; System.out.println(&quot;总计：&quot;+price); &#125; &#125; //领取优惠券并付款找零 public void other()&#123; System.out.println(&quot;为迎接新老顾客的到来，本店特地准备了两种优惠券&quot;); System.out.println(&quot;---1.满45减5 ---2.满65减8&quot;); System.out.print(&quot;您是否需要优惠券？(y/n)&quot;); String b=sc.next(); if(&quot;y&quot;.equals(b)) &#123; if(price&gt;=45&amp;&amp;price&lt;65) //价格在45-65之间领取5元 &#123; price-=5; c=5; //5元优惠券 &#125; else if(price&gt;=65) //价格&gt;=65领取8元 &#123; price-=8; c=8; &#125; else System.out.println(&quot;您不能使用优惠券！&quot;); System.out.println(&quot;领取&quot;+c+&quot;元优惠券成功！您一共消费：&quot;+price+&quot;元&quot;); &#125; System.out.print(&quot;付款：&quot;); d=sc.nextInt(); e=d-price; System.out.println(&quot;找零：&quot;+e); &#125; //打印账单 public void paint()&#123; System.out.print(&quot;您需要打印账单吗？(y/n)&quot;); String m=sc.next(); if(&quot;y&quot;.equals(m))&#123; //用户需要打印小票 System.out.println(&quot;您的账单为：&quot;); switch(a)&#123; case 1: hamburgMoney=customer.orderHamburg(num1); chickenWingsMoney = customer.orderChickenWings(num2); frenchFriesMoney = customer.orderFrenchFries(num3); singleMoney = customer.orderBeverage(num4); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; case 2: taocan1Money =customer.orderTaoCan1(num5); taocan2Money =customer.orderTaoCan2(num6); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; &#125; try&#123; fully(); &#125;catch(Exception e)&#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; else if(&quot;n&quot;.equals(m))&#123; System.out.println(&quot;欢迎下次光临~&quot;); &#125; &#125; //在文件中打印小票 public void fully() throws Exception&#123; FileWriter pw=new FileWriter(&quot;zhangdan.txt&quot;,true); BufferedWriter bw=new BufferedWriter(pw); try &#123; switch(a) &#123; case 1: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;麻辣奥尔良烤堡 &quot;+&quot;单价：28 数量：&quot;+num1+&quot;合计：&quot;+hamburgMoney+&quot;\r\n&quot;); bw.write(&quot;奥尔良烤翅 &quot;+&quot;单价：5 数量：&quot;+num2+&quot;合计：&quot;+chickenWingsMoney+&quot;\r\n&quot;); bw.write(&quot;普通霸王薯条 &quot;+&quot;单价：8 数量：&quot;+num3+&quot;合计：&quot;+frenchFriesMoney+&quot;\r\n&quot;); bw.write(&quot;可乐饮料 &quot;+&quot;单价：10 数量：&quot;+num4+&quot;合计：&quot;+singleMoney+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; case 2: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;超值套餐1 &quot;+&quot;单价：50 数量：&quot;+num5+&quot;合计：&quot;+taocan1Money+&quot;\r\n&quot;); bw.write(&quot;超值套餐2 &quot;+&quot;单价：40 数量：&quot;+num6+&quot;合计：&quot;+taocan2Money+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;打印成功！欢迎下次光临~&quot;); &#125; &#125; 19.主函数MainApp 12345678910111213141516package inter.KFC;import java.util.*;import java.text.*; //获取当前系统时间public class MainApp &#123; public static void main(String[] args) &#123; Date date=new Date(); DateFormat fullFormat=DateFormat.getDateInstance(DateFormat.FULL); System.out.println(&quot;当前日期：&quot;+fullFormat.format(date)); //引用菜单类 MainMenu mainmenu=new MainMenu(); mainmenu.menu(); mainmenu.other(); mainmenu.paint(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种简单的程序设计模式实例]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.题目名称 (1)简单工厂模式 使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果传入参数M，则返回一个Man对象，如果传入参数W，则返回一个Woman对象，请实现该场景。现需要增加一个新的Robot类，如果传入参数R，则返回一个Robot对象，对代码进行修改并注意女娲的变化。 (2)工厂方法模式 海尔工厂(Haier)生产海尔空调(HaierAirCondition)，美的工厂(Midea)生产美的空调(MideaAirCondition) 。使用工厂方法模式描述该场景，绘制类图并编程实现。(3)抽象工厂模式 电脑配件生产工厂生产内存、CPU等硬件设备，这些内存、CPU的品牌、型号并不一定相同，根据下面的“产品等级结构-产品族”示意图，使用抽象工厂模式实现电脑配件生产过程并绘制相应的类图，绘制类图并编程实现。 2.题目分析 (1)简单工厂模式 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 &lt;1&gt;工厂角色(Nvwa)：实现所有实例的内部逻辑； &lt;2&gt;抽象产品角色(Person)：所有对象的父类，负责描述所有实例共有的公共接口； &lt;3&gt;具体产品角色(Man,Woman,Robot)：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实现； &lt;4&gt;XML配置文件(XMLUtilNvwa,Simple.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (2)工厂方法模式 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 &lt;1&gt;抽象产品(KongTiao)：产品对象同一的基类，或者是同一的接口； &lt;2&gt;具体产品(Haier,Midea)：各个不同的实例对象类； &lt;3&gt;抽象工厂(KongTiaoFactory)：所有的子类工厂类的基类，或是同一的接口； &lt;4&gt;具体工厂(HaierFactory,MideaFactory)：负责每个不同的产品对象的实际创建； &lt;5&gt;XML配置文件(XMLUtil,FactoryMethod.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (3)抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 产品等级结构：即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 &lt;1&gt;抽象工厂(ComputerFactory)：模式的核心，通常是接口或抽象类，其他的具体工厂类必须实现这个接口或继承这个抽象类； &lt;2&gt;具体工厂(macFactory,pcFactory)：直接在客户端的调用下创建产品的实例； &lt;3&gt;抽象产品(CPU,RAM)：工厂模式所创建的对象的父类，或他们共同的接口； &lt;4&gt;具体产品(pcCPU,macCPU,pcRAM,macRAM)：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。 &lt;5&gt;XML配置文件(XMLUtil,AbstractFactory.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 3.类图设计 (1)简单工厂模式： (2)工厂方法模式： (3)抽象工厂模式： 4.经验归纳 4.1遇到的问题 &lt;1&gt;对三种模式都不太熟悉，花费的时间较多 &lt;2&gt;不懂如何解析xml文档 &lt;3&gt;eclipse版本问题导致XMLUtil代码有错误，但可以运行 4.2心得体会 第一次编写程序设计模式的代码，刚开始觉得无从下手。对三种模式不熟悉，导致花费了较多的时间，所以一直在查资料。特别实在xml文档那块，我一直没搞懂为什么要写文档而不直接用输入输出流，结果发现是将参数保存在XML的配置文件中，这样修改参数的时候就没有必要修改任何Java源代码。但是这块还是挺薄弱的，写代码的时候也不能独立完成，还需要参考老师给的代码。第一个简单工厂模式挺简单的，第三个比较难（我觉得），所以要多练习抽象工厂模式的习题~ 附：源代码 (1)简单工厂模式 &lt;1&gt;抽象产品角色(父类):Person 12345package Nvwa;public interface Person&#123; public void make();&#125; &lt;2&gt;工厂角色(实现内部逻辑):Nvwa 1234567891011121314151617181920212223242526package Nvwa;public class Nvwa &#123; public static Person producePerson(String sex) throws Exception &#123; if(sex.equalsIgnoreCase(&quot;M&quot;)) //选择&apos;M&apos; &#123; System.out.println(&quot;造了一个男人！&quot;); return new Man(); //返回参数 &#125; else if(sex.equalsIgnoreCase(&quot;W&quot;))//选择&apos;W&apos; &#123; System.out.println(&quot;造了一个女人！&quot;); return new Woman(); &#125; else if(sex.equalsIgnoreCase(&quot;R&quot;))//选择&apos;R&apos; &#123; System.out.println(&quot;造了一个机器人！&quot;); return new Robet(); &#125; else &#123; throw new Exception(&quot;对不起，女娲正在忙，没空造人！&quot;); &#125; &#125;&#125; &lt;3&gt;具体产品角色(实现类):Man,Woman,Robet: Man: 12345678package Nvwa;public class Man implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造男人...&quot;); &#125;&#125; Woman: 12345678package Nvwa;public class Woman implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造女人...&quot;); &#125;&#125; Robot: 12345678package Nvwa;public class Robet implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造机器人...&quot;); &#125;&#125; &lt;4&gt;XML配置文件(方便修改参数):XMLUtilNvwa,Simple.xml XMLUtilNvwa： 12345678910111213141516171819202122232425262728293031XMLUtilNvwa：package Nvwa;import javax.xml.parsers.*;import org.w3c.dom.*;//import org.xml.sax.SAXException;import java.io.*;public class XMLUtilNvwa &#123; //该方法用于从XML配置文件中提取名称，并返回该名称 public static String getSexName() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;Simple.xml&quot;)); //获取包含名称的文本节点 NodeList nl = doc.getElementsByTagName(&quot;sexName&quot;); Node classNode=nl.item(0).getFirstChild(); String sexName=classNode.getNodeValue().trim(); return sexName; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; Simple.xml: 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;sexName&gt;M&lt;/sexName&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 123456789101112131415161718package Nvwa;public class Client &#123; public static void main(String args[]) &#123; try &#123; Person pe; String sexName=XMLUtilNvwa.getSexName(); pe=Nvwa.producePerson(sexName); pe.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (2)工厂方法模式 &lt;1&gt;抽象产品：KongTiao 12345package FactoryMethod;public interface KongTiao &#123; public void make();&#125; &lt;2&gt;具体产品：Haier,Midea Haier： 12345678package FactoryMethod;public class Haier implements KongTiao&#123; public void make() &#123; System.out.println(&quot;海尔空调正在使用...&quot;); &#125;&#125; Midea： 12345678package FactoryMethod;public class Midea implements KongTiao&#123; public void make() &#123; System.out.println(&quot;美的空调正在使用...&quot;); &#125;&#125; &lt;3&gt;抽象工厂：KongTiaoFactory 12345package FactoryMethod;public interface KongTiaoFactory &#123; public KongTiao produceKT();&#125; &lt;4&gt;具体工厂：HaierFactory,MideaFactory HaierFactory： 123456789package FactoryMethod;public class HaierFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---海尔工厂正在生产海尔空调 &quot;); return new Haier(); &#125;&#125; MideaFactory： 12345678package FactoryMethod;public class MideaFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---美的工厂正在生产美的空调 &quot;); return new Midea(); &#125; &lt;5&gt;XML配置文件：XMLUtil,FactoryMethod.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123; //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;FactoryMethod.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; FactoryMethod.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;FactoryMethod.HaierFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 1234567891011121314151617package FactoryMethod;public class Client &#123; public static void main(String[] args) &#123; try&#123; KongTiao kt; KongTiaoFactory fa; fa=(KongTiaoFactory)XMLUtil.getBean(); kt=fa.produceKT(); kt.make(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (3)抽象工厂模式 &lt;1&gt;抽象工厂：ComputerFactory 123456package AbstractFactory;public interface ComputerFactory &#123; public CPU produceCPU(); public RAM produceRAM();&#125; &lt;2&gt;具体工厂：macFactory,pcFactory macFactory： 12345678910111213141516171819package AbstractFactory;public class macFactory implements ComputerFactory&#123; //生产macCPU public CPU produceCPU() &#123; System.out.println(&quot;生产了macCPU...&quot;); //CPU macCPU; return new macCPU(); &#125; //生产macRAM public RAM produceRAM() &#123; System.out.println(&quot;生产了macRAM...&quot;); return new macRAM(); &#125;&#125; pcFactory： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; &lt;3&gt;抽象产品：CPU,RAM CPU： 12345package AbstractFactory;public interface CPU &#123; public void make();&#125; RAM： 12345package AbstractFactory;public interface RAM &#123; public void make();&#125; &lt;4&gt;具体产品：pcCPU,macCPU,pcRAM,macRAM pcCPU： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; macCPU： 12345678package AbstractFactory;public class macCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;macCPU&quot;); &#125;&#125; pcRAM： 12345678package AbstractFactory;public class pcRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;pcRAM&quot;); &#125;&#125; macRAM： 12345678package AbstractFactory;public class macRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;macRAM&quot;); &#125;&#125; &lt;5&gt;XML配置文件：XMLUtil,AbstractFactory.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package AbstractFactory;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123;//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;AbstractFactory.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125;catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; AbstractFactory.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;AbstractFactory.macFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 12345678910111213141516171819202122package AbstractFactory;public class Client &#123; public static void main(String[] args) &#123; try &#123; ComputerFactory fac; CPU cpu; RAM ram; fac=(ComputerFactory)XMLUtil.getBean(); cpu=fac.produceCPU(); cpu.make(); ram=fac.produceRAM(); ram.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建RPG游戏角色]]></title>
    <url>%2F2019%2F04%2F17%2FJava%E5%88%9B%E5%BB%BARPG%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[◆题目名称 创建RPG游戏角色 ◆题目分析 该程序需要用到有关类与对象的知识点，所以不能使用C语言来编写代码，这里我选择Java语言。本题目要求的游戏角色应有以下属性：名字、性别、种族、职业、力量、敏捷、体力、智力、智慧、生命值和魔法值。本题目要求力量、敏捷、体力、智力和智慧要求是随机值（利用随机数函数来取得随机数），但是五项属性的总和应该是100，并且应该和职业相关。例如狂战士的体力和力量就要比较高，而巫师需要较高的智力，而祭司则需要较高的智慧。各职业初始属性的大致比例应遵从下表： 职业/属性 力量 敏捷 体力 智力 智慧 狂战士 40 20 30 5 5 圣骑士 25 15 30 20 10 刺客 20 35 20 15 10 猎手 15 40 15 10 20 祭司 15 20 15 35 15 巫师 10 20 10 20 40 例如，前面示意图中的祭司的初始属性，大致满足该比例，但是应该是随机的。然后利用属性值计算生命值和魔法值。 最后向用户显示该角色的所有信息，将用户创建角色的相关信息写入文件保存。 ◆算法构造 &lt;1&gt;玩家选择1，则进入游戏；选择2，可以查看游戏规则；选择3，则游戏结束。 &lt;2&gt;选择1：玩家先输入角色姓名、性别、种族以及职业，根据种族和职业的限制表判断玩家是否可以使用该职业，若不能则重新选择职业； &lt;3&gt;利用随机函数分别生成力量、敏捷、体力、智力和智慧五项属性，并将五项属性的总和控制在100，并且属性值和职业相关。可以由(int)(X+Math.random()_10-5)可以得到符合条件的属性值，其中X表示表1中的属性限定值，并计算生命值和魔法值：生命值=体力_20、魔法值=（智力+智慧）*10； &lt;4&gt;打印所有的信息并向用户显示出来； &lt;5&gt;将用户创建角色的相关信息写入txt文件保存。 ◆算法实现 写入文件代码： 123456789101112131415161718192021222324public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125; ◆调试及运行结果 ◆◆调试结果 ◆运行结果 ◆◆文件保存情况 ◆经验归纳 ◆◆遇到的问题 &lt;1&gt;对于Java中的类和对象用的还不是很熟练(还在努力学习中) &lt;2&gt;Java引用写入文件方法出问题(已解决) &lt;3&gt;Java写入文件方法内部出现异常(已解决) &lt;4&gt;IO流未声明(已解决) ◆◆心得体会 用Java写这个程序，让我查了不少有关Java的知识点。在类与对象那块还不太熟悉，其中，有一些知识点是值得记录的： ①访问另一个类中的某个方法：Start g=new Start();g.start(); ②对象引用：Random r=new Random();r.n=name; ③随机函数生成某个值：strength=(int)(40+Math.random()*10-5)(40是限制条件) ④调用写入文件方法： 12345try &#123; REFile(occ);&#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); 在百度文库查找资料的时候我发现可以将这个代码优化，即编为小游戏的形式，我打算找时间写一下。 附：源代码(部分代码参考百度文库) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package game;import java.io.*;import java.util.Scanner;import java.io.FileWriter;public class First &#123; public static void main(String[] args)&#123; //菜单 System.out.println(&quot;这是一个RPG游戏&quot;); System.out.println(&quot;1.开始游戏&quot;); System.out.println(&quot;2.游戏规则&quot;); System.out.println(&quot;3.结束游戏&quot;); System.out.print(&quot;请输入您想进行的操作：(1-3)&quot;); Scanner x=new Scanner(System.in); int num=x.nextInt(); switch(num)&#123; case 1: Start g=new Start(); g.start(); //访问Start类中的start方法开始创建角色 break; case 2: Rule r=new Rule(); r.rule(); //访问Rule类中的rule方法查看规则 break; default: System.out.println(&quot;游戏结束!&quot;); System.exit(0); //游戏结束标识 &#125; &#125;&#125;//开始游戏class Start&#123; int occ=0; String name; public void start()&#123; System.out.print(&quot;请输入您游戏角色的姓名：&quot;); Scanner a=new Scanner(System.in); String name=a.next(); System.out.print(&quot;请选择您游戏角色的性别：(男或女)&quot;); Scanner b=new Scanner(System.in); String sex=b.next(); System.out.print(&quot;请选择您游戏角色的种族：(1.人类,2.精灵,3.兽人,4.矮人,5.元素)&quot;); Scanner c=new Scanner(System.in); int race=c.nextInt(); switch(race)&#123; //职业选择 case 1: //种族为人类 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=1&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1-6之间的数字选择职业！！&quot;); &#125; break; case 2: //种族为精灵 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=3&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入3-6之间的数字选择职业！！&quot;); &#125; break; case 3: //种族为兽人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==4||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,4,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 4: //种族为矮人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==2||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,2,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 5: //种族为元素 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==5||occ==6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入5-6之间的数字选择职业！！&quot;); &#125; break; &#125; Random r=new Random(); r.n=name; //将姓名、性别、种族对象引用到Random类中 r.s=sex; r.ra=race; r.random(occ);//将职业传递到Random类的random方法中 &#125;&#125;//class Random&#123; String n; String s; int ra; int strength=0; //力量 int smart=0; //敏捷 int body=0; //体力 int talent=0; //智力 int wisdom=0; //智慧 int life=0; //生命值 int magic=0; //魔法值 public void random(int occ)&#123; //随机函数生成各个值 System.out.println(occ); if(occ==1) &#123; strength=(int)(40+Math.random()*10-5);//随机函数生成符合题目条件的各个值 smart=(int)(20+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(5+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==2)&#123; strength=(int)(25+Math.random()*10-5); smart=(int)(15+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==3)&#123; strength=(int)(20+Math.random()*10-5); smart=(int)(35+Math.random()*10-5); body=(int)(20+Math.random()*10-5); talent=(int)(15+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==4)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(40+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(10+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==5)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(35+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==6)&#123; strength=(int)(10+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(10+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; life=body*20; //计算生命值和魔法值 magic=(talent+wisdom)*10; print(occ); //调用打印方法 try &#123; //调用写入文件方法 REFile(occ); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //打印 public void print(int occ)&#123; System.out.println(&quot;* * * * * * * * * * * * *&quot;); System.out.println(&quot;* 姓名：&quot;+n+&quot; *&quot;); System.out.println(&quot;* 性别：&quot;+s+&quot; *&quot;); System.out.println(&quot;* 种族：&quot;+ra+&quot; *&quot;); System.out.println(&quot;* 职业：&quot;+occ+&quot; *&quot;); System.out.println(&quot;* 力量：&quot;+strength+&quot; *&quot;); System.out.println(&quot;* 敏捷：&quot;+smart+&quot; *&quot;); System.out.println(&quot;* 体力：&quot;+body+&quot; *&quot;); System.out.println(&quot;* 智力：&quot;+talent+&quot; *&quot;); System.out.println(&quot;* 智慧：&quot;+wisdom+&quot; *&quot;); System.out.println(&quot;* 生命值：&quot;+life+&quot; *&quot;); System.out.println(&quot;* 魔法值：&quot;+magic+&quot; *&quot;); System.out.println(&quot;* * * * * * * * * * * * *&quot;); &#125; //写入文件 public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125;//游戏规则class Rule&#123; public void rule()&#123; System.out.println(&quot;很多职业会限制某些种族选择,种族和职业的限制情况如下：(下表均为不允许)&quot;); System.out.println(&quot;┎---------------------------------------------┒&quot;); System.out.println(&quot;│ 种 类 职 业 │&quot;); System.out.println(&quot;│ 精灵 狂战士、圣骑士 │&quot;); System.out.println(&quot;│ 兽人 圣骑士、刺客、巫师 │&quot;); System.out.println(&quot;│ 矮人 刺客、猎手、巫师 │&quot;); System.out.println(&quot;│ 元素 狂战士、圣骑士、刺客、猎手 │&quot;); System.out.println(&quot;┖---------------------------------------------┚&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24点游戏简单版]]></title>
    <url>%2F2019%2F04%2F10%2F24%E7%82%B9%E6%B8%B8%E6%88%8F%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[●题目名称 24点游戏（经典的纸牌益智游戏） ●题目分析 随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，可以利用穷举法列出4个数字加减乘除的各种可能性，包括括号的算法，并且要利用循环控制计算范围，防止出现重复的表达式。 ●算法构造 &lt;1&gt;利用随机函数生成4个随机数 &lt;2&gt;将4个数所有可能的顺序列举，并调用计算函数 &lt;3&gt;循环调用使4个数字分别进行两两运算，并将表达式储存在一个数组中 &lt;4&gt;将3个运算符的顺序进行调整，调用加减乘除运算操作函数计算并输出 ●算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define N 10 //定义四个数的取值最大为10double operate(double a,double b,char ch) //加减乘除运算操作函数 &#123; if(ch==&apos;+&apos;) return a+b; else if(ch==&apos;-&apos;) return a-b; else if(ch==&apos;/&apos;) return a/b; else if(ch==&apos;*&apos;) return a*b; else return 0; &#125; int precede(char a,char b) //判断优先级函数 &#123; if(a==&apos;+&apos;||a==&apos;-&apos;) &#123; if(b==&apos;*&apos;||b==&apos;/&apos;) return 1; if(b==&apos;+&apos;||b==&apos;-&apos;) return 0; &#125; if(a==&apos;*&apos;||a==&apos;/&apos;) return 0; return 0; &#125; int check(double A,double B,double C,double D) &#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; //数组储存运算符 double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) //循环调用使A,B进行运算操作,d[]为运算符,运算结果存到a[]中 a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); //A,B运算的结果和C运算，结果存到b[][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //循环防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); //A,B,C运算的结果和D运算，结果存到c[][][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 return 1; &#125; return 0; &#125; void SHOW(double A,double B,double C,double D) //输出函数，运算过程与check()函数相同&#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 &#123; if(precede(d[i],d[j])) //调用判断优先级函数，判断第一、第二个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f)%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); //(AB)CD printf(&quot;\n&quot;); &#125; else if(precede(d[j],d[k])) //调用判断优先级函数，判断第二、第三个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f%c%.0f)%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; else //调用判断优先级函数，判断第一、第三个运算符可能出现的情况 &#123; printf(&quot;%.0f%c%.0f%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; &#125; &#125; &#125; void game_24() &#123; double A=0,B=0,C=0,D=0; char j; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; srand((unsigned)time(NULL)); while(1) &#123; while((A==0||B==0)||(C==0||D==0)) //当A,B,C,D不为0时，4个随机数赋值给A,B,C,D &#123; A=rand()%10*1.0; B=rand()%10*1.0; C=rand()%10*1.0; D=rand()%10*1.0; &#125; if((check(A,B,C,D)||check(B,C,A,D))||(check(C,B,D,A)||check(D,A,B,C))) break; else &#123; A=0; B=0; C=0; D=0; &#125; &#125; printf(&quot;随机生成四个数为：&quot;); printf(&quot;%.0f %.0f %.0f %.0f\n&quot;,A,B,C,D); printf(&quot;是否要看答案(y/n):&quot;); while(1) &#123; scanf(&quot;%s&quot;,&amp;j); if(j==&apos;y&apos;||j==&apos;Y&apos;) &#123; SHOW(A,B,C,D); //将24种可能列举，并调用函数计算并输出结果 SHOW(A,B,D,C); SHOW(A,D,B,C); SHOW(A,D,C,B); SHOW(A,C,B,D); SHOW(A,C,D,B); SHOW(B,A,C,D); SHOW(B,A,D,C); SHOW(B,C,A,D); SHOW(B,C,D,A); SHOW(B,D,A,C); SHOW(B,D,C,A); SHOW(C,A,B,D); SHOW(C,A,D,B); SHOW(C,B,A,D); SHOW(C,B,D,A); SHOW(C,D,A,B); SHOW(C,D,B,A); SHOW(D,A,B,C); SHOW(D,A,C,B); SHOW(D,B,A,C); SHOW(D,B,C,A); SHOW(D,C,A,B); SHOW(D,C,B,A); break; &#125; else printf(&quot;是否要看答案(y/n):&quot;); &#125; &#125; void menu() &#123; int i; while(1) &#123; system(&quot;cls&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 智力游戏24点 *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 1.开始游戏. *\n&quot;); printf(&quot;* 2.退出游戏. *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;你准备好了吗？\n&quot;); printf(&quot;输入你的选择:&quot;); scanf(&quot;%d&quot;,&amp;i); if(i==3) break; switch(i) &#123; case 1: game_24(); //开始游戏 system(&quot;PAUSE&quot;); break; default: printf(&quot;error input!\n&quot;); system(&quot;PAUSE&quot;); &#125; &#125; &#125; void main() &#123; menu(); &#125; ●经验归纳 ●●遇到的问题 &lt;1&gt;在防止重复问题上有点迷茫，已解决 &lt;2&gt;对数据结构栈不够清楚，未写提高要求 ●●心得体会 感觉自己对数据结构栈的知识点很薄弱，需要加强。而且在解决基本要求时考虑的不够全面，刚开始没有考虑到防止重复的问题，还有出现过进入无限循环的问题，好在均已解决，但是随机函数生成4个数字的时候，4个数字可能会出现重复的情况，我在网上找了一下，有不重复的随机函数代码，在这里不赘述了。 个人认为这个代码还可以优化~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于文件的C语言学生信息管理系统]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[●题目名称 C语言学生信息管理系统 ●题目分析 将文件引入学生信息管理系统，完善学生信息数据的处理，包括信息的读取、保存、刷新。编写与文件有关的程序，需要考虑将对文件以什么方式操作，文件能否被打开，文件在什么位置。为了程序的可读性，一般将文件的读取、存盘、操作自定义为函数。 ●算法构造 ●●刷新学生信息update()函数 &lt;1&gt;以只读方式打开指定文件，判断文件是否为空，若为空，则提示：文件为空！ &lt;2&gt;循环读入学生信息，并累加当前记录的学生人数n &lt;3&gt;输出提示：刷新成功！ &lt;4&gt;关闭文件 ●●查询学生信息seek()函数 &lt;1&gt;用户输入要进行的操作:1.按学号查询；2.按姓名查询；3.退出本菜单 &lt;2&gt;选择1：输入要查询的学生的学号；判断输入的学号和存好的学号一致；一致则输出学生的信息，不一致则输出：该学号不存在！ &lt;3&gt;选择2：输入要查询的学生的姓名；判断输入的姓名和存好的姓名一致；一致则输出学生的信息，不一致则输出：该姓名不存在！ ●●修改学生信息modify()函数 &lt;1&gt;输入要修改的学生的学号 &lt;2&gt;比较输入的学号和文件存好的学号是否一致，选择要进行的操作编号：1.修改姓名；2.修改年龄；3.修改性别；4.修改C语言成绩；5.修改高等数学成绩；6.修改大学英语成绩；7.退出本菜单 &lt;3&gt;选择1：输入新的姓名s2；新的姓名s2替换原来的姓名；保存新的姓名 &lt;4&gt;选择2：输入新的年龄age；新的姓名age替换原来的年龄；保存新的年龄 &lt;5&gt;选择3：输入新的性别sex1；新的性别sex1替换原来的性别；保存新的性别 &lt;6&gt;选择4：输入新的C语言成绩score1；新的C语言成绩score1替换原来的C语言成绩；保存新的C语言成绩 &lt;7&gt;选择5：输入新的高等数学成绩score1；新的高等数学成绩score1替换原来的高等数学成绩；保存新的高等数学成绩 &lt;8&gt;选择6：输入新的大学英语成绩score1；新的大学英语成绩score1替换原来的姓名；保存新的大学英语成绩 &lt;9&gt;选择7：返回主菜单 ●●插入学生信息函数insert()函数 &lt;1&gt;输入待增加的学生数n &lt;2&gt;循环依次输入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;将这些信息依次写入文件 &lt;4&gt;提示：添加成功！ &lt;5&gt;调用按学号排序函数，将信息排序好 &lt;5&gt;关闭文件 ●●按学号删除信息del()函数 &lt;1&gt;输入要删除学生的学号s1 &lt;2&gt;初始化flag=0，进入循环，比较输入的学号和文件记录的学号是否一致，若一致则令flag=1，循环将后面的学生记录向前移动 &lt;3&gt;判断flag=0，提示：该学号不存在！ &lt;4&gt;判断flag=1，学生人数-1并保存，提示：删除成功！ &lt;5&gt;关闭文件 ●●显示当前信息display()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次输出每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●●保存当前学生信息fileWrite()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次写入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432#include&lt;stdio.h&gt; /*I/O函数*/#include&lt;stdlib.h&gt; /*其它说明*/#include&lt;string.h&gt; /*字符串函数*/#define max 100#define LEN 15 /* 学号和姓名最大字符数,实际请更改*/#define N 100 /* 最大学生人数,实际请更改*/int k=1,n=0, m=0;/* n代表当前记录的学生人数*///学生信息结构体struct student &#123; char no[LEN];//学号 char name[LEN];//姓名 char sex[LEN];//性别 int age;//年龄 float C;//c语言成绩 float M;//数学成绩 float E;//英语成绩&#125;stu[N];void fileWrite();//系统帮助及说明void help() &#123; printf("\n0.欢迎使用系统帮助！\n"); printf("\n1.初次进入系统后,请先选择增加学生信息;\n"); printf("\n2.按照菜单提示键入数字代号;\n"); printf("\n3.增加学生信息后,切记保存;\n"); printf("\n4.谢谢您的使用！\n");&#125;//刷新学生信息void update()&#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s,%s,%s,%d,%f,%f,%f\n",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) //从文件中读取信息 &#123; j++; &#125; n=j; printf("\n 提示：刷新成功!!! \n"); fclose(fp);&#125;//查询学生信息void seek() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i=0,item,flag; char s1[LEN+1]; /* 以姓名和学号最长长度+1为准*/ printf("----------------------\n"); printf("-----1.按学号查询-----\n"); printf("-----2.按姓名查询-----\n"); printf("-----3.退出本菜单-----\n"); printf("----------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); //用户输入要进行的操作 flag=0; switch(item) &#123; case 1: printf("请输入要查询的学生的学号:\n"); scanf("%s",&amp;s1); for(i=0; i&lt;n; i++) //n代表当前记录的学生人数 if(strcmp(s1,stu[i].no)==0) //strcmp()是字符串比较函数，判断输入的学号和存好的学号一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的学号和存好的学号不一致 printf("该学号不存在！\n"); break; case 2: printf("请输入要查询的学生的姓名:\n"); scanf("%s",&amp;s1); //输入学生姓名 for(i=0; i&lt;n; i++) if(strcmp(stu[i].name,s1)==0) //输入的姓名和存好的姓名一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的姓名和存好的姓名不一致 printf("该姓名不存在！\n"); break; case 3: return; default: printf("请在1-3之间选择\n"); &#125; &#125;&#125;//修改学生信息void modify() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) &#123; printf("\n 警告：打开文件错误，请退出重新打开！\n"); system("pause"); exit(0); &#125; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,item=0,num; int age; char sex1[4],s1[LEN+1],s2[LEN+1]; /* 以姓名和学号最长长度+1为准*/ float score1; printf("请输入要修改的学生的学号:"); scanf("%s",s1); for(i=0;i&lt;n;i++) &#123; if(strcmp(stu[i].no,s1)==0) /*比较字符串是否相等*/ &#123; num=i; //给num赋i值 printf("------------------\n"); printf("1.修改姓名\n"); printf("2.修改年龄\n"); printf("3.修改性别\n"); printf("4.修改C语言成绩\n"); printf("5.修改高等数学成绩\n"); printf("6.修改大学英语成绩\n"); printf("7.退出本菜单\n"); printf("------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); switch(item) &#123; case 1: printf("请输入新的姓名:"); scanf("%s",s2); strcpy(stu[num].name,s2); //strcpy()是字符串复制函数，将新输入的值赋给原先的值 fileWrite(); break; case 2: printf("请输入新的年龄:"); scanf("%d",&amp;age); stu[num].age=age; fileWrite(); break; case 3: printf("请输入新的性别:"); scanf("%s",&amp;sex1); strcpy(stu[num].sex,sex1); fileWrite(); break; case 4: printf("请输入新的C语言成绩:"); scanf("%d",&amp;score1); stu[num].C=score1; fileWrite(); break; case 5: printf("请输入新的高等数学成绩:"); scanf("%d",&amp;score1); stu[num].M=score1; fileWrite(); break; case 6: printf("请输入新的大学英语成绩:"); scanf("%d",&amp;score1); stu[num].E=score1; fileWrite(); break; case 7: return; default: printf("请在1-7之间选择\n"); &#125; &#125; &#125; else &#123; printf("没有该学生学号!!!"); &#125; &#125;&#125;//按学号排序函数void sort()&#123; int i,j,*p,*q,s; char temp[LEN+1],ctemp[LEN]; float *x,*y,z; float *a,*b,c; float *k,*l,h; for(i=0;i&lt;n-1;i++) &#123; for(j=n-1;j&gt;i;j--) if(strcmp(stu[j-1].no,stu[j].no)&gt;0) &#123; strcpy(temp,stu[j-1].no); strcpy(stu[j-1].no,stu[j].no); strcpy(stu[j].no,temp); strcpy(temp,stu[j-1].name); strcpy(stu[j-1].name,stu[j].name); strcpy(stu[j].name,temp); p=&amp;stu[j-1].age; q=&amp;stu[j].age; s=*q; *q=*p; *p=s; strcpy(ctemp,stu[j-1].sex); strcpy(stu[j-1].sex,stu[j].sex); strcpy(stu[j].sex,ctemp); x=&amp;stu[j-1].C; y=&amp;stu[j].C; z=*x; *x=*y; *y=z; a=&amp;stu[j-1].M; b=&amp;stu[j].M; c=*a; *a=*b; *b=c; k=&amp;stu[j-1].E; l=&amp;stu[j].E; h=*k; *k=*l; *l=h; &#125; &#125;&#125;//插入学生信息函数void insert() &#123; int i; printf("请输入待增加的学生数:"); scanf("%d",&amp;n); FILE * fp; if((fp=fopen("student.txt","at"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; printf("\n请输入第%d个学生的学号：",i+1); scanf("\n%s",&amp;stu[i].no); printf("\n请输入第%d个学生的姓名：",i+1); scanf("%s",&amp;stu[i].name); printf("\n请输入第%d 个学生的性别：",i+1); scanf("%s",&amp;stu[i].sex); printf("\n请输入第%d 个学生的年龄:",i+1); scanf("%d",&amp;stu[i].age); printf("\n请输入第%d 个学生的C语言成绩:",i+1); scanf("%d",&amp;stu[i].C); printf("\n请输入第%d 个学生的高等数学成绩:",i+1); scanf("%d",&amp;stu[i].M); printf("\n请输入第%d 个学生的大学英语成绩:",i+1); scanf("%d",&amp;stu[i].E); sort(); //调用按学号排序函数 //写入文件 fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; printf("\n添加成功!!!\n"); fclose(fp);&#125;//按学号删除信息void del() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f ",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,flag=0; char s1[LEN+1]; printf("请输入要删除学生的学号:\n"); scanf("%s",s1); for(i=0; i&lt;n; i++) &#123; if(strcmp(stu[i].no,s1)==0) //比较输入的学号和记录的学号一致 &#123; flag=1; for(j=i; j&lt;n-1; j++) &#123; stu[j]=stu[j+1]; //后面的学生记录向前移动 &#125; &#125; &#125; if(flag==0) //比较输入的学号和记录的学号不一致 printf("该学号不存在！\n"); if(flag==1) //判断flag的值为1，则成功删除 &#123; n--; //删除成功后，学生人数-1 fileWrite(); fclose(fp); printf("删除成功,显示结果请选择菜单\n"); &#125;&#125;//显示当前信息void display() &#123; int i=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s %s %s %d %f %f %f",stu[i].no,stu[i].name,stu[i].sex,&amp;stu[i].age,&amp;stu[i].C,&amp;stu[i].M,&amp;stu[i].E)==7) &#123; i++; &#125; n=i; //记录文件中数据的行数 printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); for(i=0;i&lt;n;i++) //依次输出学生信息 &#123; printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp);&#125;//保存当前学生信息void fileWrite()&#123; FILE *fp; int i; if((fp=fopen("student.txt","w"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp); printf("保存成功!!!");&#125; //界面void menu() &#123; int num; printf(" \n\n \n\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf(" * 学生信息管理系统 *\n"); printf(" * *\n"); printf(" * * * * * * * *系统功能菜单* * * * * * * *\n"); printf(" * -------------------------------------------- *\n"); printf(" * *\n"); printf(" * 0.系统帮助及说明 | 1.刷新学生信息 *\n"); printf(" * *\n"); printf(" * 2.查询学生信息 | 3.修改学生信息 *\n"); printf(" * *\n"); printf(" * 4.增加学生信息 | 5.按学号删除信息 *\n"); printf(" * *\n"); printf(" * 6.显示当前信息 | 7.保存当前学生信息 *\n"); printf(" * *\n"); printf(" * 8.退出系统 *\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n"); printf("请选择菜单编号:"); scanf("%d",&amp;num); switch(num) &#123; case 0: help(); break; case 1: update(); break; case 2: seek(); break; case 3: modify(); break; case 4: insert(); break; case 5: del(); break; case 6: display(); break; case 7: fileWrite(); break; case 8: k=0; break; default: printf("请在0-8之间选择\n"); &#125;&#125;//主函数 int main() &#123; while(k) &#123; menu(); &#125; system("pause"); return 0;&#125; ●经验归纳 ●●遇到的问题 程序无法读取文件信息：对文件的概念不清楚，文件的读取中各个数据之间不能用逗号隔开 ●●算法优化 &lt;1&gt;将主函数写到子函数后面，删去函数声明 &lt;2&gt;利用结构体，使学生信息更加结构化 &lt;3&gt;新增按学号排序函数，用户在增加了学生信息后，调用该函数，将文件中学生信息按学号排序好 &lt;4&gt;优化删除学生信息函数，直接将后面的学生记录向前移动 &lt;5&gt;将每个涉及文件的子函数都加入了文件读取功能，目的是进行相应操作时不必每次都要先执行刷新函数 &lt;6&gt;优化修改学生信息函数，每次修改完都调用保存函数，实现自动保存 ●●心得体会 学生信息管理系统是我们在学习C语言时的典例，但是我感觉在文件读取方面基础还是比较薄弱，一些基础性的知识点还是不能记住，所以以后要多多练习与读取文件有关的习题。]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求N个数的最大公约数和最小公倍数&&Hankson问题]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%B1%82N%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%26%26Hankson%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[● 题目名称 &lt;1&gt;求N个数的最大公约数和最小公倍数 &lt;2&gt;计算出Hankson的“逆问题”的答案 ● 题目分析 &lt;1&gt;求N个数的最大公约数和最小公倍数：可以先求出第一个数和第二个数的最大公约数和最小公倍数，再将这个最大公约数和最小公倍数与下一个数计算出新的最大公约数和最小公倍数，以此类推 &lt;2&gt;计算出Hankson的“逆问题”的答案：先输入组数，再根据组数以每组4个数循环输入，然后判断输入的四个数是否满足条件，接着再调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件，若满足，则累加，最后输出累加的结果 ● 算法构造 ● ● 求N个数的最大公约数和最小公倍数 &lt;1&gt;输入要计算最大公约数和最小公倍数的整数个数 &lt;2&gt;循环输入整数 &lt;3&gt;调用函数，求出这些整数的最大公约数和最小公倍数 &lt;4&gt;先计算出两个数的最大公约数（最小公倍数），再用该最大公约数（最小公倍数）和下一个数求最大公约数（最小公倍数），以此类推 &lt;5&gt;输出这些整数的最大公约数和最小公倍数 ● ● 计算出Hankson的“逆问题”的答案 &lt;1&gt;输入组数 &lt;2&gt;每组输入四个数，判断是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;3&gt;循环依次输入各组，每组4个数 &lt;4&gt;判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;5&gt;循环计算有多少个满足条件的数，调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件 &lt;6&gt;输出累加的数 ● 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;//辗转相除法求两个数的最大公约数int max1(int a,int b) &#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;//求n个数的最大公约数int max2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; z=max1(x,y); //先计算出两个数的最大公约数，再用该最大公约数和下一个数求最大公约数，以此类推 for(int i=2;i&lt;n;i++) z=max1(z,a[i]); return z;&#125; //求两个数的最小公倍数int min1(int a,int b) &#123; int max1(int a,int b); //自定义函数返回值类型 int temp; temp=max1(a,b); //再次调用自定义函数，求出最大公约数 return (a*b/temp); //返回最小公倍数到主调函数处进行输出&#125;//求n个数的最小公倍数int min2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; //与n个数的最大公约数同理 z=min1(x,y); for(int i=2;i&lt;n;i++) z=min1(z,a[i]); return z;&#125;void main()&#123; int n=0,x=0,max=0,min=0,b,sum=0,i=0; int c[4]; int a[]=&#123;0&#125;; printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* 1.输入n个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.计算出Hankson的“逆问题”的答案. *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x&lt;1||x&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;x); &#125; switch(x) &#123; case 1: printf(&quot;请输入你想要计算的整数个数（大于1）：&quot;); scanf(&quot;%d&quot;,&amp;n); //输入要计算最大公约数和最小公倍数的整数个数 printf(&quot;请依次输入整数：\n&quot;); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //循环输入整数 max=max2(a,n); //调用函数，求出这些整数的最大公约数 min=min2(a,n); //调用函数，求出这些整数的最小公倍数 printf(&quot;这些数的最大公约数为：%d\n&quot;,max); printf(&quot;这些数的最小公倍数为：%d\n&quot;,min); break; case 2: printf(&quot;请输入数据的组数：&quot;); scanf(&quot;%d&quot;,&amp;b); //输入组数 printf(&quot;每组输入四个数，要求：保证第一个数能被第二个数整除，第三个数能被第四个数整除：\n&quot;); for(;b&gt;0;b--) //循环依次输入b个组 &#123; for(i=0;i&lt;4;i++) //每组4个数 &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; if(c[0]%c[1]!=0||c[3]%c[2]!=0) //判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &#123; printf(&quot;输入不符合条件，请重新输入：\n&quot;); for(i=0;i&lt;4;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; &#125; for(int y=0;y&lt;=c[3];y++) //循环计算有多少个满足条件的数 &#123; if(max1(y,c[0])==c[1]&amp;&amp;min1(y,c[2])==c[3]) //调用计算两个数的最大公约数和最小公倍数的函数，判断y是否满足条件 sum++; &#125; printf(&quot;一共有%d个数满足条件\n&quot;,sum); sum=0; //累加sum初始化 &#125; &#125;&#125; ● 经验归纳 ● ● 遇到的问题 &lt;1&gt;习惯了计算两个数的最大公约数和最小公倍数，对N个数迷茫了… &lt;2&gt;最大公约数和最小公倍数计算有误 &lt;3&gt;提高要求要输入的那四个数的限制条件运用不当，审题不清，导致频繁出错 &lt;4&gt;在一次循环之后未将累加的值初始化，导致下一次循环完毕后的结果有误 ● ● 心得体会 以前都是计算两个数的最大公约数和最小公倍数，这次要计算n个数的最大公约数和最小公倍数，我其实运用的还是计算两个数的那个思想，就是加入了函数调用。 感觉自己有时候还挺粗心的（也可能是代码敲久了有点晕hhh），还有就是提高要求把我卡住了。。完全不知道逆着怎么求…查了一些资料，然后和一起去图书馆敲代码的同学讨论了一下，大体有思路了，但只要写程序就有错误。。。。 失误挺多的，希望自己能在以后的程序生涯里越来越棒，小细节都可以注意到~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JAVA编写奇数累加和猜数字小游戏代码（包含JAVA产生随机数）]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8JAVA%E7%BC%96%E5%86%99%E5%A5%87%E6%95%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%8C%9C%E6%95%B0%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8C%85%E5%90%ABJAVA%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.题目名称： 奇数累加、猜数字小游戏 2.题目要求： 求自然数1-99的所有奇数累加的和； 计算机自动生成答案，玩家手动输入其猜想的数字，判断玩家是否猜对。 3.算法分析： 3.1奇数累加 （1）利用for循环，遍历自然数并限制累加范围在1-99之内 （2）遍历过程中，判断正在遍历的自然数是否奇数 （3）如果是奇数，则进行累加 3.2猜数字小游戏 （1）利用随机数产生一个1-100的整数，即为正确答案 （2）玩家输入一个整数 （3）如果玩家输入的数为0，则退出游戏；如果玩家输入的数小于0或大于100，则重新输入 （4）利用循环判断计算机生成的数和玩家输入的数是否一致 （5）如果不一致：玩家输入的过大，则提示“太大了”；玩家输入的过小，则提示“太小了” （6）如果玩家输入的数与计算机产生的数一致，则提示“恭喜你，答对啦！” 4.源代码： 4.1奇数累加 12345678910111213package com.itheima.first;public class Sum &#123; public static void main(String[] args)&#123; int i,sum=0; for(i=1;i&lt;100;i++) &#123; if(i%2!=0) sum+=i; &#125; System.out.println(&quot;在自然数1-99中奇数累加之和为：&quot;+sum); &#125;&#125; 4.2猜数字小游戏 12345678910111213141516171819202122232425262728293031323334package interesting;import java.util.Scanner;public class game &#123; public static void main(String[] args) &#123; int n=(int)(Math.random()*100)+1; //利用随机数生成一个正确答案 Scanner a=new Scanner(System.in); System.out.println(&quot;***********这是一个猜数字的游戏***********\n&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)，退出游戏请按0：&quot;); int b=a.nextInt(); while(b&lt;0||b&gt;100) &#123; System.out.println(&quot;输入错误~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; if(b==0) System.out.println(&quot;你已退出游戏~~~&quot;); else &#123; while(b!=n) //如果用户输入的数与正确答案不符 &#123; if(b&gt;n) System.out.println(&quot;太大了~&quot;); else if(b&lt;n) System.out.println(&quot;太小了~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; &#125; if(b==n) System.out.println(&quot;恭喜你，猜对啦!&quot;); &#125;&#125; 5.心得体会： 这些都是简单的程序，但是JAVA与C语言和C++的语法不一样，比如游戏里的产生随机数，我本来用的是C语言的随机数，但运行的时候发现了错误，于是我上网搜了一下，发现JAVA和C语言的随机数不一样；JAVA的输入代码，我在网上找了一下，接收字符和数字的输入代码是不一样的~ 还有程序最后保存是以文件夹的形式，我不知道最好是删除某个文件还是保留整个文件夹…于是我又做了新的尝试，我只留了src那个文件夹，然后…代码运行不了…我只好重新建了个项目，这次不敢删了… 不过这是我第一次用JAVA写代码呢感觉自己学到了很多*****]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方法计算两个数的最大公约数]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0~~~%2F</url>
    <content type="text"><![CDATA[1.题目名称 计算两个数的最大公约数 2.题目分析 计算两个数的最大公约数，可以采用最大公约数的四种常用算法，分别是辗转相除法、穷举法、更相减损法、Stein算法。每种方法写一个函数，分别计算出最大公约数，主函数的菜单里有选择功能，用户可以选择自行输入两个数，然后调用这四种方法的任一种；也可以选择程序的测试功能，通过自己选择的组数，计算机自动产生随机函数，然后调用四种方法的任一种，并计算出程序运行的时间。 3.算法构造 3.1辗转相除法 设两数为a,b设其中a 做被除数,b做除数，temp为余数 1、大数放a中、小数放b中； 2、求a/b的余数； 3、若temp=0则b为最大公约数； 4、如果temp!=0则把b的值给a、temp的值给a； 5、返回第二步； 3.2穷举法（利用数学定义） 穷举法（也叫枚举法）穷举法求两个正整数的最大公约数的解题步骤： 从两个数中较小数开始由大到小列举，直到找到公约数立即中断列举，得到的公约数便是最大公约数 。 对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp能同时被a和b所整除，则temp即为最大公约数。 3.3更相减损法 更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。《九章算术》是中国古代的数学专著，其中的“更相减损术”可以用来求两个数的最大公约数，即“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 翻译成现代语言如下： 第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。 3.4 Stein算法 Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。来研究一下最大公约数的性质，发现有 gcd( k_x,k_y ) = k_gcd( x,y ) 这么一个非常好的性质。试取 k=2，则有 gcd( 2x,2y ) = 2 * gcd( x,y )。很快联想到将两个偶数化小的方法。那么一奇一个偶以及两个奇数的情况如何化小呢？ 先来看看一奇一偶的情况： 设有2x和y两个数，其中y为奇数。因为y的所有约数都是奇数，所以 a = gcd( 2x,y ) 是奇数。根据2x是个偶数不难联想到，a应该是x的约数。我们来证明一下：(2x)%a=0，设2x=n_a，因为a是奇数，2x是偶数，则必有n是偶数。又因为 x=(n/2)*a，所以 x%a=0，即a是x的约数。因为a也是y的约数，所以a是x和y的公约数，有 gcd( 2x,y ) &lt;= gcd( x,y )。因为gcd( x,y )明显是2x和y的公约数，又有gcd( x,y ) &lt;= gcd( 2x,y )，所以 gcd( 2x,y ) = gcd( x,y )。至此，我们得出了一奇一偶时化小的方法。 再来看看两个奇数的情况：设有两个奇数x和y，不妨设x&gt;y，注意到x+y和x-y是两个偶数，则有 gcd( x+y,x-y ) = 2 * gcd( (x+y)/2,(x-y)/2 )，那么 gcd( x,y ) 与 gcd( x+y,x-y ) 以及 gcd( (x+y)/2,(x-y)/2 ) 之间是不是有某种联系呢？为了方便设 m=(x+y)/2 ，n=(x-y)/2 ，容易发现 m+n=x ，m-n=y 。设 a = gcd( m,n )，则 m%a=0,n%a=0 ，所以 (m+n)%a=0，(m-n)%a=0 ，即 x%a=0 ，y%a=0 ，所以a是x和y的公约数，有 gcd( m,n )&lt;= gcd(x,y)。再设 b = gcd( x,y )肯定为奇数，则 x%b=0,y%b=0 ，所以 (x+y)%b=0 ，(x-y)%b=0 ，又因为x+y和x-y都是偶数，跟前面一奇一偶时证明a是x的约数的方法相同，有 ((x+y)/2)%b=0,((x-y)/2)%b=0 ，即 m%b=0 ，n%b=0 ，所以b是m和n的公约数，有 gcd( x,y ) &lt;= gcd( m,n )。所以 gcd( x,y ) = gcd( m,n ) = gcd( (x+y)/2,(x-y)/2 )。 整理一下，对两个正整数 x&gt;y ： 1.均为偶数 gcd( x,y ) =2gcd( x/2,y/2 )； 2.均为奇数 gcd( x,y ) = gcd( (x+y)/2,(x-y)/2 )； 2.x奇y偶 gcd( x,y ) = gcd( x,y/2 )； 3.x偶y奇 gcd( x,y ) = gcd( x/2,y ) 或 gcd( x,y )=gcd( y,x/2 )； 现在已经有了递归式，还需要再找出一个退化情况。注意到 gcd( x,x ) = x ，就用这个。 4.算法实现 4.1辗转相除法 123456789101112131415161718192021222324int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125; 4.2穷举法（利用数学定义） 12345678910111213141516int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125; 4.3更相减损法 123456789101112131415161718192021222324252627int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125; 4.4 Stein算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;****4.5完整代码**** 在这里插入代码片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include&lt;stdio.h&gt;#include&lt;math.h&gt; //计算2的i次方的函数pow(2,i)的头文件#include&lt;time.h&gt; //计算程序运行时间和随机产生数的头文件#include&lt;stdlib.h&gt;int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125;int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125;int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125;int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;void main()&#123; int x,y,p,i,n,N,m[1000]; int a,b,c,d,e; printf(&quot;*********************你有两种选择********************\n&quot;); printf(&quot;* 1.输入两个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.利用随机数测试最大公约数并计算程序运行时间. *\n&quot;); printf(&quot;*****************************************************\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n&lt;1||n&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;n); &#125; if(n==1) &#123; printf(&quot;请输入两个正整数:\n&quot;); //用户自行输入两个数 scanf(&quot;%d%d&quot;,&amp;x,&amp;y); while(x&lt;0||y&lt;0||x==0||y==0) &#123; printf(&quot;请按要求输入正整数:\n&quot;); scanf(&quot;%d%d&quot;,&amp;x,&amp;y); &#125; printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); break; case 2: a=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); break; case 3: a=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); break; case 4: a=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); break; case 5: a=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); break; &#125; printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125;&#125;else if(n==2)&#123; clock_t start,finish; //计算随机函数 double duration; srand((unsigned)time(NULL)); printf(&quot;你想测试多少组数据？\n&quot;); scanf(&quot;%d&quot;,&amp;N); for(i=0;i&lt;N;i++) //随机取20个数（1-100） &#123; m[i]=rand()%100+1; printf(&quot;%d\t&quot;,m[i]); &#125; printf(&quot;\n&quot;); printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: start=clock(); //程序运行，开始计时 while(j&lt;20) &#123; x=m[j++]; y=m[j++]; a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125; finish=clock(); //程序运行结束，结束计时 break; case 2: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; b=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,b); &#125; finish=clock(); break; case 3: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; c=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,c); &#125; finish=clock(); break; case 4: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; d=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,d); &#125; finish=clock(); break; case 5: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; e=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,e); &#125; finish=clock(); break; &#125; duration=(double)(finish-start)/1000; ////计算时间差，由于计算机计算的是毫秒，转换成秒要除以1000 printf(&quot;这个方法的运行时间是%f秒\n&quot;,duration); &#125; &#125; &#125; 5.经验归纳 5.1遇到的问题 1.对随机函数不熟悉； 2.测试环节，对计算程序运行时间不熟悉； 3.在更相减损法的最后，用到了pow()函数，因没加头文件#include&lt;math.h&gt;而出错； 4.因知识储备不足，对最后一种方法（Stein算法）不理解。 PS：以上问题均已解决。 5.2心得体会 我觉得这四种方法里Stein算法我有点看不懂（可能是因为有&gt;&gt;运算符），还有随机数的生成和计算程序运行时间的函数都只是有一些印象，并不熟悉。（但是我可以查资料和问同学啊hhh） 主函数我改了很多次，就是想让界面更加美化一些，改完就发现程序出错了…其实就是赋值这么一个小细节，但就是发现不了（Emmmm），感觉自己还需要学很多东西，动手能力也要加强 总之就是~add oil!!!]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三天打鱼两天晒网]]></title>
    <url>%2F2019%2F03%2F01%2F%E2%80%9C%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[♦ 题目： 三天打鱼两天晒网 ♦问题： 某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。 ♦ 要求： 基本要求：1.程序风格良好(使用自定义注释模板)，提供友好的输入输出。 提高要求：1.输入数据的正确性验证。 2.使用文件进行数据测试。如将日期 20100101 20111214 等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。 ♦程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void hanshu(int year,int month,int day)&#123; int sum=0; int a=0; int b=0; int c=0; int x[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; //平年各月份的天数 int y[12]=&#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; //闰年各月份的天数 for(int i=2010;i&lt;year;i++) //利用循环结构计算出在输入年份之前的那几年一共有几天 &#123; if((i%4==0&amp;&amp;i%100!=0)||i%400==0) //判断是否有闰年，有的话，一年为366天；否则一年为365天 a+=366; else a+=365; &#125; for(int j=0;j&lt;month-1;j++) //利用循环计算在输出月份之前的几个月一共有几天 &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) //判断该年是否为闰年，如果是，则用闰年数组；否则，用平年数组 b+=y[j]; else b+=x[j]; &#125; c=day; //用户输入的天数 sum=a+b+c; //将年，月，日所计算的天数相加，即为总天数 printf(&quot;距离2010年1月1日一共有%d天\n&quot;,sum); if(sum%5==1||sum%5==2||sum%5==3) //判断总天数取余后余数是否为1,2,3，如果是，输出“你在打鱼”；否则，输出“你在晒网” printf(&quot;你在打鱼~~~\n&quot;); else printf(&quot;你在晒网~~~\n&quot;);&#125;void main()&#123; int year,month,day,m,p,a,b,c; printf(&quot;***************计算你到底在打鱼还是晒网***************\n&quot;); printf(&quot;1.使用文件测试\n&quot;); printf(&quot;2.从键盘输入计算\n&quot;); printf(&quot;请输入你想选择的操作的序号：\n&quot;); scanf(&quot;%d&quot;,&amp;m); if(m==1) //选择1，进入文件测试环节 &#123; FILE *fp1; FILE *fp2; fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;); fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;); if(fp1==NULL) //判断文件in.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else if(fp2==NULL) //判断文件out.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else fscanf(fp1,&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); //文件不为空，则用格式化读写函数fscanf()和fprintf()来读取文档in.txt和out.txt中的信息 hanshu(a,b,c); fprintf(fp2,&quot;%1d&quot;,&amp;p); fclose(fp1); //关闭文件 fclose(fp2); &#125; else if(m==2) &#123; printf(&quot;请输入年，月，日：(在2010年1月1日之后)\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); while(year&lt;2010||month&gt;12||day&gt;31) //判断输入年份是否小于2010年，如果是，则重新输入 &#123; printf(&quot;输入错误！请重新输入！\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); &#125; hanshu(year,month,day); &#125; else &#123; printf(&quot;你的输入有误！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;m); &#125;&#125; ♦ 心得： 第一次接触文件测试这样的问题，我刚开始还真无从下手还好问了班里比较厉害的同学，然后自己复习了C语言课本上的文件那一章，感觉遇到的问题挺多的，但是还好在我的不懈努力（不断问别人）下，最终是把文件测试这关通过了！！！ 刚开始敲得那个代码只有一个主函数，后来检查了一下觉得太简单了，然后运用了子函数，感觉自己对C语言还掌握的不是很清楚，还需要多多动手敲代码啊！！！（希望老师能看到我这个代码小白的认真） 我觉得这次作业让我学到了好多东西，也了解到了大企业的程序设计风格，我可以从现在开始学习他们的风格。 个人感觉还是对C语言感情更深一些，毕竟是接触计算机学到的第一门语言hhhh希望我能够在史晓楠老师（超级厉害）的教导下学到更多以前没接触过的东西！！！ 新的一年，新一学期，新的起点，FIGHTING]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
