<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[knn算法]]></title>
    <url>%2F2019%2F10%2F05%2FPython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-knn%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目名称knn算法–电影分类 题目描述​ 一个样本与数据集中的k个样本最相似，如果这k个样本中的大多数属于某一个类别，则该样本也属于这个类别 算法分析1. 用字典dict构建电影分类数据集(训练集)和测试集&emsp;&emsp;&emsp;训练集： 名称 搞笑镜头 拥抱镜头 打斗镜头 类型 亲密旅行 42 2 9 喜剧片 新喜剧之王 21 17 5 喜剧片 唐人街探案2 54 9 11 喜剧片 羞羞的铁拳 39 0 31 喜剧片 复仇者联盟4 5 2 57 动作片 蜘蛛侠：英雄远征 3 2 65 动作片 速度与激情8 2 3 55 动作片 战狼2 6 4 21 动作片 无问西东 7 46 4 爱情片 后来的我们 9 39 8 爱情片 悲伤逆流成河 9 38 2 爱情片 超时空同居 8 34 17 爱情片 &emsp;&emsp;&emsp;测试集： 名称 搞笑镜头 拥抱镜头 打斗镜头 类型 美人鱼 33 4 25 2. 计算测试集与数据集中所有数据的距离&emsp;&emsp;&emsp;计算距离的方法是欧式距离： 3. 取每段距离的小数点后两位并将电影名称和对应的距离添加到空数组中4. 按距离大小升序排序并取前5项5. 取出训练集的列表，确定前5个样本所在类别出现的频率6. 对所得结果按照出现的次数用sorted()函数进行排序，得到一个升序的新数组，取出现次数最多的类型，因此要将新数组倒序，取第一个值7. 输出排序后的结果和出现频率最高的类别 算法流程图 运行截图 心得体会​ knn算法是最简单易懂的机器学习算法， 但是在设置K值时需要注意， k值设置过小会降低分类精度；若设置过大，且测试样本属于训练集中包含数据较少的类，则会增加噪声，降低分类效果。在电影分类这里我设置了k的值是5。在训练集和测试集中，使用的特征值是搞笑镜头、打斗镜头、拥抱镜头的数量，所有的镜头数量都是虚构的。 ​ knn算法的计算复杂度较高，测试集需要和训练集的每个数据进行距离计算，时间复杂度为O(n)， 所以knn适合数据较少的数据集。 附：源代码12345678910111213141516171819202122232425262728293031323334353637383940414243import math# 训练集train_data = &#123;"亲密旅行": [45, 2, 9, "喜剧片"], "新喜剧之王": [21, 17, 5, "喜剧片"], "唐人街探案2": [54, 9, 11, "喜剧片"], "羞羞的铁拳": [39, 0, 31, "喜剧片"], "复仇者联盟4": [5, 2, 57, "动作片"], "蜘蛛侠：英雄远征": [3, 2, 65, "动作片"], "速度与激情8": [2, 3, 55, "动作片"], "战狼2": [6, 4, 21, "动作片"], "无问西东": [7, 46, 4, "爱情片"], "后来的我们": [9, 39, 8, "爱情片"], "悲伤逆流成河": [9, 38, 2, "爱情片"], "超时空同居": [8, 34, 17, "爱情片"]&#125;# 测试集test_data = [23, 3, 17]KNN = []# 遍历计算测试集与数据集中所有数据的距离for key, value in train_data.items(): # 求距离 d = math.sqrt((test_data[0] - value[0]) ** 2 + (test_data[1] - value[1]) ** 2 + (test_data[2] - value[2]) ** 2) # 取小数点后两位 KNN.append([key, round(d, 2)])# 按距离大小升序并取前 5 项KNN.sort(key=lambda dis: dis[1])KNN = KNN[: 5]# print(KNN)# 类别labels = &#123; "喜剧片": 0, "动作片": 0, "爱情片": 0&#125;# 确定前 5 个样本所在类别出现的频率for i in KNN: # 取出训练集的列表 label = train_data[i[0]] # 确定出现的次数 labels[label[3]] += 1# 对所得结果按照出现的次数倒序labels = sorted(labels.items(), key=lambda l: l[1], reverse=True)# 输出排序后的结果和出现频率最高的类别print(labels, labels[0][0], sep='\n')]]></content>
      <tags>
        <tag>python机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax-3-Ajax的优缺点和跨域问题]]></title>
    <url>%2F2019%2F10%2F02%2FAjax-3-Ajax%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ajax的优缺点和跨域问题 - #### Ajax的优缺点： 优点： 无刷新更新数据：Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信 异步与服务器通信：使用异步的方式与服务器通信，不打断用户的操作 前端与后端负载均衡：将一些后端的工作移到前端，减少服务器与带宽的负担 基于规范被广泛支持：不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。 界面与应用分离：Ajax使得界面与应用分离，也就是数据与呈现分离 缺点：下面所阐述的ajax的缺陷都是它先天所产生的（部分已经解决了或者有解决方法） Ajax干掉了Back与History功能，破坏了浏览器机制：动态更新页面时，用户无法回到前一页的页面状态，因为浏览器仅能记忆历史纪录中的静态页面 安全问题：AJAX技术会给IT企业带来安全威胁，Ajax技术如同对企业数据建立了一个直接通道。使开发者不经意间暴露比以前更多的数据和服务器逻辑 对搜索引擎支持较弱 破坏程序的异常处理机制 违背URL与资源定位的初衷 不能很好地支持移动设备（但是有很多框架解决了这些问题） 客户端肥大，太多客户端代码造成开发上的成本上升 什么是跨域以及产生原因 跨域是指 a 页面想获取 b 页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址，b页面为域名地址，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。典型的例子如iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信 Uri 说明 是否跨域 http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 是 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同域名下不同文件 否 http://www.a.com:8000/a.js http://www.a.com/b.js 同域名下不同端口 是 http://www.a.com/a.js https://www.a.com/b.js 同域名 不同协议 是 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 是 http://www.a.com/a.js http://script.a.com/b.js 主域名相同 子域名不同 是（cookie不可访问） http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 是 跨域多个解决方案 【策略一】Jsonp：需要目标服务器配合一个callback函数 JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问。 JSONP顾名思义，就是把JSON填充到一个盒子里，它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 PHP代码： 12345&lt;?php $arr = array(&apos;a&apos; =&gt; 1,&apos;b&apos; =&gt; 2,&apos;c&apos; =&gt; 3,&apos;d&apos; =&gt; 4,&apos;e&apos; =&gt; 5); $result = json_encode($arr); // 服务端返回JSON数据 $callback = $_GET[&apos;callback&apos;]; echo $callback.&quot;($result)&quot;; // 动态执行回调函数 js方案 123456789 function jsonpCallback(result) &#123; console.log(result); &#125; document.getElementsByTagName("div")[0].onclick = function ()&#123; var JSONP = document.createElement("script"); JSONP.type = "text/javascript"; JSONP.src = "abc.php?callback=jsonpCallback"; document.body.appendChild(JSONP);&#125; jq方案 12345678$.ajax(&#123; url:"abc.php", dataType:'jsonp', jsonp:'callback', success:function(result) &#123; console.log(result); &#125;&#125;); 注意：JQ的方法可以用来跨域，如上面的代码也可以直接换成$.get方法来实现 【策略二】通过修改document.domain来跨子域：将子域和主域的document.domain设为同一个主域. 前提条件：这两个域名必须属于同一个基础域名！而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 12345678910 document.domain = "abc.net"; // 在一个页面里将主域设为abc.net var ifr = document.createElement('iframe'); // 创建iframe标签 ifr.src = 'http://blogs.abc.net/b.html'; // 并在里面打开需要通信的另一个页面 ifr.style.display = 'none'; // 隐藏标签 document.body.appendChild(ifr); // 插入页面 ifr.onload = function () &#123; // iframe加载完成后 var x = ifr.contentDocument; // 获取iframe的document alert(x.getElementsByTagName("h1")[0].innerHTML); // 操作其中的b.html ifr.onload = null; // 取消事件函数&#125; 注意：如果想获取iframe里的window或者document，可以使用 iframe.contentWindow、iframe.contentDocument 【策略三】使用window.name来进行跨域：window.name+iframe 需要目标服务器响应window.name,window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的! 1234 window.name = data; // 接着，子窗口跳回一个与主窗口同域的网址。window.location = 'http://parent.url.com/xxx.html'; // 然后，主窗口就可以读取子窗口的window.name了var data = document.getElementById('iframe').contentWindow.name; 注意：window.name容量很大，非常长的字符串也可以使用；但由于必须监听子窗口window.name属性的变化，会影响网页性能 【策略四】跨文档消息传输window.postMessage：HTML5引入一个全新的API —– 跨文档消息传输Cross Document Messaging来解决这个问题。 使用方法 1otherWindow.postMessage(message, targetOrigin); otherWindow ： 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性或window.open的返回值；一般可以通过name或下标从window.frames取到的值。 message: 具体的信息内容，string类型。 targetOrigin ： 接受消息的窗口的源(origin)，即”协议+域名+端口“。也可以设为”*“，表示不限制域名，向所有窗口发送。 message事件的事件对象event，提供一下三个属性 ： event.source—– 发送消息的窗口 event.origin —– 消息发向的网站 event.data —– 消息内容 12345678910111213141516171819 // a.com/index.html页面中的代码 &lt;iframe id = "ifr" src = "b.com/index.html"&gt;&lt;/iframe&gt; &lt;script type = "text/javascript"&gt; window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://b.com'; //写成'http://b.com/c/proxy.html'效果一样；写成'http://c.com'就不会执行postMessage了 ifr.contentWindow.postMessage('I was there!', targetOrigin); &#125;; &lt;/script&gt; // b.com/index.html页面中的代码 &lt;script type = "text/javascript"&gt; window.addEventListener('message', function (event) &#123; if (event.origin == 'http://a.com') &#123; // 通过origin属性判断消息来源地址 alert(event.data); // 弹出"I was there!" alert(event.source); // 对a.com、index.html中window对象的引用；由于同源策略，event.source不可以访问window对象 &#125; &#125;, false); &lt;/script&gt; 【策略五】通过CORS解决AJAX跨域：CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 CORS详解 定义：CORS其实出现时间不短了，它在维基百科上的定义是：跨域资源共享（CORS）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。而W3C的官方文档目前还是工作草案，但是正在朝着W3C推荐的方向前进。 简言之，CORS就是为了让AJAX可以实现可控的跨域访问而生的。 以往要实现跨域访问，可以通过JSONP、Flash或者服务器中转的方式来实现，但是现在我们有了CORS。CORS与JSONP相比，更为先进、方便和可靠。 CORS只需要向响应头header中注入Access-Control-Allow-Origin，这样浏览器检测到header中的Access-Control-Allow-Origin，则就可以跨域操作了。 JSONP和CORS的区别 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。 设置Access-Control-Allow-Origin：在被请求的Response header中加入 : 1234567891011&lt;?php$ret = array( 'name' =&gt; isset($_POST['name'])? $_POST['name'] : '', 'gender' =&gt; isset($_POST['gender'])? $_POST['gender'] : '' ); header('content-type:application:json;charset=utf8'); header('Access-Control-Allow-Origin:*'); // 指定允许其他域名访问header('Access-Control-Allow-Methods:POST'); // 响应类型为POST，还有GETheader('Access-Control-Allow-Headers:x-requested-with,content-type'); // 响应头设置echo json_encode($ret); // 输出, 类似console.log()?&gt; 就可以实现ajax POST跨域访问了。它在客户端的代码和AJAX没有什么区别，只不过处理地址变成了外域的地址。 Access-Control-Allow-Origin:* ： 表示允许任何域名跨域访问 如果需要指定某域名才允许跨域访问，只需把Access-Control-Allow-Origin:*改为Access-Control-Allow-Origin:允许的域名，例如：header(&#39;Access-Control-Allow-Origin:http://www.client.com&#39;); 如果需要设置多个域名允许访问，这里需要用PHP处理一下，例如允许 www.client.com 与 www.client2.com 可以跨域访问，服务器端处理： 12345678910111213141516171819&lt;?php$ret = array( 'name' =&gt; isset($_POST['name'])? $_POST['name'] : '', 'gender' =&gt; isset($_POST['gender'])? $_POST['gender'] : '' ); header('content-type:application:json;charset=utf8'); $origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : '';$allow_origin = array( 'http://www.client.com', 'http://www.client2.com' ); if(in_array($origin, $allow_origin))&#123; header('Access-Control-Allow-Origin:'.$origin); // 字符串拼接 header('Access-Control-Allow-Methods:POST'); header('Access-Control-Allow-Headers:x-requested-with,content-type'); &#125; echo json_encode($ret); ??&gt; 总结：以上总结了js跨域的几种方法，他们各有千秋。其实最主要的区别除了实现方式不一样，主要是浏览器的兼容问题而已。 JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS优点：使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。CORS缺点：古老的浏览器不支持，不过大部分现代浏览器都支持 document.domain+iframe：只适用于主域相同的跨域问题处理 postMessage优点：是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。如果是现代浏览器，首选。postMessage缺点： ie8以前不支持 window.name主要是应用当frame的页面跳到其他地址时，其window.name值保持不变的原理。兼容性好。需要照顾落后的浏览器时，首选。 练习： 1. ajax实现瀑布流。 要求：列数固定，宽度相等，但是每个子项高度不固定，刷新页面时展示30个数据，当滚动条下拉到底时每次再展示10个数据，每次添加新数据时按照列高最低的列添加问题 (注意：获取的图片大小可能不同，但是布局里要求图片的宽相同，图片还不能变形，另外由于图片加载时间问题，如果通过循环计算每列的高会由于图片没有加载的问题出错，因此可以把图的宽高放在数据内容，通过直接赋值的方式解决，还可以用递归做懒加载，让每个图片加载完后再加载下一张图当滚动条滚动到最短的列的最下边出现在可视范围内时，既是我们要用ajax动态加载数据的时候，同样由于加载时间的问题，滚动条事件可能会发生很多次，因此还要设置一个开关，在上一次加载完成之前不能再次调用方法)]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax-2-jQuery的ajax的属性和用法]]></title>
    <url>%2F2019%2F10%2F02%2FAjax-2-jQuery%E7%9A%84ajax%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[jquery的ajax的属性和用法 - #### Jquery的ajax 用js写AJAX主要问题就是浏览器兼容问题，并且状态和错误处理写起来很麻烦。用jQuery处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。 jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象。 $.ajax()：执行一个异步的HTTP（Ajax）的请求 1234567$("button").click(function () &#123; $.ajax(&#123; url: "abc.txt", success: function (result) &#123; $("#div1").html(result); &#125;&#125;);&#125;); 下面列出了常见的名称/值： url：规定发送请求的 URL。默认是当前页面。 cache：布尔值，表示浏览器是否缓存被请求页面。默认是 true。 async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为’GET’，可指定为’POST’等； contentType：发送POST请求的格式，默认值为’application/x-www-form-urlencoded; charset=UTF-8‘，也可以指定为text/plain、application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式； dataType：接收的数据格式，可以指定为’html’、’xml’、’json’、’text’等，缺省情况下根据响应的Content-Type猜测。 如一个JSON格式的例子： 1234567891011121314151617function ajaxLog(s) &#123; var txt = $('#test-response-text'); txt.val(txt.val() + '\n' + s);&#125;$('#test-response-text').val("");var jqxhr = $.ajax('data.txt', &#123; dataType: 'json', success : function (data) &#123; ajaxLog("成功, 收到的数据: " + JSON.stringify(data)); &#125;, error : function (xhr, status) &#123; ajaxLog("失败: " + xhr.status + ", 原因: " + status); &#125;, complete : function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用'); &#125;&#125;); beforeSend(xhr)：发送请求前运行的函数 complete(xhr, status)：请求完成时运行的函数（在请求成功或失败之后均调用，即在 success和 error函数之后） success(result, status, xhr)：当请求成功时运行的函数 error(xhr, status, error)：如果请求失败要运行的函数 timeout：设置本地的请求超时时间（以毫秒计） jsonp：在一个 jsonp 中重写回调函数的字符串。来替代在”callback=?“这种GET或POST请求中URL参数里的”callback”部分，比如{jsonp:&#39;onJsonPLoad&#39;}会导致将”onJsonPLoad=?“传给服务器。（query实现跨域方法） jsonpCallback：在一个 jsonp 中规定回调函数的名称，也就是替换”callback=?”中的问号 对常用的AJAX操作，jQuery提供了一些辅助方法。 $(&quot;#id&quot;).load()：从服务器载入数据并且将返回的 HTML 代码并插入至匹配的元素中 12$("#div1").load("abc.txt"); // 加载abc.txt文件的数据到#div1里$("#div1").load("history.html #div0"); // 加载history.html文件的#div0的内容到#div1里 GET请求最常见，jQuery提供了get()方法，可以这么写： 1234var jqxhr = $.get('data.txt', &#123; name: 'Bob Lee', check: 1 &#125;); 第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：data.txt?name=Bob%20Lee&amp;check=1。这样我们就不用关心如何用URL编码并构造一个query string了 post()和get()类似，但是传入的第二个参数默认被序列化为application/x-www-form-urlencoded： 1234var jqxhr = $.post('data.txt', &#123; name: 'Bob Lee', check: 1 &#125;); 实际构造的数据name=Bob%20Lee&amp;check=1作为POST的body被发送。 由于JSON用得越来越普遍，所以jQuery也提供了getJSON()方法来快速通过GET获取一个JSON对象： 123456var jqxhr = $.getJSON('data.txt', &#123; name: 'Bob Lee', check: 1&#125;,function (data) &#123; // data已经被解析为JSON对象了&#125;); 练习： 1. 利用ajax做一个分页效果，数据如下：[{“id”:”1”,”name”:”苹果1”,”price”:”6.00”},{“id”:”2”,”name”:”苹果2”,”price”:”5.00”},{“id”:”3”,”name”:”苹果3”,”price”:”7.00”},{“id”:”4”,”name”:”苹果4”,”price”:”6.00”},{“id”:”5”,”name”:”苹果5”,”price”:”6.00”},{“id”:”6”,”name”:”苹果6”,”price”:”6.00”},{“id”:”7”,”name”:”苹果7”,”price”:”6.00”},{“id”:”8”,”name”:”苹果8”,”price”:”6.00”},{“id”:”9”,”name”:”苹果9”,”price”:”6.00”},{“id”:”10”,”name”:”苹果10”,”price”:”6.00”},{“id”:”11”,”name”:”苹果11”,”price”:”6.00”},{“id”:”12”,”name”:”苹果12”,”price”:”6.00”},{“id”:”13”,”name”:”苹果13”,”price”:”6.00”}]]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax-1-Ajax原理和封装]]></title>
    <url>%2F2019%2F10%2F02%2FAjax-1-Ajax%E5%8E%9F%E7%90%86%E5%92%8C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ajax原理和封装 Ajax基础 AJAX全称为”Asynchronous JavaScript and XML”（异步JavaScript和XML），就是无刷新数据读取的技术，一种创建交互式网页应用的网页开发技术。 它可以节省用户操作，时间，提高用户体验，减少数据请求 开始大家不知道Ajax有什么用，第一个应用的是谷歌地图上，之后ajax就开始被各个地方滥用……一般用在：用户注册和在线聊天室等 Ajax代码解析 一个Ajax的流程：步骤和打电话类似 买个手机并申请个号码（创建Ajax对象） 向需要拨打的号码拨号（与服务器连接） 向对方说话（发送请求） 听对方话说（接收返回值） 代码如下： 12345678910111213141516171819//1、创建Ajax对象var xhr = new XMLHttpRequest();//2、连接服务器xhr.open("get", url, true);//3、发送请求xhr.send();//4、接收服务器的返回xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; // 完成 if (xhr.status == 200) &#123; // 成功且无错误 console.log('成功： ' + xhr.responseText); &#125; else &#123; console.log('失败'); &#125; &#125;&#125; 连接服务器：open (提交方式, 文件路径, 异步传输) 参数一：提交方法 —— GET/POST：GET多用于获取数据；POST多用于上传数据 参数二：文件路径 —— 你的文件地址和名称，如果需要阻止缓存 1'abc.txt?'+new Date().getTime(); // 每次提交时间戳不同/或者用随机数 参数三：同步和异步 —— false/true（事件一件一件进行就是同步，多件事一起进行就是异步）：同步会阻塞后续代码，异步不会 发送请求：send() —— 在表单里数据传输是在form的属性里决定get和post，在ajax里则是open方法，而提交数据的get的方法可以直接连接在url后面，可以利用url里的和编码传输（防止中文出现乱码），用encodeURI()（解码方法decodeURI()） 1xhr.open(method, url + "?" + data, true); 但 post 提交时，数据放在send()方法里作为参数传递（send(&quot;数据&quot;)），并要设置请求头（数据编码类型），form里不设置是因为有默认值，但ajax里没有： 12xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");xhr.send(data); post 没有缓冲问题和中文问题，因为 post 是提交数据的，在设置头的时候设置过了 接收返回：onreadystatechange事件：与服务器发生数据传输ajax对象的readyState属性值改变时；readyState属性：请求状态 0 ： （初始化）还没有调用open()方法 1 ： （载入）已调用send()方法，正在发送请求 2 ： （载入完成）send()方法完成，已收到全部相应内容 3 ： （解析）正在解析相应内容 4 ： （完成）相应内容解析完成，可以在客户端调用了 ajax的responseText属性：返回的数据（无论什么数据都是字符串）； ajax的status属性：是否成功（200成功且无错误，404请求页面找不到）: (状态码) 1字头： 消息类，请求收到，继续处理 2字头： 成功类型，操作成功收到，分析、接受 3字头： 重定向，请求发生了页面跳转（包括缓存），完成此请求必须进一步处理 4字头： 请求错误，请求包含一个错误语法或不能完成 5字头： 服务器错误，服务器执行一个完全有效请求失败 Ajax的封装和使用 ajax能且仅能从服务器上读取文件信息，不能在本地打开，做练习1，将ajax封装使用： 123456var oBtn = document.getElementById('btn1');oBtn.onclick = function () &#123; myApp.ajax('abc.txt', function (str) &#123; alert(str); &#125;);&#125; 注意：请求并显示静态txt文件，保存的txt文件也必须是utf-8编码，否则不是乱码就是出错 动态数据：在服务器上读到的数据全部是以文本（string）的方式，因此无法拿到数组或者json，只能拿到字符串，用eval方法有诸多问题，已经淘汰，因此可以用JSON的方法来解决 ajax的用途就是通过一个接口（既数据的地址）获取数据，根据数据的类型进行处理并展示到页面中 最终封装的ajax方法，参数应该有提交方式（可选），提交地址，数据（可选），调用成功的函数和调用失败的函数（可选），并将所有参数写成一个对象（其中默认提交方式是get，默认数据为空字符串） 练习： 1. 封装一个ajax函数，要求参数：通信地址；成功的回调函数(参数为成功时获得的数据)；失败的回调函数 12345678910111213141516171819202122232425262728function ajax(url, option) &#123; // option为对象 var json = option.json === undefined ? false : option.json; // 字符串转换成数组 // 局部刷新 var cache = option.cache == undefined ? true : option.cache; // 默认缓存 var method = option.method || "get"; // 提交方式，默认为 get var data = option.data || ""; var sucFn = option.sucFn || function () &#123;&#125;; // 数据获取成功时的函数 var faiFn = option.faiFn || function () &#123;&#125;; // 数据获取失败时的函数 var xhr = new XMLHttpRequest(); if (method == "get") &#123; xhr.open(method, (cache ? url + "?" + data + Date.now() : url + "?" + data), true); xhr.send(); &#125; else &#123; xhr.open(method, (cache ? url + "?" + Date.now(): url), true); xhr.setRequestHeader("content-type","application/x-www-form-urlencoded"); xhr.send(data); &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; // 完成 if (xhr.status == 200) &#123; // 成功且无错误 sucFn(json ? JSON.parse(xhr.responseText) : xhr.responseText); // 将字符串转换成数组或json &#125; else &#123; faiFn(); &#125; &#125; &#125;&#125; 2. 3个按钮和一个div，点击第一个按钮把文件1.txt内容放在div里，点击第二个按钮时把文件2.txt内容放在div里，点击第三个按钮时把文件3.txt内容放在div里 3. 每隔1秒重新读取数据的新闻页 1234567891011121314151617181920212223242526272829&lt;ul&gt;&lt;/ul&gt;&lt;script src = "ajax.js"&gt;&lt;/script&gt;&lt;script&gt; // 每隔1秒重新读取数据的新闻页，实时更新新闻 var str = ""; var oUl = document.querySelector("ul"); function getDate() &#123; ajax("data.txt", &#123; "sucFn": function (data) &#123; if (str != data) &#123; // 数据更新时 str = data; createLi(); // 创建 li &#125; &#125;, "cache": true &#125;); &#125; // 创建 li function createLi() &#123; oUl.innerHTML = ""; var arr = JSON.parse(str); // 将字符串转换成数组 for (var i = 0; i &lt; arr.length; i++) &#123; var oLi = document.createElement("li"); oUl.appendChild(oLi); oLi.innerHTML = arr[i]; &#125; &#125; setInterval(getDate, 1000);&lt;/script&gt;]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-4-动画和Velocity动画库]]></title>
    <url>%2F2019%2F09%2F28%2FjQuery-4-%E5%8A%A8%E7%94%BB%E5%92%8CVelocity%E5%8A%A8%E7%94%BB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[JQ动画和Velocity动画库 - #### Velocity.js介绍： 在Web上可以使用CSS实现动画，但是css的动画样式表内容膨胀，丧失对动画时间的控制，且无法灵活地实现基于物理运动模型的动画设计。也可以使用JS来实现，并且JS还有一些CSS无法替代的优势。 但是CSS动画在Web中扮演重要的角色，可以独自的实现动画或是同JS协作实现。特别的，CSS在一些简单基本的动画交互上表现的特别好，比如hover和focus等（客观的看待CSS动画和JS动画，他们各有优点） 然而，对于几乎所有事情，JS都是不错的选择，因为他的能力太强大了。jQuery设计的动画非常糟糕，比如动画出现抖动、不平滑，这不是JS的错！jQuery是由许多原生JS写的函数组成的库，原本不是以动画引擎为目标设计的，而是为了使烦人的DOM操作变得方便高效。 Velocity动画库就是专为动画而设计，简单易用，功能强大。它模仿了jQuery的语法，可以同jQuery协作，也能独立地使用，且容易学习。 为了提高你所有动画的性能，只需要简单地将目前jQuery的animate()函数调用换成velocity()，这样的一个小改变，也能使你的网站有一个显著的性能提升。 Velocity.js的方法的使用： 要使用Velocity首先要引入它，如果想与JQ配合使用注意要先引入JQ再引入Velocity Velocity 接收一个或更多的参数， 只有第一个参数是是强制要求的，它可以是一个命令（如”scroll“），或者是由CSS属性值组成的对象（这些值是动画的目标值）； 第二个参数是由动画附加选项组成的对象，比如过渡时长，张弛度，延时还有回调函数： 12345678910$element.velocity(&#123; left: "500px" &#125;, &#123; delay: 1000, duration: 500, easing: [ 1000, 40 ], // 1000是张驰度（提高整体动画的速度，可以更早到达终点，然后在终点附近来回反弹），40是摩擦系数（越小更快停下来） complete: function () &#123; alert(123); &#125;&#125;); 其中重要的属性都有默认值： &quot;`easing`&quot;的默认值是 swing；​ “duration“的默认值是 400ms; ​ 其他的属性则是可选的 你只能为一个CSS属性设置一个值，所以 “padding:&#39;10px 15px&#39;“是不合法的。应该写成： {paddingLeft:&quot;10px&quot;,paddingTop:&quot;15px&quot;,….}。这样不仅表达清晰，而且意味着你可以特别指定每一个css分属性的值（注意变成了驼峰命名了） 运动曲线easing（缓动）的取值： “ease-in-out“ ： 先加速再减速； “ease-in“ ： 加速到恒定速度直到动画结束； “ease-out“ ： 动画以恒定速度开始动画结束前减速 Velocity还提供弹性动画功能（spring），以一个张弛度（默认500）和一个摩擦系数（默认20）作为他的参数： 12345$element.velocity(&#123; width: "100px"&#125;, &#123; easing:[ 500, 20 ]&#125; 较高的张弛度将提高整体速度和动画的反弹力度，较小的摩擦系数将提高动画结束时的速度。 第二个参数其他常用名称： begin：为begin设置的函数会在动画开始前触发 complete：为complete设置的函数会在动画完成时调用； loop：值为一个整数n或true，动画循环n次或无限循环； delay：动画开始之前等待时间。 给参数传值的时候，如果CSS属性值没有给定确切的单位，那么时间默认：ms，长度默认：px，角度默认：deg。 为了表达清晰最好还是显示注明单位，如果有一个值不仅仅由数字表示，那么必须加引号。如：duration:500或duration:&quot;500ms&quot;都是合法的。 另外也允许传入简单的表达式作为CSS的属性值，但这些表达式只限于：+=， -=， *= ， /=，表示目标值在其本来的值的基础上加多少，减多少，乘多少，除多少，任何其他的表达式是不允许的。在Velocity动画引擎里使用这些快速功能保证了动画的逻辑可读性，使代码简洁清晰（消除了值的手工计算），而且向Velocity引擎提供更多有关于你动画意图的信息将有助于提高动画的性能。 楼层监听就是一种流行常见的js效果，并且无法使用css制作，你只需在目标元素上调用velocity()方法并传入”scroll”命令和过渡时间： 1234567$element.velocity("scroll", 1000); // 浏览器用1000毫秒滚动到选定的元素$element.velocity("scroll", &#123; duration: 1000, // 动画执行时间，也就是第一行代码中的第二个参数 offset: "-100px" &#125;); // 滚动后元素上边缘距窗口上边缘的距离：offset（向上为负，向下为正） 返回命令，在jQuery中，要使元素恢复成动画运行之前的状态，你要手动的设置，而在Velocity里只是一个运行”reverse“命令： 12345$element.velocity(&#123; width: "100px" &#125;, 400); $element.velocity("reverse"); velocity的链式调用即在同一个元素上一个动画完成之后马上进入另一个动画，这样一个一个的执行下去： 123456$element.velocity(&#123; width: "500px", height: "300px"&#125;).velocity(&#123; opacity: 0 &#125;); 这允许你不需要任何手动的计算,就能使那些复杂的、有时间限制的多级动画如当初计划的一样,一个接一个的执行。 velocity 允许制作基于颜色变换的动画，比如: color,backgroundColor,borderColor还有outlineColor.所有这些颜色的值只允许是16进制的字符串（黑色：#000000 , 脸谱蓝：#3b5998（for Facebook blue））.也许你想使用rgb格式的颜色设置,甚至指定颜色透明度（值介于0到1），只需简单地在CSS颜色名后面加上 “Red”，”Green”,”Blue” 或者”Alpha”即可： 12345$element.velocity(&#123; borderColor: "#ffff00", backgroundColorAlpha: 0.6,//背景颜色透明度变到60% colorBlue: 200 //rgb 方式 &#125;); 设置一些CSS3变换，允许你做一些2D或3D的动画，比如平移，扩大，旋转。 注意不会影响元素在网页中的位置，也不会影响周围 的元素在页面中的位置。 Velocity支持下面的变换： translateX: 从左向右沿x轴移动元素； translateY: 从上到下沿y轴移动元素； rotateZ: 关于z轴旋转元素； rotateX: 关于x轴旋转元素（看起来由里向外）； rotateY: 关于y轴旋转元素（由左到右）； scaleX: 成倍数改变元素宽度； scaleY: 成倍数改变元素高度 123$element.velocity(&#123; rotateZ: "180deg", scaleX: 2.0&#125;); stop结束当前动画，类似jq的stop 123$element.velocity("stop") //结束当前动画（开始执行后续动画）$element.velocity("stop",true) //结束当前和之后的动画$element.velocity("finish"); //结束当前动画，并达到动画终点，类似jq的stop(true,true) 创建一个velocity动画序列，并使用$.Velocity.RunSequence(变量)来执行动画序列，优点是可以反复使用，见例子 预定义动画和自定义动画：预定义动画是velocity.ui已经定义好的一些动画，而自定义动画则是我们自己定义一个动画 练习： 1. 用动画库做一个固定定位的返回顶部按钮，要求下拉距离超过200px后才能显示出来，否则隐藏，点击时过渡到页面顶部 2. 用动画库做一个旋转加缩放的方块的动画效果，要求时间4秒，旋转720deg，缩放从100%变成200%，颜色从红色到蓝色的循环动画 3. 用动画库做一个导航下划线滑动特效]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-3-工具方法和高级方法]]></title>
    <url>%2F2019%2F09%2F28%2FjQuery-3-%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E5%92%8C%E9%AB%98%E7%BA%A7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JQ工具方法和高级方法 - #### 工具方法： JQ的方法（$().css()等）只能给JQ对象用；而工具方法（$.type()等）不仅可以给JQ用，也可以给原生JS用 工具方法目的是完善原生js方法： 123456789101112131415$.type(a); // 可以判断比type方法更多的类型$.trim(str); // 去掉字符串前后空格(原生ES5中增加了trim()方法)$.inArray('b',arr); // 类似于 indexOf，如果第一个参数不存在返回-1(原生ES5中增加了数组的indexOf()方法)$.proxy(); // 改变this指向，参数：函数和this的指向。等同于函数.call(this的指向)$.noConflict(); // 防止冲突的，将返回值赋值给新变量，新变量就拥有$的操控权了$.parseJSON( '&#123;"name":"hello"&#125;' ).name); // 把字符串解析成json，等同于JSON.parse( '&#123;"name":"hello"&#125;' )$.makeArray(elems); // 将类数组elems转换成数组，(原生ES5的[].slice.call(elems)方法)$.ajax(); // 需要在服务器环境下，需要有地址页面，后面详解 高级方法： 简便的节点筛选方法： 123456789JQ对象.siblings(); // 找所有的兄弟节点，参数是筛选功能, 除当前元素JQ对象.nextAll(); // 下面所有兄弟节点，参数是筛选功能JQ对象.prevAll(); // 上面所有兄弟节点，参数是筛选功能JQ对象.parentsUntil()/nextUntil()/prevUntil(); // 截止第一次出现筛选条件之前，无参数时和上面一样JQ对象.clone(); // 复制元素，可以接收一个参数true ，可以复制之前的操作。为了防止id重复，应该用class做clone 元素的包装： 1234567891011JQ对象.wrap(); // 包装$("div").wrap($("&lt;div&gt;")); // 给每个div前都加一个divJQ对象.wrapAll(); // 整体包装$("div").wrapAll($("&lt;div&gt;")); // 给所有div前加一个整体的divJQ对象.wrapInner(); // 内部包装$("div").wrapInner($("&lt;span&gt;")); // 在每个div里添加一个span标签JQ对象.unwrap(); // 删除包装 ( 删除父级 : 不包括body)$("span").unwrap(); // 删除了span元素的父元素 JQ集合中添加和截取： 1234567JQ对象.add(); // 一个或多个元素添加到匹配的元素集合$("div").add("span").css("background", "red"); // 把与div同级的span的背景颜色也改变为红色var elem = $('div'); // 获取div集合var elem2 = elem.add('span'); // 在div集合中加入span集合JQ对象.slice(a,b); // 选中a到b（前）的元素，参数为下标，不是对象，左闭右开，只有一个参数时从这个参数开始，直到结束 delegate() ：事件委托 undelegate()： 终止事件委托 12345678$('li').on('click',function()&#123; $(this).css('backgroundColor','red');&#125;);$('ul').delegate('li','click',function()&#123; $(this).css('backgroundColor','red'); $('ul').undelegate();&#125;); 优点： 1、不用循环（同时会提高性能）； 2、js添加的元素也会获得事件 trigger()主动触发，适合自定义事件： 12345$('#div1').on('show',function()&#123; alert(123);&#125;); // 绑定自定义事件函数$('#div1').trigger('show'); // 触发自定义事件 ev.data（获取数据） ev.target（获取事件源） ev.type（获取事件类型) 12345$('#div1').on('click', &#123;name:'hello'&#125;, function (ev) &#123; alert( ev.data.name ); alert( ev.target ); alert( ev.type );&#125;); $.extend：扩展工具方法下的插件形式，语法：$.xxx() $.yyy() $.fn.extend：扩展到JQ对象下的插件形式，语法：$().xxx() $().yyy() 123456789101112131415161718192021222324252627$.extend(&#123; // 工具方法例子 leftTrim : function (str) &#123; return str.replace(/^\s+/,''); &#125;&#125;);$.fn.highlight1 = function () &#123; // this已绑定为当前jQuery对象: this.css('backgroundColor','#fffceb').css('color', '#d85030'); return this; // 保证我们自己写的扩展方法也要能继续链式下去&#125;$.fn.highlight2 = function (options) &#123; // 带有默认值且用户可改版 var bgcolor = options &amp;&amp; options.backgroundColor || '#fffceb'; var color = options &amp;&amp; options.color || '#d85030'; this.css('backgroundColor', bgcolor).css('color', color); return this; &#125;// 扩展：传参改变元素的字体和大小$.fn.changeF = function (str, size) &#123; this.css(&#123; "fontFamily": str, "fontSize": size &#125;); return this;&#125;$("span").changeF("楷体", 22); JQ动画：JQ对象.animate();（支持链式操作） 参数1：{} 运动的值和属性； 参数2：时间(运动快慢的) 默认: 400； 参数3：运动形式swing( 慢快慢，默认 ) linear(匀速); 参数4：回调函数 (到达指定时间后（终点）执行的动作) 123456789101112131415161718$('#div1').click(function () &#123; $(this).animate(&#123; width: 300 , height: 300 &#125; , 4000 , "linear",function () &#123; alert(123); &#125;);&#125;);$('#div1').stop(); // 默认: 只会阻止当前运动，链式操作时不会阻止下一个动画 $('#div1').stop(true); // 阻止当前和后续所有的运动$('#div1').stop(true, true); // 立即停止当前和后续所有的动画并移动至当前动画的终点$('#div1').finish(); // 立即停止当前和后续所有的动画并移动到所有动画的终点$('#div1').delay("400"); // 延时，参数可以是数字或字符串if(!$(element).is(":animated"))&#123;&#125; else&#123;&#125; // 判断当前元素是否在执行jq动画animate 练习： 1. 做一个多个图片输入移入凸显效果 2. 做一个左侧导航折叠效果 3. 无缝滚动和3个一组的轮播图 4. 淘宝好评 1234567891011121314151617&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 淘宝打评价 $("li").on("click", function () &#123; $(this).css("backgroundColor", "red"); $(this).prevAll().css("backgroundColor", "red"); $("p").html(($(this).prevAll().length + 1) + "星"); &#125;);&lt;/script&gt; CSS部分： 123456789101112ul &#123; margin: 0; padding: 0; list-style: none;&#125;li &#123; float: left; width: 30px; height: 30px; border: 1px #000 solid; margin-right: 3px; borde]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-2-DOM操作和事件操作]]></title>
    <url>%2F2019%2F09%2F28%2FjQuery-2-DOM%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JQ的DOM操作和事件操作 JQ的DOM操作 元素的移动：下面的方法前面的对象不同，链式操作的结果就不同 12345A.insertBefore(B)/A.before(B); // A放在B的前面/B放在A的前面A.insertAfter(B)/A.after(B); // A放在B的后面/B放在A的后面A.appendTo(B)/A.append(B); // A插到B的内容后/B插到A的内容后A.prependTo(B)/A.prepend(B); // A插到B的内容前/B插到A的内容前 元素的创建： 12$("&lt;li&gt;") //创建标签，如：$("&lt;li class='box'&gt;").appendTo($("ul")); 元素的删除： 12$("div").remove(); // 删除该节点$("div").detach(); // 跟remove方法一样，只不过会保留删除这个元素的操作 偏移值、父级及有定位的父级： 12345$("#div2").offset().left; // 获取元素到屏幕的左距离$("#div2").position().left; // 获取元素到有定位的父级的left值,把当前元素转化成类似定位元素.parent(); // 获取元素的父级元素.offsetParent(); // 获取元素最近的被定位的父级 JQ的遍历：each() 1234567$("li").each(function (i, elem) &#123; // 参数：下标, 每个元素 $(elem).html(i);&#125;);$("li").each(function (i, elem) &#123; // 参数：下标, 每个元素 $(this).html($(this).index()); // 与第一种结果相同&#125;); 判断真假方法：is()判断里面是否为真，返回布尔值，如: 12JQ对象.is(":checked"); // 判断单选/多选框是否被选中JQ对象.is(":animated"); // 判断对象是否在执行动画 事件操作： 事件的写法：前面说了JQ的事件没有on，除此以外还有一个on()方法绑定事件函数 1234567891011121314151617181920212223242526272829303132333435$('div').on('click',function () &#123; alert(123);&#125;); // 事件绑定，参数事件和事件函数$('div').on('click mouseover',function () &#123; alert(123);&#125;); // 第一个参数可以是多个事件(空格分隔)$('div').on(&#123; 'click' : function () &#123; alert(123); &#125;, 'mouseover' : function (&#123; alert(456); &#125;&#125;); // 也可以是对象，事件为属性，函数为值，一次为元素绑定多个事件函数$("div").one("click",function () &#123; alert(123);&#125;); // 只执行事件一次的事件方法$("div").off("mouseover"); // 解除绑定事件写法$(document).click(function () &#123; alert( $(window).scrollTop() );&#125;); // 滚动距离$(window).scroll(function () &#123;&#125;); // 滚动条事件$(document).scrollTop(0); // 滚动条赋值// 举例：$(window).on("scroll", function () &#123; console.log($(document).scrollTop());&#125;) 事件对象event：与原生js一样，JQ的事件对象也是传第一个参数ev，且没有兼容问题： 123456789101112131415161718$('div').mousedown(function (ev) &#123; // ev : event对象 &#125;);$(document).keydown(function (ev) &#123; // 键盘的event switch(ev.which) &#123; &#125;&#125;); ev.pageX/Y; // (相对于文档的) 鼠标坐标ev.clientX; // (相对于可视区) 鼠标坐标ev.which; // 原生的keyCode：键盘按键ev.preventDefault(); // 阻止浏览器默认事件ev.stopPropagation(); // 阻止事件冒泡的操作return false; // 阻止默认事件 + 阻止冒泡的操作 练习： 1. 做3个不同颜色的方块,鼠标移入第一个方块时,调换后两个方块的位置并让第二个div的内容变成第二个,点击时调换回来并让第三个div内容变成第三个 12345678910111213141516171819202122&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;div id="div2"&gt;&lt;/div&gt;&lt;div id="div3"&gt;&lt;/div&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 点击1，交换div1和div2的位置； // 点击2，把div1放进div3 // 点击3:，把div2放在div3的内容之后 $("button").eq(0).click(function () &#123; // 选择器选择位置，而不是id值 $("div").eq(0).insertAfter($("div").eq(1)); &#125;); $("button").eq(1).click(function () &#123; $("#div1").appendTo($("#div3")); &#125;); $("button").eq(2).click(function () &#123; $("#div2").appendTo($("#div3")); &#125;);&lt;/script&gt; ​ CSS部分： 12345678910#div1, #div2 &#123; width: 100px; height: 100px;&#125;#div1 &#123; background: red;&#125;#div2 &#123; background: blue;&#125; 2. 四个多选框，做一个点击多选框判断数量的效果，如果超过两个多选框被选中会提示最多选中两个多选框并取消选中 3. 做一个固定到页面右下角的按钮,点击时返回页面的顶部,要求该按钮只有在滚动距离超过200px时才能看见 4. 用JQ编写同一个元素既可以被鼠标拖拽，又可以上下左右控制元素移动 123456789101112131415$("div").mousedown(function (ev) &#123; var disX = ev.pageX - $("div").offset().left; var disY = ev.pageY - $("div").offset().top; $(document).mousemove(function (ev) &#123; $("div").css(&#123; "left": ev.pageX - disX + "px", "top": ev.pageY - disY + "px" &#125;); &#125;); // $(document).mouseup(function ()&#123; $("div").off("mousedown mousemove"); &#125;); return false;&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-1-选择器和常用方法]]></title>
    <url>%2F2019%2F09%2F28%2FjQuery-1-%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[jQuery选择器和常用方法 JQ简介 JQ是一个优秀的JS库，风靡web界很多年，是很多优秀库的参考标准之一。但它只是辅助工具，它可以简化JS的复杂操作；不用再需要关心兼容性问题；提供大量的实用方法。 JQ设计思想：模拟了CSS选择元素的方法，提供多种筛选方法，且有其独有表达式选择；属性函数化，链式操作，取值赋值合体；与js可以共存，但不能混用 ​ 官网：www.jquery.com； ​ 中文API：www.css88.com/jqapi-1.9 设计思想 选择器：与css的选择器非常类似，还增加了一些css没有的方法和筛选功能，如 12$('div'); // 字符串是css的选择器，如标签名、class以及包含选择器、css3选择器等$('li').filter('.box'); // 筛选方法filter，从选择到的元素中选取需要的，等同于多条件选择器li.box $()是JQ的一个全局函数，用来获取元素(JQ对象)，然后可以对其使用JQ方法(filter) 属性函数化：上面获取的JQ对象只能使用JQ的方法，不能使用原生JS的方法和属性，如： 12document.getElementById("div1").style.backgroundColor = "red";$('#div1').css('backgroundColor':'red'); 链式操作：方法依次执行，由于每个方法内部设置了return this，因此方法执行后依然得到该对象，可以继续执行其他方法，如： html()方法：传参数时，为div设置内容； 不传参数时，获取div中的内容 123$("#div1").html("hello").css("backgroundColor","red").click(function() &#123; $(this).css("backgroundColor", "blue");&#125;); JQ与JS对象 JQ选择器获取的是JQ对象，而JS获取的是原生DOM对象，他们不能混用，如: 12$('#div1').html = "123"; //报错document.getElementById("div1").css(); //报错 写法区别： 123456789101112131415window.onload = function () &#123;&#125;; //页面加载$(function()&#123;&#125;);document.getElementById("div1").onclick = function () &#123; alert(this.innerHTML); &#125;; //事件调用$("#div1").click(function () &#123; alert($(this).html()); &#125;); //原生this和JQ的this$("body").css("backgroundColor", "red");$("body").css(&#123; // 引入对象，可传参 "backgroundColor": "red", "color": "white"&#125;); 原生DOM对象和jquery对象的转换： js转jq方法：外面套一个$() jq转js原生方法：.get(n) / [n], 将集合的第n个对象提出来 12jq对象.get(i)/jq对象.[i] // 把jq对象转化为原生js对象，如jq对象[0]把第一个jq对象转化为原生DOM对象$(原生DOM对象) // 把原生DOM对象转化为jq对象 12345678oDiv1 = document.querySelector("#div1");// js转jq方法：外面套一个$()$(oDiv1).css("backgroundColor", "red"); // 只能是对象，不能是集合// jq转js原生方法：.get(n) / [n], 将集合的第n个对象提出来$("#div2").get(0).style.backgroundColor = "red";$("#div2")[0].style.backgroundColor = "red"; 常用方法： 筛选功能： 1234567891011121314$('div').filter('.box').css('background','red'); // 过滤（当前元素），从前者里筛选后者$('div').not('.box').css('background','red'); // filter的反义词，从前者里排除后者$('div').has('.box').css('background','red'); // 包含后代元素满足has的前者, 最后筛选到的是class为box的 div元素$('div').next().css('background','red'); // 下一个同级元素$('div').find('h2').eq(1).css('background','red'); // 后代元素中满足find的后代, 最后筛选到的只要class为h2的 元素就可以for (var i = 0; i &lt; $("li").length; i++) &#123; // console.log( $("li").eq(i).index() ); // 索引是当前元素在所有兄弟节点(具有相同父元素)中的位置 ， 控制所有的li console.log( $("li:eq(" + i + ")" ).index() ); // eq()第二种写法&#125; 属性方法：取值赋值合体，不传参为取值，传参为赋值 1234567891011121314151617$('div').css(); // 获取/修改元素的样式，2个参数时(字符串)：样式名和样式值；1个参数时(对象)：属性名为样式名，值为样式值$('input').val(); // 获取/修改表单元素的value值$('div').text(); // 获取/修改元素文本内容(不会获取标签)$('div').html(); // 获取/修改元素内容(会获取标签)$('div').size(); // 获取元素个数和length一样，length是JQ和js通用的属性，链式操作时用size()$('div').attr('title'); // 没有方法属性的取值方法$('div').attr('title','456'); // 没有方法属性的赋值方法$('div').addClass('box2 box4'); // class添加类名$('div').removeClass('box1'); // class移除类名 注意赋值的时候如果JQ对象是多个元素时会自动遍历(赋相同的值)，取值时则只会取集合中的第一个元素的值，如： 123456789101112&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("li").html("我是li"); // 赋值时自动遍历：所有li元素都显示"我是li"console.log($("li").index()); // 输出：0，只取第一个元素的下标&lt;/script&gt; 元素的尺寸：以宽为例，高同理 1234$('div').width(); // 内容width$('div').innerWidth(); // 内容 width + padding$('div').outerWidth(); // 内容 width + padding + border(即盒子)$('div').outerWidth(true); // 内容width + padding + border + margin(即盒子模型) 注意：原生js的offsetWidth等属性是获取不到隐藏元素的值，而outerWidth可以 事件方法：JQ的事件写法和事件监听写法相同(没有on)，和属性一样也写成方法，参数为事件函数： 123$('#div1').click(function () &#123;&#125;); // 点击事件$('#div1').hover(function () &#123;&#125;, function () &#123;&#125;); // 鼠标移入/移除可以合成hover事件，两个事件函数会在移入和移出时触发 JQ新增效果：下面方法不传时间参数时默认400毫秒 12345678910$('#div2').hide(3000); // 隐藏，参数为时间(毫秒)$('#div2').show(3000); // 展示，参数为时间(毫秒)$('#div2').fadeOut(1000); // 透明，参数为时间(毫秒)$('#div2').fadeIn(1000); // 不透明，参数为时间(毫秒)$('#div2').slideUp(800); // 收缩，参数为时间(毫秒)$('#div2').slideDown(800); // 展开，参数为时间(毫秒)$('#div2').fadeTo(1000, 0.5); // 透明度到，参数为时间(毫秒)和透明度 练习： 1. 利用JQ选择器做一个隔行变色效果 123456789101112&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("li.li1").css("backgroundColor", "blue"); &lt;/script&gt; 2. .li1元素显示“我是li1”，点击li元素背景颜色变红 12345678910111213&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="li1"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("li").click(function() &#123; $(this).css("backgroundColor", "red"); &#125;).filter(".li1").html("我是li1"); &lt;/script&gt; 3. 制作一个红色背景白色文字（div1）的div，当点击该元素时，背景色变成黄色，文字变成div2颜色为红色，再次点击时则变回来 4. 用三个按钮和三个div方块编写一个选项卡，要求按钮在选项卡切换时变化背景颜色 123456789101112131415161718&lt;div id="wrap"&gt; &lt;div id="ctrl"&gt; &lt;button class="active"&gt;aaaa&lt;/button&gt; &lt;button&gt;bbbb&lt;/button&gt; &lt;button&gt;cccc&lt;/button&gt; &lt;/div&gt; &lt;div id="content"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src = "jquery-1.10.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 用三个按钮和三个div方块编写一个选项卡，要求按钮在选项卡切换时变化背景颜色 var arr = ["我是aaaa的内容","我是bbbb的内容","我是cccc的内容"]; $("button").click(function () &#123; $("button").removeClass("active"); $(this).addClass("active"); $("#content").html(arr[$(this).index()]); &#125;);&lt;/script&gt; ​ CSS部分： 123456789101112131415161718192021222324#wrap &#123; width: 450px; border: 1px #000 solid;&#125;#ctrl &#123; overflow: hidden;&#125;button &#123; width: 150px; height: 40px; padding: 0; border: none; float: left; background: gray;&#125;button.active &#123; background: #fff; color: red;&#125;#content &#123; height: 200px; padding: 20px;&#125;]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 新标准4]]></title>
    <url>%2F2019%2F09%2F23%2FECMAScript-%E6%96%B0%E6%A0%87%E5%87%864%2F</url>
    <content type="text"><![CDATA[ECMAScript 新标准 - #### 数组新方法 forEach方法：(遍历数组) 用于调用数组的每个元素，并将元素传递给回调函数，返回值为 undefined。语法： 1array.forEach(function(currentValue, index, arr), thisValue); 参数1为回调函数，参数2可选参数为回调函数的this(不传为undefined)；回调函数的参数1为遍历数组的每个数据，参数2为下标，参数3为被遍历的数组： 1234567var arr = [1,2,3,4];arr.forEach(function(value, index, array) &#123; console.log(value, index, array); // 输出：1, 0, [1,2,3,4]; 2, 1, [1,2,3,4]... array[index] == value; // true sum += value; &#125;);console.log(sum); // 10 map方法：map()定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 123456789 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; function pow(x) &#123; return x * x; &#125; var newArr=arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] // 相当于arr的每个数据执行了一次pow方法 var arr1 = arr.map(item =&gt; **item); console.log(arr1); map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： 12 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var newArr=arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] // 只需要一行代码。 from方法：将两类对象转换为真正的数组：类似数组的对象和可遍历的对象，包括es6新增数据类型Set和Map。 1234567891011let arrLike = &#123; // 类数组（伪数组） "0": "a", "1": "b", "2": "c", length: 3&#125;var arr1 = [].slice.call(arrLike); // ES5console.log(arr1); var arr2 = Array.from(arrLike); // ES6console.log(arr2); // [a, b, c] from还可以接受第二个参数，相当于对返回的数组使用map方法，用来对每个元素进行处理： 12Array.from(arrLike, x =&gt; x * x); // 等同于Array.from(arrLike).map(x =&gt; x * x); 除此以外，该方法还可以用字符串或者数组作为参数，字符串会按照每个字符拆分（类似split(&quot;&quot;)方法），而数组则会得到一个相同的新对象（数组的深拷贝）： 123456 var arr1 = Array.from('hello world！'); console.log(arr1); // ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "！"]var arr = [1, 2, 3, 4]; var arr2 = Array.from(arr);console.log(arr2); // [1, 2, 3, 4] console.log(arr == arr2); // false reduce方法：Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，它必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用`reduce`实现： 1234 var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y; &#125;); // 25 要把[1, 3, 5, 7, 9]变换成整数13579，`reduce()`也能派上用场： 1234var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) &#123; return x * 10 + y; &#125;); // 13579 filter方法：filter也是一个常用操作，用于把Array的某些元素过滤掉，然后返回剩下的元素，和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素： 1234567891011 var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) &#123; return x % 2 !== 0; &#125;); console.log(r); // [1, 5, 9, 15] 删除数组中数据为偶数的项 var arr = ['A', '', 'B', null, undefined, 'C', ' '];arr = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // trim()方法：去掉前后空格 &#125;); // 注意：IE9以下的版本没有trim()方法 console.log(arr); // ['A', 'B', 'C'] 把数组中的无效字符串删掉 filter()接收的回调函数可以有多个参数。第一个参数表示Array的某个元素，另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; // 跟forEach()相同 console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 利用filter()，也可以去除Array的重复元素： 1234567'use strict'; var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index; // 如果元素第一次出现的位置和下标相同，则返回这个元素； 反之则被删除 &#125;); // 总是返回第一个 arr = arr.filter((element, index, self) =&gt; self.indexOf(element) == index); // 第二种表示方法 includes方法（ES7）：在ES5，Array提供了indexOf用来查找某个元素的位置，不存在返回-1，这个函数在判断数组是否包含某个元素时有两个不足，一个是它会返回-1和元素的位置来表示是否包含，在定位方面是没问题，就是不够语义化。另一个问题是不能判断是否有NaN的元素(原因：NaN !== NaN)。 12const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN];console.log(arr1.indexOf(NaN)); // 结果：-1 includes方法判断是否包含某一元素，除了不能定位外，解决了indexOf上面的问题。它返回true或false表示是否包含元素，对NaN一样有效。如： 12345const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN];console.log('%s', arr1.includes('c'))console.log('%s', arr1.includes('z'))console.log('%s', arr1.includes(NaN))// 结果：true false true includes()函数的第二个参数表示判断的起始位置。如： 12345const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN];console.log('%s', arr1.includes('d', 1))console.log('%s', arr1.includes('d', 3))console.log('%s', arr1.includes('d', 4))// 结果：true true false 第二个参数也可以是负数，表示从右数过来第几个，但是不改变判断搜索的方向，搜索方向还是从左到右。 练习： 1. 用数组的map方法封装一个参数为时间对象，返回值为时间格式（如：输出2019/04/23 16:51:04） 12 2. 用数组的from方法去一个数组的去重 123456789var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];var arr1 = new Set(arr); // 先创建 Set ，把数组变成键， 去重console.log(arr1); // 输出：Set(5) &#123;"apple", "strawberry", "banana", "pear", "orange"&#125;var arr2 = Array.from(arr1); // 再把 set 转换为数组console.log(arr2); // 输出： ["apple", "strawberry", "banana", "pear", "orange"]// 简化var arr1 = Array.from(new Set(arr));console.log(arr1);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 新标准3]]></title>
    <url>%2F2019%2F09%2F23%2FECMAScript-%E6%96%B0%E6%A0%87%E5%87%863%2F</url>
    <content type="text"><![CDATA[ECMAScript 新标准 - #### 新函数写法 箭头函数：ES6新增了一种新的函数：Arrow Function(箭头函数)。它的定义用的就是一个箭头：x =&gt; x * x 这个箭头函数相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。但箭头函数可以替换函数表达式，但是不能替换函数声明。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return： 123456789101112131415x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;;(x, y) =&gt; x * x + y * y // 不是一个参数要加括号() =&gt; 3.14 // 无参数为一个空括号x =&gt; &#123; foo: x; &#125; // SyntaxError，返回对象报错，因为和函数体的&#123; &#125;有语法冲突，所以要改为：x =&gt; (&#123; foo: x; // 返回对象 &#125;) 箭头函数看上去是匿名函数的一种简写，但箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，也就是外层调用者obj。由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定。箭头函数的this不受函数内部影响 1234567891011document.onclick = function () &#123; // 这里的this指向document setTimeout(function() &#123; console.log(this); // 此时this指向window，这个匿名函数相当于直接调用，和document.onclick = function()无关 &#125;,1000); // 换成箭头函数 setTimeout(() =&gt; &#123; console.log(this); // 此时this指向document,跟它的上一级document.onclick = function()相同 &#125;,1000);&#125; 12345678910var person = &#123; // ES5 name: 'tom', getName: function() &#123; return this.name; &#125; &#125; const person = &#123; // ES6 name: 'tom', getName: () =&gt; this.name; &#125; 在ES6中，会默认采用严格模式，因此this也不会自动指向window对象了，而箭头函数本身并没有this，因此this就只能是undefined，这种情况，如果你还想用this，就不要用使用箭头函数的写法。除此之外，箭头函数中也无法访问`arguments`对象。 函数默认参数：之前我们不能直接为函数指定默认参数，因此很多时候为了保证传入的参数具备一个默认值，我们常常使用如下的方法： 123456function add(x, y) &#123; var x = x || 20; var y = y || 30; return x + y;&#125;console.log(add()); // 50 上面这种方式有缺点，比如当我传入一个x值为false，这个时候仍然会取到默认值，就不是我们的本意了。 ES6函数默认值写法： 12345function add(x = 20, y = 30) &#123; // ES6默认值 return x + y; &#125;console.log(add()); // 输出 50 （取默认值）console.log(add(1, 2)); // 输出 3 generator(生成器) generator：ES6的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 函数执行过程中，如果没有遇到return语句，控制权无法交回被调用的代码。定义如下： 12345 function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; 和函数不同的generator由function*定义，除了return语句，还可以用yield返回多次。 要编写一个产生斐波那契数列的函数，可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738 function fib(max) &#123; // 函数只能返回一次，必须返回一个Array var a = 0, b = 1, c = 0; var arr = []; arr.push(a, b); while (arr.length &lt; max) &#123; c = a + b; a = b; b = c; arr.push(c); &#125; return arr; &#125; fib(5); // 测试结果[0, 1, 1, 2, 3] function* fib(max) &#123; // generator就可以一次返回一个数，不断返回多次 var c = 0, a = 0, b = 1; for (var i = 0; i &lt; n; i++) &#123; yield a; // 返回a c = a + b; a = b; b = c; &#125; return a; &#125; fib(5); // fib &#123;[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window&#125; // fib(5)仅仅是创建了一个generator对象，还没有去执行它，一个方法是不断地调用next()方法： var f = fib(5); // done为false时就是yield的返回值，而不是return 的返回值 console.log(f.next()); // &#123;value: 0, done: false&#125; f.next(); // &#123;value: 1, done: false&#125; f.next(); // &#123;value: 1, done: false&#125; f.next(); // &#123;value: 2, done: false&#125; // value就是yield的返回值 f.next(); // &#123;value: 3, done: true&#125; // done表示这个generator是否已经执行结束了 f.next(); // &#123;value: undefined, done: true&#125; // 为true时value就是return的返回值，并且执行完毕，不要再调用next()了 // 第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done for (var x of fib(5)) &#123;console.log(x); &#125; // 依次输出0, 1, 1, 2 1234567891011121314151617181920&lt;font color=&quot;red&quot;&gt;这里需要注意，一旦`next`方法的返回对象的done属性为true，`for...of`循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的3，不包括在for...of循环之中。&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;**我们可以让函数内部无限循环，但是调用时限制范围：**&lt;/font&gt;```jsfunction* fibonacci() &#123; let [a, b] = [0,1]; for(;1;) &#123; // 1为true, 无限循环 [a, b] = [b, a + b]; yield b; &#125;&#125;var i = 0;for (let n of fibonacci()) &#123; // 直接用for ... of循环迭代generator对象 console.log(n); i++; if (i==5) &#123; // 限制范围 break; &#125;&#125; 类和继承 class（类）：ES6为我们创建对象提供了新的语法，这就是Class语法。如果你对ES5中面向对象的方式比较熟悉的话，Class掌握起来也是非常迅速的，因为除了写法的不同，它并不会增加新的难以理解的知识点。 1234567891011121314151617181920// ES5function Person(name, age) &#123; // 构造函数 this.name = name; this.age = age; &#125; Person.prototype.getName = function() &#123; // 原型方法 return this.name; &#125; // ES6 class Person &#123; // Person不是构造函数了 constructor(name, age) &#123; // 构造函数 this.name = name; this.age = age; &#125; getName() &#123; return this.name; &#125; // 原型方法&#125; // 创建实例并调用 var xiaoming = new Person(“小明”， 18); xiaoming.getName(); 12345678910111213141516171819202122232425- &lt;font color=&quot;orange&quot;&gt;**继承 `extends`**&lt;/font&gt;：ES6的继承就要简单很多 ```js class Person &#123; // Student类继承Person类 constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName() &#123; return this.name; &#125; &#125; class Student extends Person &#123; // 继承 constructor(name, age, classes) &#123; super(name, age); // 相当于ES5中的Person.call(this); this.classes = classes; &#125; getClasses() &#123; return this.classes; &#125; &#125; var xiaoming = new Student(&quot;小明&quot;, 14, 2); console.log(xiaoming.getClasses()); // 输出：2 console.log(xiaoming.getName()); // 输出：小明 只需要一个`extends1`关键字，就可以实现继承了，不用像ES5那样去担心构造函数继承和原型继承，除此之外，我们还需要关注一个叫做`super`的方法。在继承的构造函数中，我们必须如上面的例子那么调用一次`super`方法，它表示构造函数的继承，与ES5中利用`call/apply`继承构造函数是一样的功能。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 新标准2]]></title>
    <url>%2F2019%2F09%2F23%2FECMAScript-%E6%96%B0%E6%A0%87%E5%87%862%2F</url>
    <content type="text"><![CDATA[解构 解构（解析结构）：解析结构是一种全新的写法，我们看下面一个例子 123456789101112const props = &#123; className: 'tiger-button', loading: false, clicked: true, disabled: 'disabled'&#125;// 当我们想要取得其中的2个值：loading与clicked时：var loading = props.loading; // ES5var clicked = props.clicked;const &#123; loading, clicked &#125; = props; //ES6// 给一个默认值，当props对象中找不到loading时，loading就等于该默认值const &#123; loading = false, clicked &#125; = props; 数组也有属于自己的解析结构 123456var arr = [1, 2, 3];// es5var a = arr[0];var b = arr[1];var c = arr[2];const arr = [1, 2, 3];// es6const [a, b, c] = arr; 数组以序列号一一对应，这是一个有序的对应关系。而对象根据属性名一一对应，这是一个无序的对应关系。根据这个特性，使用解析结构从对象中获取属性值更加具有可用性。 展开运算符 在ES6中用...来表示展开运算符，它可以将数组方法或者对象进行展开。 12345const arr1 = [1, 2, 3];const arr2 = [...arr1, 10, 20, 30];// 这样，arr2 就变成了[1, 2, 3, 10, 20, 30]; 对象也可以这样展开：const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;const obj2 = &#123; ...obj1, d: 4, e: 5, f: 6 &#125;; // &#123; a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 &#125; 展开运算符还常常运用在解析结构之中，例如我们在封装组件的时候常常不确定props到底还有多少数据会传进来，就会利用展开运算符来处理剩余的数据。 123const props = &#123; size: 1, src: 'xxxx', mode: 'si' &#125;;const &#123; size, ...others &#125; = props;console.log(others); // 输出除了size之外的部分 展开运算符还用在函数的参数中，来表示函数的不定参。只有放在最后才能作为函数的不定参，否则会报错。之前由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： 12345678910111213141516171819function foo(a, b) &#123; var i, more = []; if (arguments.length &gt; 2) &#123; for (i = 2; i &lt; arguments.length; i++) &#123; more.push(arguments[i]); &#125; &#125; console.log('a = ' + a); console.log('b = ' + b); console.log(more);&#125;//这种写法很别扭，只是为了获得额外的more参数，用ES6标准将上面的函数改写为：function foo(a, b, ...more) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(more);&#125;foo(1, 2, 3, 4, 5); // 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1); // 结果:// a = 1// b = undefined// Array [] 定义对象属性 Object.defineProperty(obj, prop, descriptor)，参数一为定义属性的对象，参数二为要定义或修改的属性名，参数三为属性描述符(配置) 该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for...in 或Object.values 方法），这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项(或配置)。默认情况下，使用 Object.defineProperty()添加的属性值是不可修改的。 对象的数据属性Configurable,Enumerable,Writable,Value： 123456789101112131415161718192021var person = &#123;&#125;;Object.defineProperty(person,'name',&#123; configurable:false, //为 true 时，该属性描述符才能够被改变和被删除。默认为 false。 enumerable:false, //为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 writable:false, //为true时，value才能被赋值运算符改变。默认为 false。 value:'xiaoming', //该属性的值。可以是任何有效的 JavaScript 值。默认为 undefined。&#125;); console.log(person); //xiaoming，value值person.name="qiang";console.log(person); //xiaoming，writable为false不可修改valuefor(var attr in person)&#123; console.log(person[attr]); //无结果，enumerable为false不可循环&#125;delete person.nameconsole.log(person.name)//xiaoming，configurable为false不可删除Object.defineProperty(person,'name',&#123; configurable:true //configurable为false不可修改，将抛出错误&#125;); 访问器属性getter，setter。 get：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 12345678910111213141516171819var book = &#123; _year: 2004, // 属性前面加_，代表属性只能通过对象方法访问 edition: 0&#125;Object.defineProperty(book,'year',&#123; get: function()&#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004 &#125; &#125;&#125;);console.log(book.year); // 2004book.year = 2006;console.log(book.year); // 2006console.log(book.edition); // 2 Object.getOwnPropertyDescriptors(ES8)：返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。参数1为目标对象，参数2可选参数为属性名，这个方法返回的值可能是configurable、enumerable、writable、get、set 和 value。 1234567891011let azatsBooks = &#123; books: ['React Quickly'], get latest () &#123; let numberOfBooks = this.books.length; if (numberOfBooks == 0) &#123;return undefined;&#125; return this.books[numberOfBooks - 1] &#125;&#125;console.log(Object.getOwnPropertyDescriptor(azatsBooks, 'books'));console.log(Object.getOwnPropertyDescriptor(azatsBooks, 'latest'));console.log(Object.getOwnPropertyDescriptors(azatsBooks));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 新标准]]></title>
    <url>%2F2019%2F09%2F23%2FECMAScript-%E6%96%B0%E6%A0%87%E5%87%861%2F</url>
    <content type="text"><![CDATA[ECMAScript 新标准 - #### ECMAScript X新标准(简称ESx，如ES6) ES5于2009年发布，并且之后JavaScript开始了神奇的崛起之路。之后2015年发布了ES6，2016年发布了ES7，ES8 或称 ES2017 在六月底的时候由TC39委员会正式发布。在我们的课件里，知识点后面标准了ES7和ES8的就说明是该标准的知识，没标注的就是ES6 浏览器发布时就确定了JavaScript的版本，加上有用户还在使用IE6这种古老的浏览器，这导致你在写JavaScript的时候要照顾一下老用户，最新的ES标准在老用户的浏览器上是无法运行的。 strict模式(js的严格模式)，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误，启用strict模式的方法是在JavaScript代码的第一行写上： 1'use strict'; 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript 测试一下你的浏览器是否能支持strict模式： 123'use strict'; // 如果支持strict模式代码将报ReferenceError错误:abc = 'Hello, world';alert(abc); //如果不报错，说明你的浏览器需要升级 ES6深入学习地址：http://es6.ruanyifeng.com/ 新写法 求幂运算符**（ES7）： 12347 ** 3; // 相当于7*7*7Math.pow(7,3); // ES5的写法var a = 7;a **= 4; // 等同于a = a ** 4; 多行字符串(模板字符串)：由于多行字符串用\n写起来比较费事，所以ES6标准新增了一种多行字符串的表示方法，用``（1左侧的键）表示： 1234567alert(`多行字符串测试`);//字符串拼接方法(模板字符串同样可以用老的字符串拼接方法拼接)：var name1 ="Mike"; var age1=20;var message1="hello," + name1 + ",your age is " + age1; //ES5var message1=`hello,$&#123;name1&#125;,your age is $&#123;age1&#125;`; //ES6 字符串填充(ES8)：String padding方法在String object中加入了两个函数：padStart 和 padEnd，即填充开头和填充结尾，参数有两个，第一个参数为新字符串的长度，第二个为填充的字符(缺省时默认值为空字符串)，增加的长度超出pad的长度时会重复出现，新长度小于原字符串长度时不会变化: 12345var str = "我是一段小说";var pad = "——新卓越";console.log(str.padStart(8)); //" 我是一段小说"console.log(str.padEnd(str.length+pad.length,pad)); //"我是一段小说——新卓越"console.log(str.padEnd(14,pad)); //"我是一段小说——新卓越——新" let与const声明：JavaScript的变量作用域实际上是函数内部，在for循环等语句块中无法定义具有局部作用域的变量，为解决块级作用域，ES6引入了新关键字let，用let替代var可以申明块级作用域的变量 1234567function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1; // SyntaxError,i未被定义&#125; 在ES6之前是不能申明一个常量的，可以用全部大写的变量来表示”这是一个常量，不要修改它的值”。新的关键字const用来定义常量，const与let一样都具有块级作用域。现在我们常用let来声明一个值会被改变的变量，用const来声明一个值不会被改变的变量，也就是常量。使用const的场景要比使用let的场景多很多。 123const obDev = &#123; a: 20, b: 30 &#125;;obDev.a = 30;console.log(obDev); // Object &#123;a: 30, b: 30&#125; 上面的例子中当值为基础数据类型时，那么这里的值就是指值本身。而当值对应的为引用数据类型时，那么这里说的值则表示指向该对象的引用。这里需要注意，正因为该值为一个引用，只需要保证引用不变就可以，我们仍然可以改变该引用所指向的对象。 对象字面量：ES6针对对象字面量做了许多简化语法的处理，如： 12345678var width = 10;var height = 20;var bg = 30;var json = &#123;width:width,height:height,bg:bg&#125;; //ES5var json = &#123;width,height,bg&#125;; //ES6// 除了属性之外，对象字面量写法中的方法也可以有简写方式：var json = &#123;fnName:function ()&#123;alert(123)&#125;&#125; //ES5var json = &#123;fnName()&#123;alert(123)&#125;&#125; //ES6 新类型 JavaScript的对象的键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的，ES6标准引入了新的数据类型Map和Set。 Map——是一组键值对的结构，具有极快的查找速度。假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 123456var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; //查找"Michael"的成绩先要找到在第一个数组中的下标，再在另一个数组中根据下标找到对应数据，Array越长，耗时越长//如果用Map实现，只需要一个"名字"-"成绩"的对照表，无论这个表有多大，查找速度都不会变慢var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。 Map具有以下方法： 1234567var m = new Map(); // 声明空Mapm.set('Adam', 67); // 添加方法m.set('Bob', 59);m.has('Adam'); // 判断方法，返回布尔值m.get('Adam'); // 取值方法m.delete('Adam'); // 删除方法m.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖 Set——和Map类似，也是key的集合，但不存储value。由于key不能重复，所以，在Set中没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：(可以用做去重) 123456var s = new Set(); // 声明空Setvar s = new Set([1, 2, 3, 3, '3']);//重复元素在Set中自动被过滤console.log(s); // Set &#123;1, 2, 3, '3'&#125;s.add(4); //添加方法，可以重复添加，但不会有效果s.delete(3); //删除方法console.log(s); // Set &#123;1, 2, '3', 4&#125; iterable类型和for ... of循环：遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历： 1234var a = [1, 2, 3];for (var x of a) &#123; alert(x); &#125; 你可能会问，for ... of循环和for ... in循环有何区别？for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性，当我们手动给Array对象添加了额外的属性后，for … in循环会将给Array添加的属性一起遍历 枚举(ES8)：Object.values and Object.entries。 Object.values方法返回一个指定对象可枚举属性值的数组，与for ... in类似， 1234Object.values(&#123; x: 'xxx', y: 1 &#125;); // ['xxx', 1]Object.values(['e', 's', '8']); // ['e', 's', '8']Object.values(&#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;); // ['yyy', 'zzz', 'xxx']，按照下标的顺序Object.values('es8'); // ['e', 's', '8']，有长度的伪对象也可以枚举 和Object.values类似，Object.entries方法返回一个给定对象可枚举属性值的数组[key, value] 1234Object.entries(&#123; x: 'xxx', y: 1 &#125;); // [['x', 'xxx'], ['y', 1]]Object.entries(['e', 's', '8']); // [['0', 'e'], ['1', 's'], ['2', '8']]Object.entries(&#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;); // [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']]]]></content>
      <tags>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js键盘键值]]></title>
    <url>%2F2019%2F09%2F16%2Fjs%E9%94%AE%E7%9B%98%E9%94%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[js键盘键值大全keycode 8 = BackSpace BackSpacekeycode 9 = Tab Tabkeycode 12 = Clearkeycode 13 = Enterkeycode 16 = Shift_Lkeycode 17 = Control_Lkeycode 18 = Alt_Lkeycode 19 = Pausekeycode 20 = Caps_Lockkeycode 27 = Escape Escapekeycode 32 = space spacekeycode 33 = Priorkeycode 34 = Nextkeycode 35 = Endkeycode 36 = Homekeycode 37 = Leftkeycode 38 = Upkeycode 39 = Rightkeycode 40 = Downkeycode 41 = Selectkeycode 42 = Printkeycode 43 = Executekeycode 45 = Insertkeycode 46 = Deletekeycode 47 = Helpkeycode 48 = 0 equal bracerightkeycode 49 = 1 exclam onesuperiorkeycode 50 = 2 quotedbl twosuperiorkeycode 51 = 3 section threesuperiorkeycode 52 = 4 dollarkeycode 53 = 5 percentkeycode 54 = 6 ampersandkeycode 55 = 7 slash braceleftkeycode 56 = 8 parenleft bracketleftkeycode 57 = 9 parenright bracketrightkeycode 65 = a Akeycode 66 = b Bkeycode 67 = c Ckeycode 68 = d Dkeycode 69 = e E EuroSignkeycode 70 = f Fkeycode 71 = g Gkeycode 72 = h Hkeycode 73 = i Ikeycode 74 = j Jkeycode 75 = k Kkeycode 76 = l Lkeycode 77 = m M mukeycode 78 = n Nkeycode 79 = o Okeycode 80 = p Pkeycode 81 = q Q atkeycode 82 = r Rkeycode 83 = s Skeycode 84 = t Tkeycode 85 = u Ukeycode 86 = v Vkeycode 87 = w Wkeycode 88 = x Xkeycode 89 = y Ykeycode 90 = z Zkeycode 96 = KP_0 KP_0keycode 97 = KP_1 KP_1keycode 98 = KP_2 KP_2keycode 99 = KP_3 KP_3keycode 100 = KP_4 KP_4keycode 101 = KP_5 KP_5keycode 102 = KP_6 KP_6keycode 103 = KP_7 KP_7keycode 104 = KP_8 KP_8keycode 105 = KP_9 KP_9keycode 106 = KP_Multiply KP_Multiplykeycode 107 = KP_Add KP_Addkeycode 108 = KP_Separator KP_Separatorkeycode 109 = KP_Subtract KP_Subtractkeycode 110 = KP_Decimal KP_Decimalkeycode 111 = KP_Divide KP_Dividekeycode 112 = F1keycode 113 = F2keycode 114 = F3keycode 115 = F4keycode 116 = F5keycode 117 = F6keycode 118 = F7keycode 119 = F8keycode 120 = F9keycode 121 = F10keycode 122 = F11keycode 123 = F12keycode 124 = F13keycode 125 = F14keycode 126 = F15keycode 127 = F16keycode 128 = F17keycode 129 = F18keycode 130 = F19keycode 131 = F20keycode 132 = F21keycode 133 = F22keycode 134 = F23keycode 135 = F24keycode 136 = Num_Lockkeycode 137 = Scroll_Lockkeycode 187 = acute gravekeycode 188 = comma semicolonkeycode 189 = minus underscorekeycode 190 = period colonkeycode 192 = numbersign apostrophekeycode 210 = plusminus hyphen macronkeycode 211 =keycode 212 = copyright registeredkeycode 213 = guillemotleft guillemotrightkeycode 214 = masculine ordfemininekeycode 215 = ae AEkeycode 216 = cent yenkeycode 217 = questiondown exclamdownkeycode 218 = onequarter onehalf threequarterskeycode 220 = less greater barkeycode 221 = plus asterisk asciitildekeycode 227 = multiply divisionkeycode 228 = acircumflex Acircumflexkeycode 229 = ecircumflex Ecircumflexkeycode 230 = icircumflex Icircumflexkeycode 231 = ocircumflex Ocircumflexkeycode 232 = ucircumflex Ucircumflexkeycode 233 = ntilde Ntildekeycode 234 = yacute Yacutekeycode 235 = oslash Oobliquekeycode 236 = aring Aringkeycode 237 = ccedilla Ccedillakeycode 238 = thorn THORNkeycode 239 = eth ETHkeycode 240 = diaeresis cedilla currencykeycode 241 = agrave Agrave atilde Atildekeycode 242 = egrave Egravekeycode 243 = igrave Igravekeycode 244 = ograve Ograve otilde Otildekeycode 245 = ugrave Ugravekeycode 246 = adiaeresis Adiaeresiskeycode 247 = ediaeresis Ediaeresiskeycode 248 = idiaeresis Idiaeresiskeycode 249 = odiaeresis Odiaeresiskeycode 250 = udiaeresis Udiaeresiskeycode 251 = ssharp question backslashkeycode 252 = asciicircum degreekeycode 253 = 3 sterlingkeycode 254 = Mode_switch]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css不常用的属性]]></title>
    <url>%2F2019%2F09%2F15%2Fcss%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[a标签： 将a标签中的文字右移30px： text-indent: 30px; 将a标签中的文字左移30px： text-indent: -30px; 去除默认下划线：text-decoration: none; 设置下划线： text-decoration: underline; input标签： 设置placeholder的文字颜色和大小：（考虑兼容性） WebKit browsers：::-webkit-input-placeholder Mozilla Firefox 19+: ::-moz-placeholder Internet Explorer 10+: ::-ms-input-placeholder 取消input获得焦点时的蓝色边框：outline: none; 改变input标签光标的颜色，但不改变字体的颜色：caret-color: red;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型和原型链]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[js原型和原型链 - #### 原型和原型链： 每个对象都连接到一个原型对象，并可从中继承属性。所有通过字面量创建的对象都具有同一个原型对象——Object.prototype既原型对象的引用。通过new关键字后跟构造函数创建的对象的原型，就是构造函数的prototype属性的值，比如通过new Object()创建的对象和字面量创建的对象一样也继承自Object.prototype 12345678 var sum = &#123; name: "百度", type: "加法" &#125; // 创建原型对象的一个方法：Object.prototype.add = function()&#123; alert("原型对象的方法"); &#125; sum.add(); // 在sum上调用原型对象的方法 构造器(constructor，包括: Object；Function；Array；Date；String等函数)才有prototype属性，对象(除Object外)都拥有__proto__。构造器才有原型对象 而javascript中的对象就是一个指向prototype的指针和一个自身的属性列表。 原型链继承就是创建一个新的指针，指向构造器的prototype属性 用一张图来表示：prototype(原型)、constructor(构造器)、__proto__(构造器的原型——constructor.prototype) 所谓原型链，指的就是图中的__proto__这一条指针链！原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的(null)。 12345 var A = function()&#123;&#125;;var a = new A(); console.log(a.__proto__); // A &#123;&#125; (即构造器function A 的原型对象) console.log(a.__proto__.__proto__); // Object &#123;&#125; (即构造器function Object 的原型对象) console.log(a.__proto__.__proto__.__proto__); // null prototype、_proto_的区别以及_proto_的指向： 1234567891011var a = &#123;&#125;; //字面量方式console.log(a.__proto__); //Object &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //truevar A = function()&#123;&#125;; //构造器方式var a = new A();console.log(a.__proto__); //A &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //truevar a1 = &#123;a:1&#125;; //Object.create()方式var a2 = Object.create(a1);console.log(a2.__proto__); //Object &#123;a: 1&#125;console.log(a.__proto__ === a.constructor.prototype); //false(此处即为图1中的例外情况) 原型链继承： 这是实现继承最简单的方式了，核心就一句话： 1234567891011121314function Super()&#123; // 父类构造函数 this.val = 1; this.arr = [1];&#125;function Sub()&#123;// ...&#125; // 子类构造函数Sub.prototype = new Super(); // 核心var sub1 = new Sub();var sub2 = new Sub();sub1.val = 2;sub1.arr.push(2);alert(sub1.val); // 2alert(sub2.val); // 1alert(sub1.arr); // 1, 2alert(sub2.arr); // 1, 2 核心：拿父类实例来充当子类原型对象 优缺点： 优点：简单，易于实现； 缺点： 1、修改sub1.arr后sub2.arr也变了，因为来自原型对象的引用属性是所有实例共享的； 2、创建子类实例时，无法向父类构造函数传参 练习： 1. 创建一个dog类，包含共有属性：name、age和varieties。在该类的原型对象上增加一个color属性和值，用for in遍历对象属性，然后通过document.write输出对象的全部属性和值 使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问 1234567891011function Dog(name,age,varieties) &#123; this.name = name, this.age = age, this.varieties = varieties&#125;Dog.prototype.color = "blue";var dog = new Dog("大黄", 5, "泰迪");console.log(dog);for (var i in dog) &#123; document.write(dog[i] + " ");&#125; 2. Array.prototype.slice.call()的方法可以将一个伪数组(类数组)转换成真正的数组，先将伪数组转换成数组，并在它的构造器的原型上添加一个numSort方法，该方法按照数组的数字大小进行正序排列(提示：不用sort方法，用冒泡排序)，并且指出在转换之前它的构造器是谁，转换之后构造器又是谁？ 12345678910111213141516171819202122232425var arr = &#123; "0":111, "1":22, "2":3, "length":3&#125;;console.log(arr.__proto__); // 输出类数组构造器原型 =&gt; objectarr = Array.prototype.slice.call(arr); // 伪数组转换为数组console.log(arr.__proto__); // 输出数组构造器原型 =&gt; arrayArray.prototype.numSort = function () &#123; // 冒泡排序 for (var i = 0; i &lt; this.length - 1; i++) &#123; for (var j = 0; j &lt; this.length - 1 -i; j++) &#123; if (this[j] &gt; this[j+1]) &#123; var temp = this[j]; this[j] = this[j+1]; this[j+1] = temp; &#125; &#125; &#125; console.log(this);&#125;arr.numSort();var arr1 = [1,4,3,2,8,0,9];arr1.numSort(); 3. 创建一个animal父类(共有属性color、sex)，一个dog子类(共有属性name和wang())和一个cat子类(共有属性name和miao())，分别用两个子类创建一个实例，要求该实例可以通过继承为其设置color和sex，并用子类的共有属性设置对应属性和方法]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js组合继承和beget函数]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%92%8Cbeget%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[js组合继承和beget函数 - #### 借用构造函数： 原型链继承存在2个致命缺点，于是出现了借用构造函数方法： 1234567891011121314151617function Super(val) &#123; this.val = val; this.arr = [1]; this.fun = function() &#123;...&#125;&#125;function Sub(val) &#123; Super.call(this, val); // 核心 // ...&#125;var sub1 = new Sub(1);var sub2 = new Sub(2);sub1.arr.push(2);alert(sub1.val); // 1alert(sub2.val); // 2alert(sub1.arr); // 1, 2alert(sub2.arr); // 1alert(sub1.fun === sub2.fun); // false 核心：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了(完全没有用到原型) 优缺点：优点：1、解决了子类实例共享父类引用属性的问题；2、创建子类实例时，可以向父类构造函数传参缺点：无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能。 组合继承(最常用)： 目前我们的借用构造函数方式还是有问题(无法实现函数复用)，于是又搞出了组合继承： 1234567891011121314function Super(val) &#123; // 只在此处声明基本属性和引用属性 this.val = val, this.arr = [1]&#125;Super.prototype.fun1 = function()&#123;&#125;; // 在此处声明函数Super.prototype.fun2 = function()&#123;&#125;; // Super.prototype.fun3...function Sub(val) &#123; Super.call(this, val); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub(1);var sub2 = new Sub(2);alert(sub1.fun1 === sub2.fun1); // true 核心：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用 优缺点： 优点：1、不存在引用属性共享问题；2、可传参；3、函数可复用 缺点：子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。内存浪费，虽然比刚才情况好点，不过确实是瑕疵 寄生组合继承(最佳方式)： 从名字就能看出又是对组合继承的优化，为了追求完美而创建的方法： 123456789101112131415161718192021function beget(obj)&#123; // 生孩子函数 beget：龙beget龙，凤beget凤。 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;Super.prototype.fun1 = function()&#123;&#125;; // 在此处声明函数Super.prototype.fun2 = function()&#123;&#125;; //Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;var proto = beget(Super.prototype); // 核心proto.constructor = Sub; // 核心Sub.prototype = proto; // 核心var sub = new Sub();alert(sub.val);alert(sub.arr); 核心：用beget(Super.prototype);切掉了原型对象上多余的那份父类实例属性 优缺点：优点：完美了缺点：除了用起来麻烦，另一方面是因为寄生组合式继承出现的比较晚，所以组合继承是最常用的，而这个理论上完美的方案却只是课本上的最佳方式了 beget函数 原型式：完美方案用到了beget函数，也叫生孩子函数 12345678910111213141516function beget(obj) &#123; // 生孩子函数 beget：龙beget龙，凤beget凤。 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super() &#123; this.val = 1; this.arr = [1];&#125;var sup = new Super(); // 拿到父类对象var sub = beget(sup); // 生孩子 核心sub.attr1 = 1; // 增强sub.attr2 = 2; // sub.attr3...alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1 核心：用生孩子函数得到得到一个没有实例属性的新对象，再逐步增强之(填充实例属性)，ES5提供了Object.create()函数，内部就是原型式继承，IE9+支持 优缺点：优点：从已有对象衍生新对象，不需要创建自定义类型(更像是对象复制，而不是继承。。)缺点：1、原型引用属性会被所有实例共享，因为是用整个父类对象来充当了子类原型对象，所以这个缺陷无可避免；2、无法实现代码复用(新对象是现取的，属性是现添的，都没用函数封装，怎么复用) 寄生式：这是一种模式(套路)，并不是只能用来实现继承： 1234567891011121314151617181920function beget(obj)&#123; // 生孩子函数 beget：龙beget龙，凤beget凤。 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125;function getSubObject(obj)&#123; var clone = beget(obj); // 创建新对象 核心 clone.attr1 = 1; // 增强 clone.attr2 = 2; //clone.attr3... return clone;&#125;var sub = getSubObject(new Super());alert(sub.val); // 1alert(sub.arr); // 1alert(sub.attr1); // 1 核心：给原型式继承穿了个马甲而已，看起来更像继承了(上面介绍的原型式继承更像是对象复制)注意：beget函数并不是必须的，换言之，创建新对象 -&gt; 增强 -&gt; 返回该对象，这样的过程叫寄生式继承，新对象是如何创建的并不重要(用beget生的，new出来的，字面量现做的都可以) 优缺点：优点：还是不需要创建自定义类型缺点：无法实现函数复用(没用到原型，当然不行)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式量词匹配和面向对象]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%87%8F%E8%AF%8D%E5%8C%B9%E9%85%8D%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[js正则表达式量词匹配和面向对象 - #### 正则表达式匹配相似项：中括号 一组相似的元素，用[]表示，整体代表一个字符，如： 123var str = 'abc'; var re = /a[bde]c/; // []里面是或的关系alert(re.test(str)); 连字符(-)：可以是任意从大到小的范围，如[a-z0-9A-Z]，其中任意一个都匹配成功， 如： 123var str = 'abc'; var re = /a[a-z]c/;alert(re.test(str)); 排除(^)：若写在[]里面，则代表排除的意思，如： 123var str = 'abc'; var re = /a[^bde]c/;alert(re.test(str)); 限定开始位置(^)和限定结束位置($)，他们本身不占位置 正则表达式量词：大括号，匹配的字符最少和最多出现的数量 {4,7} ： 最少出现4次，最多出现7次 {4,}： 最少出现4次，最多不限 {4}： 恰好出现4次 特殊情况： +：出现至少1次，完整写法{1,} ?：出现0-1次，完整写法{0,1} *：至少出现0次，完整写法{0,}* 贪婪和非贪婪匹配：、+或?限定符都是贪婪的，因为它们会尽可能多的匹配文字，*只有在它们的后面加上一个?就可以实现非贪婪或最小匹配**。如我们想匹配一个字符串中的标签： 12var re = /&lt;.*&gt;/; // 贪婪：开始小于符号到最后一个大于符号之间的所有内容var re = /&lt;.*?&gt;/; // 非贪婪：第一个标签的头标签 面向对象、面向过程和构造函数： 面对对象：把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。 面向过程：自顶向下顺序执行，逐步求精；其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构；各模块之间的关系尽可能简单，在功能上相对独立；每一模块内部均是由顺序、选择和循环三种基本结构组成；其模块化实现的具体方法是使用子程序。程序流程在写程序时就已决定。 创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便的书写方式，我们之前经常使用’var 变量名 = 对象’这种方式创建一个变量。 js里没有类的概念，也就没有面向对象，但new的方法却模拟了面向对象，因此new(var 变量名 = new 函数())也就成了唯一能够区别一般函数和构造函数的方法。 若一个函数的返回值是引用类型(对象)的数据，作为构造函数用new运算符执行构造时，运算的结果将被返回值取代，其内的this值丢失了，取而代之的是被返回的对象；若一个函数的返回值是一个值类型(this或者非对象)，执行构造时，它的返回值将被丢弃，结果仍然是this所引用的对象： 123456789function demo() &#123; this.a = 10; // 成员变量 return function()&#123;return 1;&#125; //返回值是对象 // return 1; //返回值是值类型或undefined&#125;var m = new demo();var n = demo();alert(m); // 分别返回return后面的闭包和Objectalert(n); // 分别返回return后面的闭包和1 在用new来调用一个构造函数的时候，发生了下面四件事： var obj ={}; // 创建一个空对象obj obj.__proto__ = test.prototype; // 创建一个指向test.prototype（构造函数原型对象）的指针,__proto__：构造器原型 test.call(obj);// 将构造函数的作用域赋给新对象，因此m函数中的this指向新对象obj，然后再调用test函数。于是我们就给obj对象赋值了一个成员变量a，这个成员变量的值是1。除了call外，改变this指向的还有aplly，它们是函数调用的一种特殊方法。 return obj; // 返回新对象obj。 函数内的变量有如下分类： 其中例子中写成this.a代表类的成员变量(共有变量，实例变量，每个实例独立的存储) 函数名.b是类变量(函数的属性，静态变量，所有实例共享存储) 而var定义的则是局部变量(私有变量，函数执行时临时存储) instanceof：要求其左边是一个对象，右边是对象类的名字或构造函数。如果左边的object是class或构造函数的实例，则instanceof运算符返回true。如果左边的object不是指定class或函数的实例，或object为null，则返回false。 练习： 写一个去掉字符串中的前后空格的方法 输入框里输入标题aaaaa，通过匹配替换得到’标题aaaaa’ 将一串数字字符串加上千分符 查看以下正则并说出他们匹配的是什么 12345^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$ // 邮箱地址[a-zA-Z]+://[^\s]* // 网址[1-9][0-9]&#123;4,9&#125; // qq号^[1-9]\d&#123;5&#125;$ // 邮编[1-9]\d&#123;14&#125;|[1-9]\d&#123;17&#125;|[1-9]\d&#123;16&#125;x // 身份证号 下面的函数是不是构造函数(返回值为非对象)，若是则写出它的实例化对象oF，并判断oF是构造函数F的实例 123456function F() &#123; return true;&#125; // 返回值为非对象，因此是构造函数var oF = new F();console.log(oF instanceof F);console.log(oF instanceof Object);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式元字符和方法]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%83%E5%AD%97%E7%AC%A6%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js正则表达式元字符和方法 > 只能处理字符串 正则表达式的使用： 正则表达式，由人提供给计算机，让计算机能够读懂人类的规则。它的优缺点：可以大大简化代码；性能也比正常的函数方法要好；但只能操作字符串 为什么要用正则表达式，试着用字符串操作的方法实现一个获得一个字符串中所有连续的数字，并装进一个数组，字符串如下 12var str = 'haj123sdk54hask33dkhalsd879';str.match(/\d+/g); // 用正则表达式的方法实现 正则表达式的声明(两个//)：推荐使用字面量写法，这里/a/的a没有实际意义，就是为了防止计算机把它当成注释为占位用的 12var re = /a/; // 字面量写法var re = new RegExp('a'); // 构造函数实例化写法 正则表达式不能传参，或者说两个/里面的只是正则的规则，不能是字符串、布尔值甚至变量，因此如果我们想要传参，必须用构造函数实例化写法： 12var a = "abc";var re = new RegExp(a); 特殊元字符： \ : 转义字符 . : 匹配除了\n之外的任意一个字符(.真正的点) \n : 匹配换行符 \d : 0-9之间的任意一个数字(\d只占一个位置) \D: 匹配除了数字(\d)的所有字符 \w: 匹配数字，字母 ，下划线(0-9 a-z A-Z _) \W : 匹配除了数字，字母 ，下划线(0-9 a-z A-Z _)(\w)的字符 \s: 空格或者空白等（包含空格、制表符、换页符等） \S : 除了\s \b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数 \B : 匹配除了边界(\b ) \t ： 匹配一个制表符（一个TAB键：四个空格） ^ ： 以哪一个元字符作为开始 $ ： 以哪一个元字符作为结束 x|y ： x或者y中的一个字符 [xyz] ： x或者y或者z中的一个字符，如[asjhdeyuy] [^xy] ： 除了x/y以外的任意字符 [a-z] ： 指定a-z这个范围中的任意字符，如[0-9a-zA-Z_] === \w(数字、字母、下划线) [^a-z] ：上一个的取反（\W） {} ： 正则中的分组符号 (?:) ：只匹配不捕获 (?=) ： 正向预查 (?!) ：负向预查 正则表达式常用的修饰符：img i ：(ignoreCase) 忽略大小写匹配 m ：(multiline) 可以进行多行匹配 g ： (global) 全局匹配 正则表达式的方法： test：匹配字符串，如果成功就返回真，失败则返回假，语法：正则.test(字符串)，返回的是布尔值，用途是判断，如： 123var str = 'abcdef';var re = /b/; //里面是个整体，如果是bd则是假alert(re.test(str)); search：匹配字符串，如果成功返回匹配成功的位置，如果失败就返回-1(类似indexOf)，语法：字符串.search(正则);如： 1234var str = 'abcdef';var re = /B/i; // 在正则里默认是区分大小写的，如果不区分在正则的最后加标识ialert(str.search(re)); var re = new RegExp('B','i'); // 构造函数实例化时的标识符写法 match：匹配字符串，如果成功返回数组，如果失败就返回null，语法：字符串.match(正则)，如开始的例子: 1str.match(/\d+/g); // +是它前面的元字符至少出现一次，标识符g(全局匹配) replace：匹配字符串，匹配成功的字符会替换成新的字符串，语法：字符串.replace(正则，新的字符串)，第二个参数可以是字符串也可以是回调函数，回调函数的第一个参数就是每次匹配成功的字符，如： 123456789var str = 'aaa';var re = /a/;// 第二个参数是字符串str = str.replace(re,'b');alert(str);// 第二个参数是回调函数str = str.replace(/a/, function () &#123; return "b";&#125;) 正则表达式匹配子项：小括号 正则匹配的整体叫母体，从左开始第一个小括号里匹配的叫做母体的第一个子项，以此类推。直接操作母体往往会比较麻烦，可以把母体分割成多个子项去操作。 replace函数的第二个参数就是匹配成功的母体的第一个子项，第三个参数是第二个子项，以此类推。看看下面的例子分别会弹出什么： 12345var str = '2017-6-7';var re = /\d+-/g; // /\d-+/g和/(\d-)+/gstr.replace(re,function($0,$1,$2)&#123; alert($0);&#125;) 匹配重复项\n(n是个大于等于1的数字小于等于最大子项的整数)，与第n个子项重复的项(复制第n个子项)，如： 12var re = /\w\w/; // 分别匹配一个字符var re = /(\w)\1/; // 匹配一个字符后再匹配一次该字符，\1表示匹配第一个字项，若是匹配第二个子项则是\2 match用小括号()得到结果： 123var str = 'abc';var re = /abc/;(/(a)(b)(c)/) //re不能加全局匹配galert(str.match(re)); 练习： 1. 正则处填写正确的代码来判断当前字符串全是数字或者不全是数字 123var str = '37482t9348791'; var re = /正则/;var re = /\D/; 2. 敏感词过滤，在一个文本框输入内容并点击按钮时，敏感词换成对应数量的*，并在另一个输入框里展示。注意：需要用到 | ，正则里的或者 12 3. 把”2018-6-7 font-size”变成”2018.6.7 font-size” 4. 封装函数，能够将css的样式写法修改成js的驼峰写法(如background-color =&gt; backgroundColor) 123456789function cssToJs(str) &#123; var re = /-(\w)/g; str = str.replace(re, function ($0,$1) &#123; return $1.toUpperCase(); &#125;) return str;&#125;console.log(cssToJs("background-color")); 元字符详细解析 ^ $ 12345678910let reg = /^\d/; // 以数字开头reg.test("2019zidjsi"); // truelet reg = /\d$/; // 以数字结尾reg.test("zidjsi2019"); // truelet reg = /^\d$/; // ^/$两个都加=&gt; 字符串只能是和规则一致的内容// 验证手机号码（11位数字，第一位数字是1）let reg = /^1\d&#123;10&#125;$/; // 以1开头，1后有10个数字 \：转义字符 1let reg = /^2.3$/; // .不是小数点，而是除\n外的任意字符]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js键盘事件和元素的拖放]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%85%83%E7%B4%A0%E7%9A%84%E6%8B%96%E6%94%BE%2F</url>
    <content type="text"><![CDATA[js键盘事件和元素的拖放 - #### 键盘事件： onkeydown/onkeyup：当键盘按键按下/抬起时触发 我们不能让所有按键按下时都执行同一件事，这时需要用到：event.keyCode——键盘按键值(数字类型),如： 1234document.onkeydown = function(ev) &#123; ev = ev || event; alert(ev.keyCode);&#125; //判断一下当前按键的键值 因此在使用该事件时应该判断一下当前按键的键值，来分别执行不同的函数 event下还有ctrlKey，shiftKey，altKey等属性(布尔值)，当一个事件发生时，如果ctrl或shift或alt是按下状态，返回true，否则返回false 注意：只有能接受焦点的元素才能接收键盘事件，特殊的document可以接收，如不能直接给div加 按键事件在按下不抬起时会连续触发，但是连续触发前会有一个停顿，如果要做按住连续触发并且不想要停顿效果时，需要自己写个方法(可以用计时器的方法) 元素的拖拽： 前面我们说到用下面两个方法获取到鼠标的位置 12ev.clientX/ev.clientY; ev.pageX/ev.pageY; 那么我在选择元素时(鼠标按下)保存下鼠标的位置和元素位置的差值；然后移动元素时(鼠标移动)，不停的给元素赋值(当前鼠标位置减去保存的差值)；释放元素(鼠标抬起)时，取消移动事件，就能让该元素随着我的鼠标移动了 12345678// 鼠标按下时保存差值：var disX = ev.pageX - 元素.offsetLeft; // ev.pageX是相对页面，包括有滚动条的情况var disY = ev.pageY - 元素.offsetTop;// 鼠标移动时不停的给元素赋值：元素.style.left = ev.pageX - disX + 'px';元素.style.top= ev.pageY - disY + 'px';// 鼠标抬起释放元素，把事件指向null：元素.onmousemove = 元素.onmouseup = null; 问题： 移动太快脱离元素时事件就不会执行了，解决方法：onmousemove事件放在document上就可以了 抬起鼠标时在其他元素上抬起的，元素也不会停止。同样把onmouseup事件也放在document上 鼠标按下时，如果有文字被选中(包括图片)，拖拽会变成复制(浏览器的默认行为)，在onmousedown阻止默认行为。 封装拖拽，限制范围的拖拽：让其不能离开另一个元素的范围。方法：在赋值前进行判断，将一个正确的值赋给它 碰撞检测：当我们拖拽一个元素的时候，它可能会与另一个元素发生重叠，当两个元素有重叠区域时，我们认为它们发生了碰撞。那么怎么检查两个元素是否发生了碰撞那？思路：九宫格方式判断，我们可以找出它们不碰撞的情况，然后排除这些情况既是碰撞状态了 模拟滚动条：滚动条的样式我们没法处理，类似表单元素select、单选多选等，因此我们可以自己定义一个滚动条，这样我们就是自己设置样式了。方法：定义一个元素在另一个元素里拖拽，只需要一个方向移动。 try…catch…语句： 错误发生时JavaScript引擎会停止并生成一个错误消息，try允许执行时进行错误测试的代码块，catch允许当 try代码块发生错误时执行的代码块，finally无论有没有错都执行的代码块，throw new Error(&quot;自定义错误&quot;)自定义错误信息 可以在用户自己操作失误或者函数少条件时不会影响下面的函数执行 语法：try {//运行代码} catch (err) {//处理错误} finally {//无论有没有错都执行的代码块}，如： 123456789try &#123; allert("Welcome guest!"); //throw new Error("自定义错误");&#125; catch(err) &#123; txt = "本页有一个错误。\n"; txt += "错误描述：" + err.message + "\n"; txt += "点击确定继续。\n"; alert(txt);&#125; 适用情况： 兼容性问题，浏览器兼容性不是程序员能改正的，所以可以用try catch：不同浏览器的报错提示是不一样的，根据浏览器的报错提示判断用户的浏览器，做出对应的措施，这时候用try catch，if通常只能反馈真或假，不能直接反馈浏览器的报错内容。 如window.a.b是非法的，再跟2对比就没有意义，这样非法的条件，在try catch中仍可以继续运行下去。但在if中window.a.b已经报错，整个页面都会坏掉。用try catch，程序不但知道window.a.b == 2是假的，而且直接可以知道究竟哪一步就已经是假的。 try catch不能做真假判断，只能做非法判断。也就是说：try {1 === 2}，虽然1===2是假，但是是合法的，catch不会捕捉到错误，也不会告诉你1 === 2到底是真是假。 名字空间： 用一个对象制作名字空间(命名空间)，全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或定义了相同名字的顶层函数，会造成命名冲突，很难发现。 减少冲突的一个方法是把所有变量和函数绑定到一个全局变量中。例如： 123456var myApp = &#123;&#125;;// 唯一的全局变量myAppmyApp.name = 'myapp';// 其他变量myApp.version = 1.0;// 其他变量myApp.foo=function () &#123; return 'foo';&#125;; //其他函数 把自己的代码全部放入唯一的名字空间myApp中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的，如：jQuery，YUI等等。 练习： 1. 做一个输入框和ul，每次输入完内容后，点击ctrl+回车变成留言 123456789101112var oInput = document.querySelector("input");var oUl = document.querySelector("ul");oInput.onkeydown = function() &#123; // 同时按下 ctrl和 enter if (event.ctrlKey &amp;&amp; event.keyCode == 13) &#123; var oLi = document.createElement("li"); oLi.innerHTML = oInput.value; // 将留言从上往下显示 oUl.children[0] ? oUl.insertBefore(oLi, oUl.children[0]) : oUl.appendChild(oLi); oInput.value = ""; &#125;&#125; 2. 做一个div元素，用上下左右按钮按住时，在页面中移动的效果 3. 模拟一个滚动条的拖拽，并在拖拽时改变一个div的高度 4. 做一个拖拽的方块和图片碰撞时，图片切换成另一张图片，离开时变回的效果 5. 做一个弹球游戏，要求左右键控制一个木板在页面底部20px处移动，小球只会在页面中来回反弹，碰到木板会反弹，落到地下就失败]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件委托和滚轮事件]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%92%8C%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[js事件委托和滚轮事件 - #### 事件委托： 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序 event.type ：触发事件的类型，如通过onclick的事件类型是click event.target(低版本IE用event.srcElement)：事件触发元素，比如可以用 12var tar = event.target || event.srcElement; //兼容写法tar.tagName; //获取事件触发元素标签名，大写，需要转换为小写 用事件触发元素封装一个事件委托方法： 123456789101112function delegation(fEle,ele,attr,fn)&#123; ele = ele.toLowerCase(); bind(fEle,attr,function (ev)&#123; ev = ev || event; var tar = ev.target || ev.srcElement; if(ele[0]==="#"&amp;&amp;("#"+tar.id)===ele|| ele[0]==="."&amp;&amp;tar.className.indexOf(ele.substring(1))!=-1|| /[a-z]/.test(ele[0])&amp;&amp;tar.nodeName.toLowerCase()===ele)&#123; fn.call(tar); &#125; &#125;)&#125; 鼠标滚轮事件： 在ie浏览器和谷歌浏览器的滚轮事件使用onmousewheel；而火狐浏览器的事件用DOMMouseScroll(该事件必须用addEventListener事件监听才能生效) 12345if (window.navigator.userAgent.indexOf("Firefox")!=-1)&#123; obj.addEventListener('DOMMouseScroll', wheel, false);&#125; else &#123; obj.onmousewheel = wheel;&#125; 根据不同浏览器执行不同的代码 另外在ie浏览器和谷歌浏览器里用来判断滚轮方向的属性为：event.wheelDelta(上：120 下：-120)；而火狐浏览器的属性为：ev.detail(上：-3 下：3) 123456var delta = true;if (ev.wheelDelta) &#123; delta = ev.wheelDelta &gt; 0 ? true : false; &#125; else if(ev.detail) &#123; delta = ev.detail &lt; 0 ? true : false;&#125; 将滚动方向统一为向上为true，向下为false 最后我们将其进行封装，在使用滚动条事件时需要注意几点： 封装函数的参数尽量设置成一个对象，并设置默认值，提高用户体验，并且在函数命名时尽量使用名字空间的方式 如果我们想在滚轮滚动时不要移动滚动条就需要阻止浏览器默认行为，而标准浏览器的事件监听需要通过event的ev.preventDefault()来阻止，而attachEvent和on事件用的是return false 滚动距离(可视区到页面顶部/左侧)： 12345document.body.scrollTop/scrollLeft // 仅chrome下有效document.documentElement.scrollTop/scrollLeft // 其他浏览器// 垂直滚动条和水平滚动条的兼容写法：var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft; 页面内容宽高(盒子内部包括溢出部分的宽度/高度) 12var oBWidth = document.body.scrollWidthvar oBHeight = document.body.scrollHeight 例如一个元素内容被隐藏，可以用滚动条查看，这些实际内容的宽高 设置滚动条的位置 1obj.scrollTo(x,y); // x为水平方向的滚动条位置，y为垂直方向的滚动条位置,是window的方法 注意：必须两个值都写，如希望设置y轴滚动条(x不变)，首先获得x轴滚动条位置并为之赋值，然后设置y轴位置，设置的时候不需要单位。不过现在的页面很少需要水平方向滚动条，所以一般用0即可 Console 对象 JavaScript 原生中默认是没有 Console 对象,这是宿主对象(也就是游览器)提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 console命令中最常用的就是console.log 了。console.log有一个特殊的首参数：字符串(%s)、整数(%d或%i)、css样式(%c)、浮点数(%f)、DOM对象属性(%O)和可展开的JS对象(%o)，如 12345console.log("%s",&#123;name:"魏老师"&#125;); //输出:[object Object]console.log("%d年%d月%d日",2011,3,26); //输出:2011年3月26日console.log("%chello world", "color: red;font-size: 24px;font-weight: bold;"); //输出：hello world(带有样式)console.log("圆周率是%f",3.14159); //输出：圆周率是3.14159console.log("%o",&#123;name:"魏老师"&#125;); //输出：Object &#123; name: "魏老师" &#125; 常用的还有 12console.dir(obj); //输出obj的信息console.dirxml(info); //某个节点(node)所包含的html/xml代码 练习： 1. 做一个点击添加留言效果，用事件委托的方法给每个添加的留言设置一个撤回功能 12345delegation(oLi,"button","click",function() &#123; oUl.removeChild(oLi); len--; // 将留言条数减一 // console.log(len);&#125;); 2. 鼠标滚轮控制并改变div高度变化，向上滚动减少div高度，向下滚动增加div高度 CSS部分： 12345div &#123; width: 200px; height: 200px; background: red;&#125; JS部分： 12345678910111213141516171819202122232425262728293031323334var oDiv = document.getElementsByTagName("div")[0];doWheel(oDiv,&#123; "up": function() &#123; oDiv.style.height = oDiv.offsetHeight - 1 + "px"; &#125;, "down": function() &#123; oDiv.style.height = oDiv.offsetHeight + 1 + "px"; &#125;&#125;);// 鼠标滚轮事件封装function doWheel(obj,fns,stop) &#123; // obj,fns都为对象 var up = fns.up || function() &#123;&#125;; var down = fns.down || function() &#123;&#125;; var stop = stop === undefined ? true : stop; // 判断是否火狐浏览器 var fire = window.navigator.userAgent.indexOf("Firefox") &gt;= 0; // console.log(fire); if (fire) &#123; obj.addEventListener("DOMMouseScroll", function() &#123; event.detail &lt; 0 ? up() : down(); if (stop) &#123; event.preventDefault(); &#125; &#125;,false) &#125; else &#123; obj.onmousewheel = function() &#123; event.wheelDelta &gt; 0 ? up() : down(); if (stop) &#123; return false; &#125; &#125; &#125;&#125; 3. 点击按钮返回页面顶部按钮，要求定位在页面左下角，但是在滚动距离少于200px时隐藏 12345678910var oBtn = document.querySelector("button");// 触发滚动事件window.onload = window.onscroll = function() &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; oBtn.style.display = scrollTop &gt;= 200 ? "block" : "none"; console.log(scrollTop);&#125;oBtn.onclick = function() &#123; window.scrollTo(0,0);&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件流和事件监听]]></title>
    <url>%2F2019%2F09%2F07%2Fjs%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[js事件流和事件监听 - #### 事件流： DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程可称为DOM事件流。事件顺序有两种类型：事件捕捉和事件冒泡。 事件冒泡（从内向外）：是IE浏览器对事件模型的实现。从DOM树型结构上理解，就是事件由叶子节点沿祖先结点一直向上传递直到根节点。 事件捕捉（从外向内）：它与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素。DOM标准同时支持两种事件模型，即捕获型事件与冒泡型事件，但是，捕获型事件先发生。两种事件流都会触发DOM中的所有对象，从document对象开始，也在document对象结束(大部分兼容标准的浏览器会继续将事件捕捉/冒泡延续到window对象)。 先捕获后冒泡，所以如果一个处理函数既注册了捕获型事件的监听，又注册冒泡型事件监听，那么在DOM事件模型中它就会被调用两次。DOM标准的事件模型最独特的性质是,文本节点也会触发事件(在IE不会)。如果为上面的div添加了click事件监听器，该事件监听器指派给了包含该div的body元素或者位于DOM树顶端的document(window)节点，点击div时body等也同样会触发该事件。事件不仅仅对目标元素产生了影响，还会对沿着DOM结构的所有元素产生影响。这就是事件传递。 事件传递模式： 事件捕获(Capturing)阶段，事件将沿着DOM树向下转送，目标节点的每一个祖先节点，直至目标节点。 在目标(target)阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行该事件监听器。目标节点就是触发事件的DOM节点。如上面的div 在冒泡(Bubbling)阶段，事件将沿着DOM树向上转送，再次逐个访问目标元素的祖先节点到document节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。 所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段。如让表单元素获得焦点的focus事件及失去焦点的blur事件就不会冒泡。 给一个元素绑定事件实际上是绑定事件所处理的函数–事件函数，即使没写事件函数在你点击时点击事件也会触发，但他没有绑定任何函数也就不会执行任何动作 事件冒泡机制：当一个元素接受到事件的时候，会把他接收到的所有传播给他的父级，父级继续传播直到顶层，事件冒泡是默认存在的 为什么会默认冒泡，因为页面中很多元素有共同的父元素，你只需要给他们的父元素绑定事件，而不是给每个元素绑定事件就可以解决问题，这样大大减少操作 如果不需要冒泡则阻止事件冒泡就可以了。在事件函数中调用 123event.cancelBubble = true; // 阻止当前对象的此次事件的冒泡(on事件)event.stopPropagation(); // 标准方法(停止传播)event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true; // 兼容写法 同样，如果我们不需要浏览器的默认行为可以用： 123return false; //前面学过(on事件)event.preventDefault(); //标准方法(阻止系统默认)event.preventDefault ? event.preventDefault() : return false; //兼容写法 事件监听器： 我们在之前的语法中，用来执行事件函数的写法通常会用 12元素.事件 = 函数; //甚至更早的有下面的写法&lt;a href="#" onclick="JavaScript code here"&gt;......&lt;/a&gt; 这种行间JavaScript代码和行间css类似。违背了将实现动态行为的代码与显示文档静态内容的代码相分离的原则。从1998年开始，这种写法就过时了。 上面的事件绑定技术简单方便，在HTML中直接书写处理函数的代码块，在JS中给元素对应事件属性赋值即可；IE与DOM标准都支持的一种方法，它在IE与DOM标准中都是在事件冒泡过程中被调用的；可以在处理函数块内直接用this引用注册事件的元素，this引用的是当前元素；但要给元素注册多个监听器，就不能用这方法了。 在一个大型项目中很可能出现一个元素需要绑定多个不同的函数，如果想给一个对象的同一个事件绑定多个不同的函数，就要用到——事件监听器： 在低版本的IE中，每个元素和window对象都有两个方法：attachEvent方法和detachEvent方法。 特点：倒序执行 123 // 注：在使用attachEvent()方法的情况下，事件函数会在全局作用域中运行，即this === windowobj.attachEvent(事件名称,事件函数); //事件监听 obj.detachEvent(事件名称,事件函数); //解除事件监听 - **在标准浏览器中**，每个支持事件的对象都可以使用`addEventListener`方法和`removeEventListener`方法。该方法既支持冒泡又支持捕获。 &lt;font color=&quot;green&quot;&gt;特点：顺序执行&lt;/font&gt; &lt;font color=&quot;red&quot;&gt;注意：是否捕获默认是false，false：冒泡阶段； true：捕获阶段&lt;/font&gt; 12obj.addEventListener(事件名称,事件函数,是否捕获); //事件监听obj.removeEventListener(事件名称,事件函数,是否捕获); //解除事件监听 12345678// 事件监听document.addEventListener("click", function() &#123; alert("123");&#125;, false);// 解除事件监听document.removeEventListener("click", function() &#123; alert("456");&#125;, false); 区别：1. 参数不一样 2. 事件顺序不一样 3. this不一样 4. 阻止冒泡和浏览器默认行为写法 - ie的`obj.attachEvent`的四个特点：1、没有捕获；2、事件名称有on；3、事件执行顺序倒序；4、this指向window； - 标准的`obj.addEventListener`的四个特点：1. 有捕获；2. 事件名称没有on；3. 事件执行是顺序；4. this指向该事件的对象 - &lt;font color=&quot;purple&quot;&gt;**函数有个`call()`方法(调用函数并改变this的指向)，我们可以用这个方法解决ie事件监听`this`指向的问题，函数直接调用`fn1()`等价于`fn1.call()`，但如果我们在`call()`方法的第一个参数设置为一个对象，那么该方法中的`this`执行会指向该对象，后面的参数是正常的参数**&lt;/font&gt; 1234document.attachEvent("onclick", function() &#123; // fn(); fn.call(document);&#125;, false); - 而事件捕获只有标准浏览器下才有，因此我们只能封装一个冒泡的方法: 1234function bind(obj,evname,fn) &#123; obj.addEventListener ? obj.addEventListener(evname,fn,false) : obj.attachEvent('on'+evname,function()&#123;fn.call(obj);&#125;)&#125;bind(document,'click',fn1); //调用 练习： 1. 做3个div嵌套，并都绑定一个事件，点击某个div时，弹出这个div的id，如果出现问题如何解决问题 2. 做一个下拉菜单，在点击时，让该菜单展示出来，点击页面的其他位置时，菜单隐藏 CSS部分： 12345678910button &#123; width: 200px; height: 30px;&#125;div &#123; width: 200px; height: 400px; background: red; display: none;&#125; JS部分： 123456789101112131415161718192021222324252627var oBtn = document.querySelector("button");var oDiv = document.querySelector("div");// 事件监听器兼容写法function bind(obj,attr,fn) &#123; // obj表示对象,attr表示事件,fn表示执行的时间函数 for (var i = 0; i &lt; fn.length; i++) &#123; if (document.attachEvent) &#123; obj.attachEvent("on" + attr,function() &#123; fn[fn.length - 1 - i].call(obj); &#125;); &#125; else &#123; obj.addEventListener(attr,fn[i],false); &#125; &#125;&#125;bind(oBtn,"click",[ function() &#123; oDiv.style.display = "block"; // 阻止冒泡 event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true; &#125;]);bind(document,"click",[ function() &#123; oDiv.style.display = "none"; &#125;]);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js浏览器定位对象和事件对象]]></title>
    <url>%2F2019%2F09%2F03%2Fjs%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9A%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[js浏览器定位对象和事件对象 浏览器的历史记录 window的history对象，html5中新增了popstate等方法我们会在后面详细说明 123456window.history.go(-1); //访问浏览器窗口的历史，负数为后退，正数为前进window.history.back(); //在浏览历史里后退一步，等同go(-1)window.history.forward(); //在浏览历史里前进一步，等同go(1)window.history.length //浏览过的页面数 location对象和其他打开页面方法 1234567891011121314// 常用window.location.href; // 载入页面的完整URL，如http://www.baidu.com window.location.search; // 执行GET请求的URL中的问号后的部分，又称查询字符串，如?p=xxxx window.location.hash; // 如果URL包含#，返回该符号之后的内容，如#anchor1window.location.portocol; // URL中使用的协议，即双斜杠之前的部分，如http window.location.host; // 服务器的名字，如www.baidu.com window.location.hostname; // 通常等于host，有时会省略前面的www window.location.port; // URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080 window.location.pathname; // URL中主机名后的部分，如/pictures/index.html window.location.assign("http:www.baidu.com"); // 同href，新地址会被加到浏览器的历史栈中 window.location.replace("http:www.baidu.com"); // 同assign，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问window.location.reload(true | false); // 重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false 12345 2. `open`方法打开一个新窗口 ```js open(URL,打开方式)； // 用来打开一个新窗口 注意：网址为空时打开的是空白页面，打开方式默认为_blank(新窗口)，设置_self(当前窗口)，此方法的返回值是新窗口的window对象 close方法关闭窗口，有兼容性问题(火狐禁止代码关闭浏览器，chrome直接关闭，ie询问关闭)，但可以用来关闭用js方法打开的窗口 window.location.href的方法也可以用来做页面跳转，如 123window.location.href = "url"; //同时可以在url后面添加信息，如"?"+信息或者"#"+信息 window.location.search //用来获取url?后面的内容window.location.hash //用来获取url#后面的内容 注意：下面两个的window是跳转后新窗口对象，获取的数据还包括”?”和”#” window的事件 1234window.onload; //window的加载事件window.onscroll; //window的滚动事件window.onresize; //window的窗口变化事件window.onhashchange; //window的hash值发生变化事件 注意：onscroll和onresize不是按照距离触发事件，而是单位时间；onhashchange可以让我们在改变页面视图的同时让历史记录功能生效，如后面的ajax的问题 获取选中文字 获取和取消鼠标选中的文字： 1234567document.selection.createRange().text; //IE9以下获取选中文字window.getSelection().toString(); //其他浏览器获取选中文字window.getSelection ? window.getSelection().toString() : document.selection.createRange().text; //兼容写法document.selection.empty(); //IE9以下取消选中文字window.getSelection().removeAllRanges(); //其他浏览器取消选中文字window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); //兼容写法 事件对象event 当我们与浏览器中 Web 页面进行某些类型的交互时，事件就发生了。可能是用户在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键。还可能是 Web 浏览器中发生的事情，比如某个 Web 页面加载完成，或者是用户滚动窗口或改变窗口大小。 当事件发生时，和这个对象事件有关的一些信息都会被临时保存到一个指定地方–event对象(类似飞机的黑匣子) 注意：事件对象必须在一个事件调用的函数里面使用才有内容。函数是不是事件函数，不是定义时决定，而是调用时决定，如： 1234function fn1() &#123; alert(event);&#125; //通过fn1()方式调用就不会有内容document.onclick = fn1; //用事件调用就有内容 event对象在ie和chrome里面是内置的全局变量，是window的属性，弹出为空和未定义。但是在火狐里会报错(新版不会报错)，火狐的事件对象是通过事件函数的第一个参数–function fn1(ev){alert(ev)};(event标准下的用法，在标准的ie和chrome也是有效)，兼容写法： 1var ev = ev || event; //前面必须是ev，因为event在前火狐里会直接报错 event储存了很多东西，如在event上获得事件发生时的鼠标位置： 12event.clientX/event.clientY; //鼠标在可视区的X/Y的坐标event.pageX/event.pageY; //鼠标在页面的X/Y的坐标 练习： 点击一个按钮，以新的窗口打开”http://www.yahoo.com&quot;首页，然后再用另一个按钮关闭它。 五个按钮(value分别为一、二、三、四、五)都可以用location.href打开同一个新页面，在新页面中输出“你是通过第几个按钮跳转到该页面的” 做一个自动生成彩票系统，要求每次生成一注28选7的随机彩票(从1-28中选择7个不重复的数字)，并且能够通过历史记录找到之前生成的彩票 页面中一个p和一个div，p元素里设置一篇文章，当你选中p中的文字后，在div里显示出来 设置一个div元素，跟着鼠标移动的效果 CSS部分： 12345678div &#123; width: 150px; height: 150px; background: red; position: absolute; top: 0; left: 0;&#125; JS部分： 12345var oDiv = document.querySelector("div");document.onmousemove = function() &#123; oDiv.style.left = event.clientX + "px"; oDiv.style.top = event.clientY + "px";&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js浏览器对象和方法]]></title>
    <url>%2F2019%2F09%2F03%2Fjs%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[浏览器对象和方法 - #### BOM的常用属性和方法 window对象属性 12345678910111213window.document; // 对 Document 对象的只读引用window.history; // 对 History 对象的只读引用window.location; // 用于窗口或框架的 Location 对象window.screen; // 对 Screen 对象的只读引用window.navigator; // 对 Navigator 对象的只读引用window.event; // 对 Event 对象的只读引用window.innerHeight/window.innerWidth; // 返回窗口的文档显示区的高度/宽度，（有滚动条时包括滚动条）window.outerHeight/window.outerWidth; // 返回窗口的外部高度/宽度,（整个浏览器）window.pageXOffset/window.pageYOffset; // 设置或返回当前页面相对于窗口显示区左上角的 X/Y 位置window.name; // 设置或返回窗口的名称window.parent; // 返回父窗口window.top; // 返回最顶层的先辈窗口window.self; // 返回当前窗口本身 window对象方法 1234567891011121314window.open(); // 打开一个新的浏览器窗口或查找一个已命名的窗口，第一个参数是要打开的页面的路径，第二个参数是在新标签页打开(_blank)还是当前页打开(_self)window.close(); // 关闭当前窗口,但是其返回值关闭的是新页面的窗口window.alert("message"); // 弹出一个具有OK按钮的系统消息框，显示指定的文本 window.confirm("Are you sure?"); // 弹出一个具有OK和Cancel按钮的询问对话框，返回一个布尔值window.prompt("What's your name?", "Default"); // 提示用户输入信息，接受两个参数，要显示给用户的文本和文本框中的默认值，将文本框中的值作为函数值返回window.setTimeout("alert('xxx')", 1000); // 设置在指定的毫秒数后执行指定的代码，接受2个参数，要执行的代码和等待的毫秒数window.clearTimeout("ID"); // 取消由 setTimeout 方法设置的timeout。window.setInterval(function, 1000); // 无限次地每隔指定的时间段重复一次指定的代码，参数同setTimeoutwindow.clearInterval(); // 取消由 setInterval 设置的timeout screen对象和各种尺寸 window的screen对象，包含用户屏幕的信息(尺寸)： 1234window.screen.width; // 屏幕宽度 window.screen.height; // 屏幕高度 window.screen.availWidth; // 可用宽度(除去滚动条的) window.screen.availHeight; // 可用高度(除去任务栏的) 获取浏览器的尺寸，有兼容问题： 123456document.body.clientWidth; // BODY对象宽度document.body.clientHeight; // BODY对象高度document.documentElement.clientWidth; // HTML对象宽度document.documentElement.clientHeight; // HTML对象高度var sW = document.documentElement.clientWidth || document.body.clientWidth; // 兼容写法var sH = document.documentElement.clientHeight || document.body.clientHeight; // 兼容写法 获取窗口尺寸 12window.innerWidth; // 浏览器窗口的内部宽度window.innerHeight; // 浏览器窗口的内部高度 浏览器信息 window的external对象 1window.external.AddFavorite("地址","标题"); // 把网站新增到保藏夹 window的navigator对象，可以用来判断当前浏览器是否是什么浏览器 12window.navigator.userAgent // 浏览器信息 (内核，版本等)window.navigator.userAgent.indexOf('MSIE')=-1; // 信息中包含了MSIE字符 iframe标签和顶层元素的关系 iframe标签的window对象，浏览器会为HTML文档创建一个window对象，并为每个iframe框架创建一个额外的window对象 123456window.frames; // 返回窗口中所有命名的框架的集合，伪数组window.frames[index]; // 获取某个iframe(按照下标)window.frames[name]; // 获取某个iframe(按照name)iframe.contentWindow; // 获得某个iframe的window对象iframe.contentWindow.document; // 获取某个iframe的document对象window.parent; // 是父窗口，如果窗口是顶级窗口，那么parent(父窗口)==self(当前窗口)==top(最顶级父窗口) 获取和取消鼠标选中的文字： 12345678//获取鼠标选中的文字：document.selection.createRange().text; //IE9以下使用window.getSelection().toString(); //其他浏览器使用window.getSelection ? window.getSelection().toString() : document.selection.createRange().text; //兼容写法//取消鼠标选中的文字：document.selection.empty(); //IE9以下使用window.getSelection().removeAllRanges(); //其他浏览器使用window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); //兼容写法 练习： 1. 提示用户输入用户名，用户输入XX内容并确认后弹出”欢迎XX朋友”，若未输入内容或输入为空则并确认后弹出”欢迎您，我的朋友” 2. 点击重置时让其确定，是否重置，用户确认重置表单，否则阻止浏览器默认行为 12345678var oFm = document.getElementById("fm");var oBtn = document.getElementsByTagName("button")[0]; oFm.onreset = function() &#123; var a = confirm("确定要重置吗？"); if (!a) &#123; return false; &#125;&#125; 3. 判断打开的浏览器是什么浏览器(IE、火狐和谷歌)，如用IE浏览器打开就弹出“IE”，用火狐浏览器打开就弹出“火狐” 4. 在页面中设置一个div元素、一个按钮和一个iframe元素，点击按钮时将div元素移动到iframe中去]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择器详解和BOM]]></title>
    <url>%2F2019%2F08%2F31%2F%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3%E5%92%8CBOM%2F</url>
    <content type="text"><![CDATA[js选择器详解和BOM - #### 获取元素方法详解： 通过document可以访问其子节点(其实任何节点都可以)，我们看一下获取元素的所有方法 var oEle = document.getElementById(id); 该方法接收一个参数——元素的ID(区分大小写，严格匹配)，返回一个Element对象(可看作是动态NodeList集合，只是集合中只包含一个匹配的元素，会实时反映DOM节点的变化)，若当前文档中拥有特定ID的元素不存在则返回null。 注意：该方法不会搜索不在文档中的元素，创建一个元素且分配ID后，要用insertBefore()或其他类似的方法把元素插入到文档中之后才能使用该方法获取到 12var aEle = element.getElementsByTagName(tagName);var aEle = rootElement.getElementsByTagName(names);//调用这个方法的元素将作为本次查找的根元素 该方法接收一个参数——元素的标签名(不区分大小写)，返回一个HTMLCollection动态集合(也可以说返回一个NodeList类数组对象)，集合中包含以当前元素为根节点(不包括当前元素自身)，所有指定标签名的子元素，子元素的顺序是在当前元素的子树中出现的顺序，如果没有搜索到元素则集合为空。 12var aEle = document.getElementsByClassName(names); var aEle = rootElement.getElementsByClassName(names); //调用这个方法的元素将作为本次查找的根元素 该方法接收一个参数——一个或多个类名的字符串(类名通过空格分隔)，返回一个HTMLCollection动态集合(也可以说返回一个NodeList类数组对象)，集合中包含以当前元素为根节点，所有指定 class 名的子元素。 注意：getElementsByTagName()和getElementsByClassName()方法都是动态方法，因此我们用循环依次删除时会发现删不干净，原因是每次删除都会改变HTMLCollection动态集合的length，可以每次删除第一项(或最后一项) 1var aRadio = oForm.getElementsByName("sex"); 该方法接收一个参数——元素name的属性值，返回一个动态NodeList类数组对象，对象中包含以当前元素为根节点，所有指定name属性值的子元素。 注意：表单元素获取更多的是用表单的DOM操作，既oF.sex的方式获取 12var oSub = document.querySelector("form#f1 input[name=login]");var oLi = document.querySelector(".box"); 该方法接收一个参数——包含一个或多个CSS选择器的字符串(多个选择器以逗号分隔)，返回匹配指定CSS选择器的第一个元素节点(无法选中伪元素)，没有发现匹配的节点则返回null。该方法非常强大，它能像css一样选择元素。 注意：由于它的写法类似于css，所以必须给传的参数加上”.”和”#”等css标识，否则无法区分 var aMatch = document.querySelectorAll(&quot;div.note, div.alert&quot;); 该方法接收一个参数——包含一个或多个CSS选择器的字符串(多个选择器以逗号分隔)，返回静态NodeList对象集合，该集合中包含匹配指定CSS选择器的所有节点，元素节点的变化无法实时反映在结果中；如果参数中包含CSS伪元素则返回一个空的对象集合。 注意：该方法可以将所有匹配项返回成一个集合，所以需要和其他类似方法一样进行遍历，但由于该方法为静态方法，因此不需要如动态方法一样进行特殊处理，也就是说可以一次性删除 1var oEle = document.elementFromPoint(x, y); 该方法接收两个参数——是相对于当前窗口左上角的横纵坐标，单位为像素；返回位于页面指定位置的元素，如果该元素不可返回(如滚动条)则返回它的父元素，如果坐标值无意义(如负值)则返回null。 getElementBy系列返回的都是动态的HTMLCollection集合，DOM结构变化能实时地反映到所保存的对象中，而querySelector系列返回的都是静态的NodeList对象，是一个快照，DOM的任何操作都不会对其产生影响(这是规范的要求)。那么这两者有什么异同： 二者都是类数组对象，因此都具有length属性，都具有item()方法(该方法节点列表中位于指定索引的节点)，下面写法等价 12document.body.children.item(0);document.body.children[0]; NodeList对象会包含文档中的所有节点，如 Element、Text 和 Comment 等 HTMLCollection 对象只会包含文档中的 Element 节点 注意：由于我们使用的获取元素的方法一般都不会获得Element以外的节点，因此在这里我们可以认为他们是等价的 BOM： Browser Object Model(简称BOM)：浏览器对象模型，专门操作浏览器窗口(window)的对象，而window是BOM对象，而非js对象。通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，如我们之前学习的： 12alert();setInterval(); 这些方法其实都是window的方法，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM(Document Object Model)模型的根节点。可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 DOM和BOM的区别：DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口 在可视区窗口中我们看到的所有元素(也就是我们写在html文件的body之内部分的)，在js中由DOM负责 浏览器的标签页，地址栏，搜索栏，书签栏，窗口放大还原关闭按钮，菜单栏等等；浏览器的右键菜单；document加载时的状态栏，显示http状态码等；滚动条scroll bar，上面这些在js由BOM负责 window对象是js层级中的顶层对象；代表一个浏览器窗口或一个框架；会在每次打开页面(或框架)时被自动创建。因为window对象的属性和方法是直接可以使用而且被感知的，所以使用window的属性和方法时我们常常会省略window(为了防止和变量的误会最好加上) 练习： 1. 获取一个ul的所有子元素li，然后遍历并输出所有的li，要求分别用NodeList和HTMLCollection操作一次 12 2. 封装一个方法，要求点击页面时，返回被点击的元素 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js表格和表单的DOM操作]]></title>
    <url>%2F2019%2F08%2F31%2Fjs%E8%A1%A8%E6%A0%BC%E5%92%8C%E8%A1%A8%E5%8D%95%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js表格和表单的DOM操作 - #### 表格的DOM操作： 表格较为繁杂，层次也多，使用DOM只是来获取某个元素会非常难受，所以使用table DOM会清晰很多。 浏览器在解析table的时候，如果你没有写tbody，它会自动生成一个tbody，因此如果你用html结构去获取元素时会出错，table应该直接加上thead和tbody 由于用上面的children获取表格中的元素会非常麻烦，js里原生提供了一些表格元素的方法： 1234567891011121314151617181920212223242526 // 获取表格的节点： var oTable = document.getElementsByTagName('table')[0]; oTable.caption; // 获取表格标题 oTable.tHead; // 获取表格头 oTable.tFoot; // 获取表格尾 oTable.tBodies; // 获取表格正文的集合 oTable.tBodies[0].rows[0]; // 获取表格第一个表格正文中第一行 oTable.tBodies[0].rows[0].cells; // 获取表格第一个表格正文中第一行的单元格集合 // 删除表格的节点： oTable.deleteCaption(); // 删除表格标题 oTable.deleteTHead(); // 删除表格头 oTable.tBodies[0].deleteRow(0);// 删除第一个正文的第一行 oTable.tBodies[0].rows[0].deleteCell(0);// 删除第一个正文的第一行的第一个单元格 // 创建表格的节点： var oTable = document.createElement("table"); // 创建一个table var oCaption = oTable.createCaption(); // 创建一个表格标题 var oThead = oTable.createTHead(); // 创建一个表格头 var oTr = oThead.insertRow(0); // 为表格头的指定位置添加一个新的行tr var oTd = oTr.insertCell(0); // 为上面的行的指定位置添加一个新的单元格td // 表格属性的设置： oTable.border = 1; oTable.width = 300; oTable.bgColor = "red"; 注意：一个表格里只能有一个表格标题、表格头和尾，但其他可以有多个；在创建表格的时候table、tbody和th没有特定的方法，需要使用document来创建。 表单的DOM操作： 通常每个表单元素应该有name和id属性，name用于交给服务器，id用于绑定和功能筛选。js可以通过下面方法获取对应表单元素 123var oF = document.getElementsByTagName("form")[0];oF.q; // 获取name值等于q的表单元素(假设name="q"的元素只有一个)oF.sex; // 如果name="sex"的表单元素不唯一，则需要用循环进行遍历 单选框、多选框选中状态：checked属性： 12oF.sex[0].checked // 若radio或checkbox元素已被选中返回true，否则返回falseoF.sex[0].checked = true/false // 操作radio或checkbox元素被选中状态 表单常用事件和方法： 1234oF.q.onchange // 事件，当表单项的值发生改变时触发(失去焦点时触发)，值不变，不会触发oF.onsubmit // 事件，当表单提交的时候(点击submit时触发)oF.onreset // 事件，当表单重置的时候(点击reset时触发)oF.submit() // 方法，执行提交表单 注意：onchange事件是表单项的事件，而onsubmit、onreset和submit()都是表单的事件和方法 焦点事件和方法(焦点就是光标所在的位置)：当一个元素有焦点的时候，那么它就可以等待用户的输入。可以切换焦点的方法：1、点击；2、tab；3、javascript 12345onfocus //事件，当元素获取到焦点时触发onblur //事件，当元素失去焦点时触发blur() //方法，元素取消焦点focus() //方法，元素获得焦点，例如百度刷新出来后会立即在搜索框里获得焦点select() //方法，选择指定元素里的文本内容，但是只能选择能获取焦点元素的内容 注意：不是所有元素都有焦点，能响应用户操作的元素才有焦点(如div就没有焦点，a就有焦点) 有些事件如点击右键(oncontextmenu)或提交表单等会有浏览器默认行为，如果需要阻止浏览器默认行为(on事件)，可以在事件函数内部加一句return false class列表属性： classList属性用于在元素中添加，移除及切换 CSS 类。 classList 属性是只读的，但你可以用它的方法修改它。 12345元素.classList.length; // 返回类列表中类的数量(只读)元素.classList.contains(class); // 返回布尔值，判断指定的类名是否存在。元素.classList.add(class1, class2, ...); // 在元素中添加一个或多个类名。如果指定的类名已存在，则不会添加元素.classList.remove(class1, class2, ...); // 移除元素中一个或多个类名。注意： 移除不存在的类名，不会报错元素.classList.toggle(class); // 在元素中切换类名。参数为要移除的类名，如果该类名不存在则会添加类名 练习： 1. 用DOM的表格操作做一个表格——九九乘法表 12 2. 用DOM的表格操作做一个表格的隔行变色和鼠标移入变色移出恢复原色的效果 12 3. 如果文本框的内容为空时，阻止提交，并弹出一个请填写内容的弹窗 12 4. 做一个自定义的默认菜单(把原本右键的默认事件取消)，这个菜单要求和原本右键菜单一样(内容是个框) 12 5. 做一个四个以上选项的多选框，要求当已经有三个选项被选中了，选择第四个时会弹出最多只能选择三项 12 6. 用class切换的方法做一个选项卡和一个折叠，并用css给折叠加上动画 ​ HTML部分： 12345678&lt;div class="wrap"&gt; &lt;div id="ctrl"&gt; &lt;button class="active"&gt;AAA&lt;/button&gt; &lt;button&gt;BBB&lt;/button&gt; &lt;button&gt;CCC&lt;/button&gt; &lt;/div&gt; &lt;div id="content"&gt;我是第一个AAA的内容&lt;/div&gt;&lt;/div&gt; ​ CSS部分： 123456789101112131415161718192021222324252627.wrap &#123; width: 480px; border: 1px #000 solid;&#125;button &#123; width: 160px; height: 60px; font-size: 24px; float: left; margin: 0; padding: 0; border: none; background: #666;&#125;#content &#123; height: 250px; padding: 20px; box-sizing: border-box; font-size: 18px;&#125;#ctrl &#123; overflow: hidden;&#125;button.active &#123; background: white; color: red;&#125; ​ JS部分： 1234567891011121314151617var arr = ["我是第一个AAA的内容","我是第二个BBB的内容","我是第三个CCC的内容"];var aBtn = document.getElementsByTagName("button");var oContent = document.getElementById("content");var iActive = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function() &#123; // 删除之前的class为active的类 aBtn[iActive].classList.remove("active"); // 添加类名 this.classList.toggle("active"); // 设置iActive的值为当前的按钮 iActive = this.index; // 给div赋数组里的值 oContent.innerHTML = arr[this.index]; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js元素属性节点和属性操作]]></title>
    <url>%2F2019%2F08%2F31%2Fjs%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9%E5%92%8C%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js元素属性节点和属性操作 - #### DOM的属性节点 元素.offsetLeft/offsetTop // 只读属性–当前元素到其定位父级的距离(偏移值)：(没有单位，使用时需要加上) 若有定位的父级，但自己没有定位，在ie7及以下浏览器里该属性指的是到body的距离，其他浏览器中则是到定位父级的距离；若无定位父级，ie8及以下浏览器是到html的距离 上面两个属性由于兼容性的问题，在使用时一定注意两点：第一清除浏览器的默认样式；第二该元素要有定位属性。否则在使用时会出问题。用偏移值属性：我们可以用循环把浮动布局的元素改成定位布局的元素，从而添加动画等效果 元素.offsetWidth/offsetHeight // 只读属性–当前元素的占位宽高 元素.style.width/元素.style.height的取值可以得到元素属性style里的宽度/高度(行间样式) 元素.clientWidth/元素.clientHeight的值为盒子宽度/高度去掉边框border的部分，如可视区尺寸(浏览器窗口)： 12document.documentElement.clientWidth //可视区宽度document.documentElement.clientHeight //可视区高度 ​ 注意：document是没有尺寸的，要从文档元素documentElement上获取 元素.offsetWidth/元素.offsetHeight(占位宽高)既盒子宽高，如文档高度： 12var oDomHeight = document.documentElement.offsetHeight //在ie7及以下会表现为可视区（窗口）的高度,而不是文档（页面）的高度var oDomHeight = document.body.offsetHeight //推荐这个写法，无兼容问题 元素.offsetLeft和元素.offsetTop会获取该元素到其定位父级的距离，想要获取一个元素到整个页面document或可视区窗口的距离，就要用下面的方法处理了： 封装一个方法：用来获得元素到整个页面的距离 12345678function getOffset(obj,lrr) &#123; var iOff = 0; while(obj) &#123; //注意：body的offsetParent为空 iOff += obj[lrr]; obj = obj.offsetParent; &#125; return iOff;&#125; 元素.getBoundingClientRect()方法 返回元素的大小及其相对于可视区窗口的位置。该函数返回一个Object对象，该对象有6个属性：top,left,right,bottom,width,height。top、left、right、bottom分别表示该元素左、上、右、下边距离可视区原点(0,0)的位置，width、height是元素自身盒子的宽高。 123456789var rectObject = 元素.getBoundingClientRect();rectObject.top; // 元素上边到视窗上边的距离rectObject.right; // 元素右边到视窗左边的距离rectObject.bottom; // 元素下边到视窗上边的距离rectObject.left; // 元素左边到视窗左边的距离// 低版本ie不支持宽高属性，可以用下面两个公式来计算出来：rectObject.right-rectObject.left;rectObject.bottom-rectObject.top; 元素的操作 创建元素：之前我们用innerHTML的累加的方式创建元素，但是添加若次数过多会使性能降低，新语法： 1234var oTag = document.createElement(tag); //纯洁的tag元素(无任何属性)oTag.innerHTML = "新元素的内容"; //需要我们自己添加属性方法，然后再放在DOM里：oPar.appendChild(oTag); //在父级最后一个节点后添加该元素oPar.insertBefore(oTag,n); //在父级第n个节点前添加该元素 注意：insertBefore方法在ie浏览器中若父元素中没有第n个子元素会报错，如果我们想从前添加元素，则需要判断一下该元素是否有第一个子元素，若没有改用append方法添加： 1oPar.children[0] ? oPar.insertBefore(oTag,oPar.children[0]) : oPar.appendChild(oTag); 删除元素： 1父级.removeChild(oTag); // 从父级中删除某子节点 替换元素： 1父级.replaceChild(新节点,被替换节点); // 在父元素中用新节点替换某子节点 appendChild,insertBefore,replaceChild等方法都可以操作动态创建的元素，也可以操作已有的节点，它们都是剪切操作(既被操作的元素在原位置已经不存在了) 克隆元素： 1元素.cloneNode(); // 克隆该元素对象 注意：由于使用克隆方法后，原来的元素依然存在，因此克隆的元素不应该使用id(否则id就不唯一了) 练习： 1. 布局一个输入框，一个按钮和一个ul列表，要求用动态创建的方法做一个点击按钮时将输入框中的内容在ul中生成一个对话li，li里面需要包含一个按钮-删除，点击该删除时，将按钮对应的对话li删除 12345678910111213var oInput = document.getElementsByTagName("input")[0];var oUl = document.getElementsByTagName("ul")[0];function send()&#123; var oLi = document.createElement("li"); var oBtn = document.createElement("button"); oLi.innerHTML = oInput.value; oBtn.innerHTML = "撤回"; oUl.appendChild(oLi); oLi.appendChild(oBtn); oBtn.onclick = function() &#123; oUl.removeChild(this.parentNode); &#125;&#125; 2. 做一个点击图片弹窗效果，要求点击的图片依然在原地，在页面正中间用遮罩做一个窗口，在窗口中展示一个放大后的图片，并在点击他时消失 12 3. 写一个简单的小游戏：要求先布局一个5*5的格子(div)，起始为白色背景红色边框，点击任意一个格子的时候，要求该格子和其上下左右相邻的格子背景变色，变色规则——如果格子是白色的就变成黑色，反之亦然 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 对象操作和DOM]]></title>
    <url>%2F2019%2F08%2F30%2Fjs-%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[js对象操作和DOM - #### 对象操作： 对象与数据的转换操作：由于数组或者对象在进行数据传递是会变成字符串形式，如果不做转换是不能直接操作的 eval方法：把字符串解析成JS代码并运行，但是由于该方法不安全而耗性能(解析一次运行一次)，因此现在已经不推荐使用 JSON方法：stringify方法将对象转成字符串，但是json必须是严格模式，既key必须是严格的字符串(双引号)；遵循外单内双原则 JSON方法：parse方法将字符串转成对象 123// 数据的深拷贝var arr1 = [1,2,[3,4]];var arr2 = JSON.parse(JSON.stringify(arr1)); 删除属性方法——delete操作符，语法：delete 对象名.属性名。这是删除属性的唯一方法。 判断属性方法——hasOwnProperty()函数，语法： 1object.hasOwnProperty(proName); //判断proName属性是否属于object对象。若属于返回true，反之返回false 该方法是 JavaScript 中唯一一个处理属性但是不查找原型的函数 DOM： Document Object Model (简称DOM)文档对象模型 文档：html文件 文档对象：页面中的元素 文档对象模型：对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM，目的是为了能够让程序–js去操作页面中的元素 把整个文档看成一棵树，树分支就是节点，同时定义了很多方法来操作这些节点，如下图是一个将html代码分解成的DOM树： DOM树中三种常见的DOM节点: 元素节点：上图中、、等都是元素节点，即标签 文本节点：向用户展示的内容，如…中的”文档标题”文本 属性节点：元素的属性，如标签的链接地址属性 href 通过getElementById和document.body等方法获取元素就是获取元素节点的 浏览器工作的过程： 从网络或本地拿到html源代码 浏览器将html源码中的每个标签都实例化对应的对象 在内存中形成一个DOM树 将内存DOM树解析为可视页面 JS直接修改DOM树，改变页面视图 元素属性节点： 属性节点：就是元素的属性–元素.attributes //只读属性，如：属性的名称.name，属性的值.value等 获取属性值 元素.getAttribute() //一个参数，为属性名 设置属性值 元素.setAttribute() //两个参数，为属性名和值 删除属性值 元素.removeAttribute() //一个参数，为属性名 标签的自定义属性，在ie8及以下可以用.和[]的方法取到，但是标准浏览器不支持，但getAttribute()支持所有的浏览器 用.src和[&#39;src&#39;]的方法取到的是绝对路径，用getAttribute(&#39;src&#39;)可以获取到相对路径(既实际值，ie7及以下不兼容) 元素.childNodes // 只读属性–子节点列表集合：该属性不只包含元素节点，因此获取一个父元素的chlidNodes时要比实际元素的数量多 元素.nodeType // 只读属性–获取元素的节点类型，常用的节点有：1元素节点，2属性节点，3文本节点。若我们希望控制元素节点，则可以先判断子节点的nodeType为1时，再控制它 元素.children//只读属性–子元素属性：元素节点的列表集合 由于children只会包含元素节点，因此不会有上面属性的兼容性问题 元素.firstChild // 只读属性–第一个子节点：该属性是元素的所有子节点(childNodes)中的第一个子节点，因此包含文本类型的节点，不兼容；标准浏览器有效的写法为元素.firstElementChild。因此兼容所有浏览器的写法： 123456789var oFirst = 元素.firstElementChild || 元素.firstChild; if(oFirst)&#123;oFirst.style.....&#125; //为防止在没有子节点时出问题的写法父元素.children[0].style.... //因此最好的做法是用这个方法，避免上面那些写法兼容性的问题//类似的写法：var oLast = 元素.lastElementChild || 元素.lastChild; //最后一个子节点var oNext = 元素.nextElementSibling || 元素.nextSibling; //下一个兄弟节点var oPrev = 元素.previousElementSibling || 元素.previousSibling; //上一个兄弟节点 元素.parentNode // 只读属性–父节点：由于父元素是唯一的，因此没有兼容问题 元素.offsetParent // 只读属性–距当前元素最近一个有定位属性的父元素节点：若无定位父级则默认会找到body(若在ie7及以下的浏览器中，该元素在没有定位的时候找的是body，有定位的时候则变成html) 练习： 1. 创建一个cat对象，包含属性：name、sex和color。用delete删除name属性，给sex赋值为undefined，给color赋值为null。用hasOwnProperty()函数判断各个属性是否存在 1234567891011var cat = &#123; "name": "cat", "sex": undefined, "color": null&#125;// 删除name属性delete cat.name;// 属性存在则返回true，不存在则返回falseconsole.log(cat.hasOwnProperty("name"));console.log(cat.hasOwnProperty("sex"));console.log(cat.hasOwnProperty("color")); 2. 分别用遍历和对象操作来完成数据的深拷贝 12345678910111213var arr1 = [1,2,[3,4]];var arr2 = [];// 遍历拷贝数组for (var i = 0; i &lt; arr1.length; i++) &#123; arr2.push(arr1[i]);&#125;console.log(arr2);// 改变arr2的第一项值，检测arr2是否拷贝的是地址arr2[0] = 10;console.log(arr1);// 对象操作拷贝数组var arr3 = JSON.parse(JSON.stringify(arr1));console.log(arr3); 3. 做一个列表ul，其每个li里面有个按钮，点击该按钮时隐藏其父元素li 1234567var aBtn = document.getElementsByTagName("button");for (var i = 0; i &lt; aBtn.length; i++) &#123; // console.log(aBtn[i].parentNode); aBtn[i].onclick = function() &#123; this.parentNode.style.display = "none"; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js表单验证]]></title>
    <url>%2F2019%2F08%2F26%2Fjs%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[必填或必选项目（验证表单数据是否为空？）下面的函数用来检查用户是否已填写表单中的必填（或必选）项目。假如必填或必选项为空，那么警告框会弹出，并且函数的返回值为 false，否则函数的返回值则为 true（意味着数据没有问题）： 1234567891011121314&lt;form name="myForm" onsubmit="return notNull()" method="post"&gt; 姓名: &lt;input type="text" name="fname"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;script&gt; function notNull() &#123; var oName = document.forms["myForm"]["fname"].value; if (oName == null || oName == "") &#123; alert("姓名不能为空！"); return false; &#125; &#125;&lt;/script&gt; Email验证：下面的函数检查输入的数据是否符合电子邮件地址的基本语法。 意思就是说，输入的数据必须包含 @ 符号和点号(.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号： 12345678910111213141516&lt;form name="myForm" onsubmit="myFunction()"&gt; Email：&lt;input type="text" name="femail"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;script&gt; function myFunction() &#123; var oEmail = document.forms["myForm"]["femail"].value; var atpos = oEmail.indexOf("@"); var dotpos = oEmail.lastIndexOf("."); if (atpos &lt; 1 || dotpos &lt; atpos+2 || dotpos+2 &gt;= x.length) &#123; alert("不是有效的电子邮件地址！"); return false; &#125; &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树：根 左 右 递归：1. 递归公式 2. 终止条件二叉树中两个结点的公共祖先： 站在root的角度 把二叉树分为三个部分：根左右 如果两个结点不在root的同一棵子树中，最近公共祖先一定是root 如果两个结点在root的同一棵子树中，把问题留给该边的孩子去解决（递归） 如果两个结点中有一个结点是root，则最近公共祖先一定是root 二叉搜索树： 如何从二叉搜索树中得到一个有序序列？ 中序遍历 如果已经有一串有序序列了，能否组成双向链表？ 层序遍历： 把根结点放到队列中 循环 从队首取出结点 把该结点的左右孩子放到队列中 堆： ​ 逻辑上：完全二叉树 ​ 物理上：数组 二叉树如何用数组保存？ 层序遍历平铺在数组中 堆的基本功能：找最值 堆的两个重要操作： 向下调整/堆化（heapify） 前提：除了要调整的位置之外，其他位置都满足堆的性质 操作： 要调整的位置是叶子，则不需要调整 2. 找最大孩子的下标 3. 最大孩子的值和该位置的值比较，如果已经满足堆的性质了，则不需要调整 4. 交换两个位置的值 5. 继续调整最大孩子值（最大孩子处因为交换，可能不满足堆的性质了） 建堆 (createHeap) [最后一个非叶子结点, 0] 堆的应用： 优先级队列 时间复杂度 空间复杂度 稳定性 插入排序 O(n) | O(n) 稳定 选择 不稳定 冒泡 稳定 堆排 不稳定 快排：（分治算法） 确定基准值 边界 随机 多数取中 遍历整个待排序区间，把比基准值小的放左边，大的放右边]]></content>
  </entry>
  <entry>
    <title><![CDATA[js Es6基础语法]]></title>
    <url>%2F2019%2F08%2F20%2Fjs-Es6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1copyright: true]]></content>
  </entry>
  <entry>
    <title><![CDATA[js 正则表达式基础语法]]></title>
    <url>%2F2019%2F08%2F20%2Fjs-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[【概念】正则表达式是由普通字符及特殊字符组成的对字符串进行过滤的逻辑公式 正则表达式创建方式1234// 1. 字面量的方式var reg = /abc/;// 2. 构造函数的方式var reg = new RegExp("abc"); 正则表达式的方法 test()方法 1var flag = reg.test(str);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js cookie基础操作]]></title>
    <url>%2F2019%2F08%2F19%2Fjs-cookie%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[【概念】cookie ：是指缓存在本地客户端的数据 【功能】cookie基本操作包括增、删、改、查四个部分 123456789101112131415161718// 查询cookieconsole.log(document.cookie);// 设置cookiedocument.cookie = "username=honey";// 设置cookie期限var Date = new Date();oDate.setDate(oDate.getDate()+3);document.cookie = "username=honey;expires="+Date;// 修改cookie 同名的cookie会被覆盖document.cookie = "username=honey1";// 删除cookie,即给cookie设置一个过去的时间var Date = new Date();oDate.setDate(oDate.getDate()-1); // 无所谓减几document.cookie = "username=honey;expires="+Date; cookie操作的封装 setCookie()： 1234567function setCookie(name,value,day) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate()+day); document.cookie = name + "=" + value + ";expires=" + oDate;&#125;setCookie("name1", "honey1", 1);setCookie("name2", "honey2", 1); getCookie() 12345678910function getCookie(name) &#123; var str = document.cookie; var arr = str.split("; "); for(var i = 0; i &lt; arr.length; i++) &#123; var arr1 = arr[i].split("="); if(arr1[0] == name) &#123; return arr1[1]; &#125; &#125;&#125; removeCookie() 删除cookie 12345function removeCookie(name) &#123; setCookie(name,1,-1);&#125;removeCookie("name1"); consolelog(getCookie("name1")); //发现控制台没有name1了，删除成功！ cookie基础应用：记住用户账户密码，第二次登陆直接点击登录即可HTML部分： 1234用户名:&lt;input type="text"&gt;密码:&lt;input type="password"&gt;&lt;label&gt;&lt;input type="checkbox"&gt;七天免登录&lt;/label&gt;&lt;input type="button" value="登录"&gt; JS部分： 1234567891011121314151617181920212223242526272829303132333435363738// 提前封装好的cookie操作function setCookie(name,value,day) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate()+day); document.cookie = name + "=" + value + ";expires=" + oDate;&#125;function getCookie(name) &#123; var str = document.cookie; var arr = str.split("; "); for(var i = 0; i &lt; arr.length; i++) &#123; var arr1 = arr[i].split("="); if(arr1[0] == name) &#123; return arr1[1]; &#125; &#125;&#125;function removeCookie(name) &#123; setCookie(name,1,-1);&#125;var aInput = document.getElementsByTagName("input");// 判断cookie的usernam值是否存在if(getCookie("username")) &#123; // 赋值 aInput[0].value = getCookie("username"); aInput[1].value = getCookie("password");&#125;// 点击“登录”aInput[3].onclick = function() &#123; var username = aInput[0].value; var password = aInput[1].value; // 如果点击了“七天免登录” if(aInput[2].checked) &#123; // 七天过期 setCookie("username",username,7); setCookie("password",password,7); &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 事件event详解]]></title>
    <url>%2F2019%2F08%2F18%2Fjs-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[事件处理函数【类型】鼠标事件、键盘事件、HTML事件 【组成】on + 事件名称 事件流【概念】事件流描述的是页面接收事件的顺序 【阶段】事件流的三个阶段：捕获、目标、冒泡 DOM 2级事件 添加事件监听器：addEventListener(事件名, 处理函数, 布尔值) 移除事件监听器：removeEventListener(事件名, 处理函数) IE下的事件监听器：attachEvent(事件名, 处理函数)、 detachEvent(事件名, 处理函数)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 封装获取节点函数]]></title>
    <url>%2F2019%2F08%2F17%2Fjs-%E5%B0%81%E8%A3%85%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[封装一个函数，可以拥有几种获取元素节点的功能 【注】通过css选择器选择对应的选择器 1234567891011121314151617181920function $(vArg) &#123; // &lt;1&gt; 对参数进行区分 switch(vArg[0]) &#123; case "#": // id return document.getElementById(vArg.substring(1)); break; case ".": // className return elementByClassName(document, vArg.substring(1)); break; default: // 对参数的前5个字符，进行判断 var str = vArg.substring(0, 5); if(str == "name=") &#123; return document.getElementsByName(vArg.substring(5)); &#125; else &#123; return document.getElementsByTagName(vArg); &#125; break; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js DOM]]></title>
    <url>%2F2019%2F08%2F17%2Fjs-DOM%2F</url>
    <content type="text"><![CDATA[DOM对象 【概念】document object model，文档对象模型，是W3C标准，中立于平台和语言的接口，它允许程序和脚本动态的访问和更新文档的内容、结构和样式 HTML，CSS–页面内容 JS–页面行为操作 DOM–打通HTML，CSS，JS壁垒的一个工具 【分类】DOM中节点种类一共有三种，在JS中所有节点都是对象 ​ 测试div 元素节点： 属性节点：title = “属性节点” 文本节点：测试div 【注】这些节点都有三个属性，分别为：nodeName、nodeType、nodeValue 元素节点对象 查找元素节点的方法：document.getElementById(id);：通过当前元素节点的id，获取对应元素节点 【注】window.onload = function(){}：在页面加载完成以后执行的函数 元素节点属性 通过这个节点对象，访问它的一系列属性 tagName：获取元素节点的标签名 innerHTML：获取元素节点标签间的内容，解析标签 HTML属性的属性 访问这些属性id，title，style，className： 元素节点.属性名 元素节点[属性名] attribute方法set/getAttribute() 设置/获取元素节点 removeAttribute() 删除元素节点 【注】都是操作当前元素节点中某个属性的 12345// 修改某一属性值的方法// 方法1：点操作oDiv.title = "xxx";// 方法2：attribute方法oDiv.setAttribute("title", "xxx"); 上述两种方法的区别： &lt;1&gt; class属性范围区别：点操作是通过className，而set/getAttribute()是通过class &lt;2&gt; set/getAttribute()支持用户自定义属性 &lt;3&gt; removeAttribute()删除元素节点，如： 12// 删除title属性oDiv.removeAttribute("title"); 元素节点属性 childNodes ：获取当前元素节点的所有的子节点，包括两种节点类型：元素节点和文本节点 123alert(oDiv.childNodes); // 输出object NodeList// object NodeList 装有当前元素节点所有的子节点alert(oDiv.childNodes.length); // 输出子节点长度 ownerDocument：返回该节点的文档对象根节点，返回的对象相当于document 1alert(box.ownerDocument === document); // true， 根节点 insertBefore()方法【格式】父节点.insertbefore(插入的节点, 旧节点) 【功能】将插入的节点插入到旧节点之前 123456// 创建一个&lt;strong&gt;将这个节点插入到span节点之前// &lt;1&gt; 创建strongvar node = createElementWithTxt("strong", "strong文本");var oSpan = document.getElementByTagName("span")[0];// &lt;2&gt; 进行插入oSpan.parentNode.insertBefore(node, oSpan); 元素节点操作方法 replaceChild() ： 【格式】parent.replaceChild(newNode, oldNode); 【功能】用newNode替换oldNode 123456// 新建一个strong，代替原有的divwindow.onload = function() &#123; var oDiv = document.getElementsByTagName("div")[0]; var node = document.createElement("strong"); oDiv.parent.replaceChild(node, oDiv);&#125; cloneNode()： 【格式】node.cloneNode() 【功能】克隆节点 【返回值】新克隆出来的节点 【参数】true，默认是false，如果 传true，就会复制元素节点中的innerHTML 12345// 将div添加到span节点的前面// 方法一：原来的div被删除了oSpan.parentNode.insertBefore(oDiv, oSpan);// 方法二：克隆div节点并插入var node = oDiv.cloneNode(true); removeChild() ： 【格式】node.parentNode.moveChild(); 【功能】删除节点]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js BOM_history对象和search处理]]></title>
    <url>%2F2019%2F08%2F17%2Fjs-BOM-history%E5%AF%B9%E8%B1%A1%E5%92%8Csearch%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[history对象【定义】history是window对象的属性，它保存这个用户上网的记录 【属性】history.length：返回当前history对象中记录数，也就是历史记录的条数 【方法】 1. `history.back()`：返回上一条历史记录，类似于后退 2. `history.forward()`：前进到下一条历史记录，类似于前进 3. `history.go()`：参数为 0 时，重载当前页面；参数为正数时，前进对应数量的记录；参数为负数时，后退对应数量的记录 search处理例1~在web开发中，我们经常需要获取诸如?id=5&amp;search=ok这种类型的URL键值对，那么通过location，我们可以写一个函数来一一获取 1234567891011121314function getArray() &#123; // 创建一个存放键值对的数组 var array = []; // 取出?号 var str = location.search.length &gt; 0 ? location.search.substring(1) : ""; // 按&amp;字符串拆分数组 var items = str.split("&amp;"); // 遍历 for (var i = 0; i &lt; items.length; i++) &#123; var itemArray = items[i].split("="); array[i] = itemArray[1]; &#125; return array;&#125; 例2~获取URL中的search，通过传入对应的key，返回key对应的value，如：传入id，返回5 12345678910111213141516171819202122function getValue(search, key) &#123; // &lt;1&gt; 找出key第一次出现的位置 var start = search.indexOf(key); if(start == -1) &#123; return; &#125; else &#123; // &lt;2&gt; 找出键值对，结束的位置 var end = search.indexOf("&amp;", start); if(end == -1) &#123; //这是最后一个键值对 end = search.length; &#125; &#125; // &lt;3&gt; 将这个键值对提取出来 var str = search.substring(start, end); // alert(str); // &lt;4&gt; key = value 获取value var arr = str.split("="); return arr[1];&#125;var search = "?id=5&amp;search=ok";getValue(search, "search");]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js BOM_location属性和方法]]></title>
    <url>%2F2019%2F08%2F16%2Fjs-BOM-location%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[location对象【定义】 浏览器最上方的地址栏输入框，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能 【属性】 (组成一个url的各个部分) ​ url：统一资源定位符（相当于快递包上的一个地址） location.hash：锚点，也就是url最后的#部分，实现页内跳转 12345678// 获取锚点alert(location.hash); // hash是锚点，也就是url最后的#部分，实现页内跳转// 设置页面锚点window.onload = function() &#123; document.onclick = function() &#123; location.hash = "#3"; // 点击页面任意位置时，可以看到url最后加了#3 &#125;&#125; host：主机名端口号 浏览器的端口号，默认是8080， IP：通过IP可以在全球范围内找到这台电脑所使用的网络的地址 端口号：正在使用网络的软件，在当前电脑内唯一的标识 hostname：主机名，域名/IP 域名：就是给IP起的好记的名字 href：整个url pathname：路径名 port：端口号 protocal：协议 http：网络协议 file：本地文件协议 search ：查询字符串，跟在?后面的部分 123456// 设置window.onload = function() &#123; document.onclick = function()&#123; location.search = "?xxx=yyy&amp;age=18"; &#125;&#125; 补充：url：统一资源定位符 包括以下几个部分: protocol(协议):host(主机名):port(端口号)/pathname(路径)?查询字符串(search)#锚点(hash) 例~http://www.baidu.com:8080/code/xxx.html?username=xxx&amp;age=18#1 location对象的方法 assign()：跳转到指定的url 12// 跳转到百度页面location.assign("http://www.baidu.com"); reload()：重载当前的url 如果传参(忽略缓存)，参数为true时，强制加载，即从服务器源头重新加载 1234// 刷新当前页面（无参数时）location.reload();// 强制加载（有参数时）location.reload(true); replace()：用新的url替换当前页面，可以避免产生跳转前的历史记录]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js BOM_open()方法]]></title>
    <url>%2F2019%2F08%2F16%2Fjs-BOM-open-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[【调用】open() 【参数】（三个） 要加载的URL 窗口的名称或窗口的目标 一串具有特殊意义的字符串 【注意】 只有第一个参数，调用open()方法会打开新窗口，加载url 第二个参数是给打开的新窗口起一个名字，以后再去加载url，就在已经起好名字的目标窗口加载url 第三个参数是设置当前打开窗口的参数，比如：width、height 例1~点击按钮打开百度页面 ​ HTML部分： 1&lt;input type="button" value="按钮" /&gt; ​ JS部分： 123456789window.onload = function() &#123; var oBtn = document.getElementsByTagName("input")[0]; oBtn.onclick = function() &#123; // 只有第一个参数 open("http://www.baidu.com"); // 有两个参数 open("http://www.baidu.com","百度"); &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js BOM_系统对话框]]></title>
    <url>%2F2019%2F08%2F16%2Fjs-BOM-%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[三种系统对话框 alert()：直接弹出警告框 confirm()： 【功能】弹出一个带有确定和取消按钮的警告框 【返回值】点击确定，返回true；点击取消，返回false prompt()： 【功能】弹出一个带输入框的提示框 【参数】（可以是两个） 第一个参数：要在提示框上显示的内容 第二个参数：输入框内默认的值 【返回值】点击确定，返回值是输入的内容；点击取消，返回值是null ​]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数创建对象]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前面有两种创建对象的方法：1.对象字面量创建对象；2. new Object()创建对象； 但是这两种方法一次只能创建一个对象，但可能不同的对象里面很多的属性和方法是大量相同的，而我们只能复制，因此我们可以用构造函数的方法重复这些相同的代码 构造函数：把对象里面一些相同的属性和方法抽象出来封装到函数里面，主要用来初始化对象 构造函数的语法格式：123456function 构造函数名() &#123; this.属性 = 值; this.方法 = function() &#123;&#125;&#125;// 调用构造函数要用newnew 构造函数名(); 注意：1. 构造函数名首字母要大写 ​ 2. 构造函数不需要return就可以返回结果 ​ 3. 调用构造函数必须使用new ​ 4. 只要new Star()调用函数就可以创建一个对象ldh {} ​ 5. 构造函数的属性和方法前面必须添加this 构造函数和对象的区别： 构造函数（泛指）：是泛指的一大类，相当于Java中的类(class)；如：明星 对象（特指）：是一个具体的事物，看得见摸得着；如：刘德华 == {name: “刘德华”, age: 18, sex: “男”, sing: f} 利用构造函数创建对象的过程也称为对象的实例化 例1：创建四大天王的对象 ​ 分析：相同的属性：名字、年龄、性别 ​ 相同的方法：唱歌 12345678910111213// 声明构造函数function Star(uname,age,sex) &#123; this.uname = uname; this.age = age; this.sex = sex; this.sing = function(sang) &#123; console.log(sang); &#125;&#125;// 调用构造函数var ldh = new Star("刘德华",18,"男");// 调用函数返回的是一个对象ldh.sing("冰雨");zxy.sing("李香兰"); 例2：利用构造函数创建两个英雄对象，函数中的公共部分包括：姓名属性(name)，类型属性(type)，血量属性(blood)和攻击方式(attack) 12345678910111213141516171819function Hero(name,type,blood) &#123; this.name = name; this.type = type; this.blood = blood; this.attack = function(method) &#123; console.log(method); &#125;&#125;var LianPo = new Hero("廉颇","力量型","500血量"); // 创建了廉颇的对象var HouYi = new Hero("后羿","射手型","100血量"); // 创建了后羿的对象 // 遍历对象for(var k in LianPo) &#123; console.log(LianPo[k]);&#125;LianPo.attack("近战");for(var k in HouYi) &#123; console.log(HouYi[k]);&#125;HouYi.attack("远程"); new关键字执行过程： new构造函数可以在内存中创建一个新的空对象 this就会指向这个新的对象 执行构造函数里面的代码，给这个新对象添加属性和方法 返回这个新对象（所以构造函数里不需要return） 遍历对象：for...in语句 语法格式：for(变量 in 对象) 1234for(var k in obj) &#123; console.log(k); // k是变量，得到的是属性名 console.log(obj[k]); // ob[k]是对象,得到的是属性值&#125; 注意：一般 for...in 里面的变量为 k 或者 key 练习： ​ 创建一个电脑对象，该对象要有颜色、重量、品牌、型号，可以看电影、听音乐、打游戏和敲代码 123456789101112131415161718function Computer(brand,type,color,weight) &#123; this.brand = brand; this.type = type; this.color = color; this.weight = weight; this.action = function(active) &#123; console.log("这个对象可以" + active); &#125;&#125;var obj = new Computer("联想","KONEW12","灰色","1.5kg");// 遍历对象for(var k in obj) &#123; console.log(obj[k]);&#125;obj.action("看电影");obj.action("听音乐");obj.action("打游戏");obj.action("敲代码");]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js预解析]]></title>
    <url>%2F2019%2F08%2F11%2Fjs%E5%9F%9F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[当变量没有var声明，直接赋值时，相当于全局变量，不会被销毁 JS引擎执行js分为两步：1.预解析；2.执行代码（1）预解析：js引擎会把js里所有的var和function提升到当前作用域的最前面 （2）代码执行：按照代码书写的顺序从上往下执行 预解析分为：变量预解析（变量提升）、函数预解析（函数提升）**（1）变量提升：把所有的变量声明提升到当前的作用域最前面，但不提升赋值操作 ​ 例： 12345678910111213fun(); // 报错 var fun = function() &#123; console.log(22); &#125;// 在这种初始化变量的情况下，函数调用要在后面/* 分割线 *///上面的代码相当于以下代码var fun;fun(); // 按顺序执行，上面并没有fun()这个函数，所以报错fun = function() &#123; console.log(22);&#125; ​ （2）函数提升：把所有的函数声明提升到当前作用域 ​ 例： 1234fn(); // 输出11function fn() &#123; // 在js眼里，函数声明是在fn()之前的 console.log(11);&#125; 预解析案例： ​ (1) 案例一：以下代码结果是多少？ 123456var num = 10;fun();function fun() &#123; console.log(num); var num = 20;&#125; ​ 预解析分析： 123456789// 相当于执行了以下操作var num; // 不提升值function fun() &#123; var num; // 函数内部的var提升到当前作用域 console.log(num); // 按顺序执行，num没有赋值，所以结果是undefined num = 20;&#125;num = 10;fun(); ​ (2) 案例二：以下代码结果是多少？ 1234567var num = 10;function fn() &#123; console.log(num); var num = 20; console.log(num);&#125;fn(); ​ 预解析分析： 123456789// 相当于执行了以下操作var num;function fn() &#123; var num; console.log(num);// 输出undefined num = 20; console.log(num); // 输出20&#125;fn(); ​ (3) 案例三：以下代码结果是多少？ 12345678var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = '123';&#125; ​ 预解析分析： 123456789101112// 相当于执行了以下操作var a;function f1() &#123; // 函数声明也要提到前面 var b; var a; b = 9; console.log(a); // undefined console.log(b); // 9 a = '123';&#125;a = 18;f1(); ​ (4) 案例四：以下代码结果是多少？ 1234567891011f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; // 相当于var a = 9; b = 9; c = 9;也就是b和c没有var声明，直接赋值，相当于全局变量 console.log(a); console.log(b); console.log(c);&#125; ​ 预解析分析： 123456789101112// 相当于执行了以下操作function f1() &#123; var a,b,c; a = b = c = 9; console.log(a); // 9 console.log(b); // 9 console.log(c); // 9&#125;f1();console.log(c); // 9 ,全局变量console.log(b); // 9 ,全局变量console.log(a); // 报错，没有被定义 （局部变量执行完就被销毁）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3渐变(Gradients)]]></title>
    <url>%2F2019%2F08%2F06%2FCSS3%E6%B8%90%E5%8F%98(Gradients)%2F</url>
    <content type="text"><![CDATA[CSS3 渐变可以让你在两个或多个指定的颜色之间显示平稳的过渡，它有两种渐变分别为线性渐变和径向渐变 CSS3 定义了两种类型的渐变： 线性渐变（Linear Gradients）：向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）： 由它们的中心定义 浏览器支持： 属性 浏览器类别 IE浏览器 谷歌浏览器 火狐浏览器 linear-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- radial-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- repeating-linear-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- repeating-radial-gradient 10.0 26.0 10.0 -webkit- 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- 1. 线性渐变(linear gradients)​ 为了创建一个线性渐变，必须至少定义两种颜色结点(颜色结点即想要呈现平稳过渡的颜色)。同时，也可以设置一个起点和一个方向（或一个角度）。 线性渐变-从上到下（默认情况下）： 123456789div&#123; width:450px; height: 300px; background: linear-gradient(#03a9f4, #f71ab95e); /* 标准的语法 */ /* 以下三种均是为了适应浏览器而写，因为我用的是Google浏览器，所以下面只举适应谷歌浏览器的例子 */ background: -webkit-linear-gradient(#03a9f4, #f71ab95e); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(#03a9f4, #f71ab95e); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(#03a9f4, #f71ab95e); /* Firefox 3.6 - 15 */&#125; 线性渐变-从左到右： 123456div&#123; width: 450px; height: 300px; background: linear-gradient(left, #03a9f4, #f71ab95e);/* 标准写法，谷歌浏览器不兼容 */ background: -webkit-linear-gradient(left, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-对角：可以通过指定水平和垂直的起始位置来制作一个对角渐变 123456div&#123; width: 450px; height: 300px; background: linear-gradient(left top, #03a9f4, #f71ab95e);/* 标准写法，谷歌浏览器不兼容 */ background: -webkit-linear-gradient(left top, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-自定义角度：如果想要在渐变的方向上做更多的控制，可以自定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right等等） 注意：很多浏览器(Chrome,Safari,fiefox等)使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度 123456div&#123; width: 450px; height: 300px; background: linear-gradient(150deg, #03a9f4, #f71ab95e);/* 标准写法 */ background: -webkit-linear-gradient(150deg, #03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 线性渐变-使用多个颜色结点： 123456div&#123; width: 450px; height: 300px; background: linear-gradient(pink,#03a9f4, #f71ab95e);/* 标准语法 */ background: -webkit-linear-gradient(pink,#03a9f4, #f71ab95e);/* 谷歌浏览器 */&#125; 使用透明度（transparent）：CSS3 渐变也支持透明度，可用于创建减弱变淡的效果。为了添加透明度，我们使用 rgba()函数来定义颜色结点。rgba()函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。 123456div&#123; width: 450px; height: 300px; background: linear-gradient(right,rgba(247,26,185,0.37 ),rgba(3,169,244,0.8));/* 标准语法 */ background: -webkit-linear-gradient(right,rgba(247,26,185,0.37 ),rgba(3,169,244,0.8));/* 谷歌浏览器 */&#125; 重复的线性渐变：repeating-linear-gradient() 函数用于重复线性渐变 12345div&#123; width: 450px; height: 300px; background: -webkit-repeating-linear-gradient(#03a9f4 30%, #f71ab95e 70%);/* 谷歌浏览器 */&#125; 2. 径向渐变(radial-gradient)​ 径向渐变(radial-gradient)由它的中心定义。必须至少定义两种颜色结点(颜色结点即你想要呈现平稳过渡的颜色)。同时，也可以指定渐变的中心、形状（圆形或椭圆形）、大小(closest-side：最近；farthest-corner：最远)。 默认情况下，渐变的中心是 center，渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落） 默认情况下： 12345div&#123; width:150px; height: 150px; background: -webkit-radial-gradient(#03a9f4 30%, #f71ab95e 70%);&#125; 设置径向渐变的大小以及形状：shape 参数定义了形状，它可以是值 circle（圆形）或 ellipse（椭圆形）。默认值是ellipse 123456789div&#123; width: 150px; height: 150px; background: radial-gradient(circle, #03a9f4, #f71ab95e);/*我试了一下，在谷歌浏览器里如果设置形状就没办法显示*/ /* 其他浏览器 */ background: -webkit-radial-gradient(circle, closest-side,#03a9f4,#f71ab95e); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(circle,closest-side,#03a9f4,#f71ab95e); /* Opera 11.1 - 12.0 */ background:-moz-radial-gradient(circle, closest-side,#03a9f4,#f71ab95e); /* Firefox 3.6 - 15 */&#125; size 参数定义了渐变的大小。它可以是以下四个值： closest-side：径向渐变的半径长度为从圆心到离圆心最近的边 farthest-side：径向渐变的半径长度为从圆心到离圆心最远的边 closest-corner：径向渐变的半径长度为从圆心到离圆心最近的角 farthest-corner：径向渐变的半径长度为从圆心到离圆心最远的角 12345div&#123; width:450px; height: 300px; background: radial-gradient(60% 55%, closest-side,#03a9f4,#f71ab95e); /* 标准的语法 */ background: -webkit-radial-gradient(40% 55%, closest-side,#03a9f4,#f71ab95e); /* 谷歌浏览器 */ 重复的径向渐变：repeating-radial-gradient()函数用于重复径向渐变 效果像一朵花一样很好看~ 123456div&#123; width:450px; height: 300px; background: repeating-radial-gradient(#03a9f4 40%,#f71ab95e 60%); /* 标准的语法 */ background: -webkit-repeating-radial-gradient(#03a9f4 40%,#f71ab95e 60%);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和css知识点]]></title>
    <url>%2F2019%2F08%2F01%2Fhtml%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[HTML部分知识点总结 块元素（将内容分块显示）：特立独行，不在一行中显示 eg：h1,h2,…,h6,p,blockquote . 块元素在内容前后分别有一个默认的换行内联元素（显示在所在的段落中）：随波逐流 eg：q,a,em link：利用外部样式表为本页面增加样式（不再需要style） eg：新建一个lounge.css文件1&lt;link type="test/css" rel="stylesheet" href="lounge.css"&gt; em ：斜体；strong：加粗；b：加粗（强调文本）1&lt;em&gt;我是一个斜体标签&lt;/em&gt; q：短引用（段落中的引用）；blockquote：长引用（引用独立的文字） 12&lt;q&gt;千里之行，始于足下&lt;\q&gt;&lt;blockquote&gt;我是一个长引用&lt;/blockquote&gt; br：换行 code：显示计算机程序代码 li：列表元素；ol：有序列表；ul：无序列表（不与p标签写在一起，都是块元素）123456&lt;ol&gt; &lt;li&gt;Walla, WA&lt;/li&gt; &lt;li&gt;Magic city, ID&lt;/li&gt; &lt;li&gt;Bountiful, UT&lt;/li&gt; &lt;li&gt;Last chance, CO&lt;/li&gt;&lt;/ol&gt; StarBuzzCoffee.com是域名（范围大）；www.StarBuzzCoffee.com是网站名（范围小） 链接页面的方式：a.相对路径：只能链接同一网站的页面 b.URL：通常用来链接其他网站 为链接增加标题以便访问：a herf=”” title=”” 当鼠标移到链接上，停留一秒，就可以看到这个工具提示1Read the &lt;a href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt;. 使用id属性为超链接a创建目标 用id链接到元素：要链接到页面中的一个特定目标，只需在链接最后加一个#，再加上目标标志符1&lt;a href="index.html#chai"&gt;See Chai Tea&lt;/a&gt; 使用target打开新窗口 1&lt;a target="_blank" href="http://wickedlysmart.com/buzz" title="Read all about caffeine on the Buzz"&gt;Caffeine Buzz&lt;/a&gt; 调整图像大小：width和heightsrc：引入和替代 href：引用和链接 alt：当图片无法识别时的提示 title：鼠标点击图片时的提示 target=”_black”：在新窗口打开新页面 target=”_self”：在原来的窗口打开页面 1&lt;img src="../images/red.jpg" alt="" width="200" height="200"&gt; W3C验证工具：http://validator.w3.org 绝对路径：相对于计算机的路径 相对路径：一般使用 背景定位常用指令：水平方向Left center right；垂直方向top center bottom css知识点汇总注：在CSS中，不需要给元素两边加尖括号&lt;&gt;，所有元素都叫做选择器 把css放入html：在head元素中增加开始和结束style标记，css规则要放在style里 margin-left, margin-right：左右外边距，占页面的20% 12margin-left: 20%;margin-right: 20%; border：定义页面主体周围的边框 虚线：dotted，实线：solid，颜色为黑色 1border: 2px dotted black; padding：在页面主体周围创建一些内边距 1padding:10px 10px 10px 10px; font-family：定义文本使用的字体1font-family: sans-serif; color：设置文字颜色1color:red; border-bottom：加下划线 eg：在h1标题下加下划线123h1&#123; border-bottom: 1px solid black; &#125; 盒子模型=内容+内填充+外边距+边框]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Operation Of Hexo]]></title>
    <url>%2F2019%2F08%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment The Step Of Upload12345$ hexo s$ hexo clean$ hexo g$ hexo s$ hexo d]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js字符串和数组方法]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串方法 前面我们学习了字符串，用字面量方式声明一个字符串： 123var str = ' nihao';str.length; //获取字符串的长度str.charAt(2); 获取传入下标序号处的字符(ES5中可以用str[2]) 注意：如果不传默认值为”0”，当传入的下标超出字符串长度时返回”null” 字符串其他方法： 12345678910111213141516str.charCodeAt(2); //获取传入下标序号处的字符的Unicode编码值，如果不传值默认值为"0"String.fromCharCode(); //传入Unicode编码值返回对应的字符，可以传多个编码，用','分割str.indexOf(); //获取()中字符在字符串中从左向右第一次出现的下标str.lastIndexOf(); //获取()中字符在字符串中从右向左第一次出现的下标//上面两个方法可以传多个连续的字符，未找到返回-1，第二个可选参数为开始位置的下标(负数和不写默认是从0/最后开始)str.substring(); //截取两个参数之间的字符串，传入的两个参数会自动检测大小，按照从小到大的顺序截取，不写和负数默认从0开始，注：包括首位，不包括尾位str.slice(); //同上，但不会自动检测参数大小，参数为负数时从后向前计算(最后一个字符为-1，依次向前-2，-3...)//被截取的字符串包含第一个参数位置的字符，不包括第二个参数位置的字符，如果只有一个参数则是从第一个参数截取到字符串结尾str.toUpperCase(); //把字符串的字母字符转换成大写str.toLowerCase(); //把字符串的字母字符转换成小写str.split('.'); //用参数的字符将字符串分割成数组，第二个可选参数限制生成数组的长度(超出的部分会被舍去)//不传参会返回只有一个数据(该字符串)的数组；分割每个字符需要传一个空字符串''；分隔符在左右也会在数组(开头/结尾)生成空字符 数组方法 数组的声明方式 1234var arr = [1,2,3]; //字面量写法，推荐这种写法var arr = new Array(1,2,3); //构造函数实例化写法// 特殊情况var arr1 = new Array(2); // 数组长度为2，数组内容为空 构造函数实例写法在参数只有一个且是数字它会理解为长度，是字符串它会理解为内容，所以用推荐第一种写法 如果定义后的数组重新定义长度，那么数组会变成新的长度，多余的数据舍去，增多的数据为空(字符串length重新设置不会改变长度)： 123arr.length = 2; //[1,2]arr.length = 0; //快速清空一个数组arr[3] = 4; //[1,2, ,4]; 数组其他方法： 12345678910111213141516171819202122232425arr.join(''); // 用参数的字符把数组里的内容连成字符串，split的反义词arr.push(); // 向数组后添加数据arr.unshift(); // 向数组前添加数据// 添加方法返回值为新数组的长度arr.pop(); // 从数组后删除数据arr.shift(); // 从数组前删除数据// 删除方法返回值为被删除的数据arr.splice(); // 数组的删除、替换和添加方法，根据参数作用不同arr.splice(a,b); // 删除：a为删除的起点位置，b为删除数据的数量，只有删除的时候会有返回值(既被删除的数据，但是装在数组里)arr.splice(a,b,c,...n); // 替换：a为替换的起点位置，b为删除数据的数量，c及c后面的所有参数为替换后的新数据arr.splice(a,0,c,...n); // 添加：a为添加的起点位置，0为不删除数据，c及c后面的所有参数为添加的新数据arr.sort(); // 排序：按照数据字符串的Unicode 编码大小把内容按照顺序进行排列，不能直接排数字。arr.sort(function(a,b) &#123; // 用高阶函数排序数字 return a-b/b-a; // 正序/反序&#125;)arr.sort(function(a,b) &#123; // 乱序排列数字 return Math.random()-0.5; // 随机得到正负值 &#125;)arr.reverse(); // 倒序，将数组反向排列var newArr = arr.concat(arr1,arr2...); // 数组拼接：将arr1、arr2...拼接在arr后面，结果为新数组arr.indexOf(); // 同字符串的indexOf，找出参数在数组中从左向右第一次的出现的下标 练习： 1. 判断输入框内容是否都为数字(用Unicode) 12 2. 加密和解密：让一段字符串在两个p标签里显示加密后的乱码和还原回来的字符串 ​ HTML: 12345&lt;input type="text" /&gt;&lt;button&gt;加密&lt;/button&gt;&lt;p&gt;&lt;/p&gt;&lt;button&gt;解密&lt;/button&gt;&lt;p&gt;&lt;/p&gt; ​ JS： 12345678910111213141516171819window.onload = function() &#123; oInput = document.getElementsByTagName("input")[0]; aBtn = document.getElementsByTagName("button"); aP = document.getElementsByTagName("p"); aBtn[0].onclick = function() &#123; var str = oInput.value; for(var i = 0; i &lt; str.length; i++) &#123; aP[0].innerHTML += String.fromCharCode(str.charCodeAt(i) + 10); &#125; &#125; aBtn[1].onclick = function() &#123; var str = aP[0].innerHTML; for(var i = 0; i &lt; str.length; i++) &#123; aP[1].innerHTML += String.fromCharCode(str.charCodeAt(i) - 10); &#125; &#125; &#125; 3. 找到字符串’同学们在新学期里有新学期的样子，并开始了新学期的学习’中每个’学期’的位置和出现的次数。 1234567891011window.onload = function() &#123; var str = "同学们在新学期里有新学期的样子，并开始了新学期的学习"; var s = "新学期"; var arr = []; var i = 0; while(str.indexOf(s,i) &gt;= 0) &#123; arr.push(str.indexOf(s,i)); i = str.indexOf(s,i) + s.length; &#125; console.log(arr);&#125; 4. 使一段文字在点击按钮时变成20个字符+’……’，再次点击按钮后展开还原，按钮也要在”展开”和”收缩”来回切换 ​ HTML部分： 1234567&lt;p&gt;第十三届大会上电话是多少第十三届大会上电话是多少 第十三届大会上电话是多少第十三届大会上电话是多少 第十三届大会上电话是多少第十三届大会上电话是多少 第十三届大会上电话是多少第十三届大会上电话是多少第十三届大会上电话是多少 第十三届大会上电话是多少第十三届大会上电话是多少第十三届大会上电话是多少第十三届大会上电话是多少&lt;/p&gt;&lt;button&gt;收起&lt;/button&gt; ​ JS部分： 1234567891011121314151617window.onload = function() &#123; var oP = document.getElementsByTagName("p")[0]; var oBtn = document.getElementsByTagName("button")[0]; oP.inner = oP.innerHTML; var a = true; oBtn.onclick = function() &#123; if(a) &#123; oP.innerHTML = oP.innerHTML.substring(0, 20) + "..."; oBtn.innerHTML = "展开"; a = false; &#125; else &#123; oP.innerHTML = oP.inner; oBtn.innerHTML = "收起"; a = true; &#125; &#125;&#125; 5. 设置几个颜色（红、黄、蓝、绿、黑），在输入框中输入文字，点击按钮后在p标签中生成背景颜色不同的文字 ​ HTML部分： 123&lt;input type="text"&gt; &lt;button&gt;生成&lt;/button&gt; &lt;p&gt;&lt;/p&gt; ​ JS部分： 12345678910111213window.onload = function() &#123; var oInput = document.getElementsByTagName("input")[0]; var oBtn = document.getElementsByTagName("button")[0]; var oP = document.getElementsByTagName("p")[0]; var arr = ["red","orange","yellow","green","blue","pink"]; oBtn.onclick = function() &#123; oP.innerHTML = "&lt;span&gt;" + oInput.value.split("").join("&lt;/span&gt;&lt;span&gt;") + "&lt;/span&gt;"; var aSp = document.getElementsByTagName("span"); for (var i = 0; i &lt; aSp.length; i++) &#123; aSp[i].style.color = arr[i % arr.length]; &#125; &#125; &#125; 6. 做一个点击查找一段字符（将所需查找的字段显示为高亮）和替换一段字符（将被替换的字段显示为高亮）的效果 ​ HTML部分： 123456789101112131415&lt;p&gt;反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的 反倒是基本上的痕迹打飞机客户端附近的客户发的&lt;/p&gt;&lt;input type="text"&gt;&lt;button&gt;查找&lt;/button&gt;&lt;input type="text"&gt;&lt;button&gt;替换&lt;/button&gt; ​ JS部分： 1234567891011121314151617181920212223242526272829window.onload = function() &#123; var aInput = document.getElementsByTagName("input"); var aBtn = document.getElementsByTagName("button"); var oP = document.getElementsByTagName("p")[0]; oP.inner = oP.innerHTML; aBtn[0].onclick = function() &#123; var str = aInput[0].value; if (oP.inner.indexOf(str) &gt;= 0) &#123; oP.innerHTML = oP.inner.split(str).join("&lt;span&gt;" + str + "&lt;/span&gt;"); var aSpan = document.getElementsByTagName("span"); for (var i = 0; i &lt; aSpan.length; i++) &#123; aSpan[i].style.backgroundColor = "yellow"; &#125; &#125; else &#123; alert("没有查找到该字符！"); &#125; &#125; aBtn[1].onclick = function() &#123; var str = aInput[0].value; if (oP.inner.indexOf(str) &gt;= 0 &amp;&amp; str) &#123; oP.innerHTML = oP.inner.split(str).join("&lt;span&gt;" + aInput[1].value + "&lt;/span&gt;"); var aSpan = document.getElementsByTagName("span"); for (var i = 0; i &lt; aSpan.length; i++) &#123; aSpan[i].style.backgroundColor = "blue"; aSpan[i].style.color = "white"; &#125; &#125; &#125;&#125; 7. 每点击一次就将[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]的最后一位放到第一位，如：[&#39;5&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;] ​ HTML部分： 1&lt;button&gt;点击&lt;/button&gt; ​ JS部分： 12345678910window.onload = function() &#123; var arr = ['1','2','3','4','5']; var oBtn = document.getElementsByTagName("button")[0]; console.log("原数组为：" + arr); oBtn.onclick = function() &#123; // 删除最后一个值的同时把最后一个值加到首位 arr.unshift(arr.pop()); console.log("点击后：" + arr); &#125;&#125; 8. 数组去重（去掉数组的重复数据）如：将var arr =[1,2,2,2,2,3,3,4,4,4,2,3] 变成[1,2,3,4] ​ HTML部分： 1&lt;button&gt;排序并去掉重复项&lt;/button&gt; ​ JS部分： 1234567891011121314151617181920212223242526window.onload = function() &#123; var arr =[1,2,2,2,2,3,3,4,4,4,2,3]; var oBtn = document.getElementsByTagName("button")[0]; console.log("原数组为：" + arr); oBtn.onclick = function() &#123; // 将原数组进行排序 for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; console.log("按从小到大排序：" + arr); // 去掉重复项 var arr1 = []; // 新数组用来存储去掉重复项后的字符 for (var k = 0; k &lt; arr.length; k++) &#123; if (arr[k] != arr[k+1]) &#123; arr1.push(arr[k]); &#125; &#125; console.log("去掉重复项后：" + arr1); &#125;&#125; 9. 把数组[&#39;345px&#39;,&#39;23px&#39;,&#39;10px&#39;,&#39;1000px&#39;]按照数据数字的从大到小的顺序排列 12 10. 把一个字符串var str = &quot;abcdef&quot;变成倒序 123456window.onload = function() &#123; var str = "abcdef"; console.log("原字符串：" + str); var str1 = str.split("").reverse().join(""); console.log("翻转后：" + str1);&#125; 11. 随机生成7个1~50之间不重复的整数，并存在一个数组中 12345678910111213141516171819window.onload = function() &#123; var arr = []; for (var i = 0; i &lt; 6; i++) &#123; var flag = true; // 检查是否重复 var num = Math.floor(Math.random() * (50 - 1)) + 1; // 生成随机数 // 循环判断随机数是否重复 for (var i in arr) &#123; if (num == arr[i]) &#123; flag = false; break; &#125; &#125; // 随机数不重复，加到数组中 if (flag == true) &#123; arr.push(num); &#125; &#125; console.log("生成的随机数数组为：" + arr);&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js计时器和动画]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E8%AE%A1%E6%97%B6%E5%99%A8%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[获取元素样式 元素.style.width获取的样式是元素的行间样式(不管该样式是否有效)，若样式时通过选择器写成内部或外链样式时就无法获取了 计算元素有效的样式的代码： 12getComputedStyle(元素).width; //标准浏览器元素.currentStyle.width; //IE8及以下浏览器 处理浏览器兼容后封装代码： 1234function getStyle(obj,attr)&#123; return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr]; &#125;getStyle(元素,'样式名'); //调用，获得我们需要元素的样式 注意的问题： 获取的样式是带有单位的(100px)，需配合parseInt或者parseFloat方法获得数字结果 不能获取像background这种复合样式，只能用backgroundColor等非复合样式分别获取 由于是计算的结果，获取的颜色格式不同(如red和rgb(255,0,0)都是红色)，因此结果不能用做判断，可以用做赋值 传参的字符串里面不能出现空格，否则变成未定义 未设置的样式不要获取，有的浏览器会将未设置的样式值设置为auto，导致结果出现错误 例~按钮控制div元素移动 ​ JS部分： 123456789var oDiv = document.getElementsByTagName("div")[0];var oBtn = document.getElementsByTagName("button")[0];function getStyle(obj,attr)&#123; return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr]; &#125;oBtn.onclick = function ()&#123; oDiv.style.left = parseFloat(getStyle(oDiv,"left"))+10+"px"; oDiv.style.top = parseFloat(getStyle(oDiv,"top"))+10+"px";&#125; ​ HTML部分： 12&lt;div&gt;&lt;/div&gt;&lt;button&gt;移动&lt;/button&gt; ​ CSS部分： 123456789div&#123; width: 150px; height: 150px; border-radius: 50%; background-color: red; position: absolute; left: 0; top: 100px;&#125; 计时器 循环计时器：每隔传入的毫秒时间执行一次传入的函数 对比循环：不同点——循环计时器带有时间概念，而循环的所有重复执行的代码是瞬间完成的，没有时间概念；相同点——它们都在重复执行代码 语法：setInterval(函数,毫秒);例如： 12345var i = 0;setInterval(function ()&#123; //这里可以是函数名(有名函数)，也可以是匿名函数 document.title = i; i++;&#125;,1000); 注意：计时器是我们学习的第三种函数调用的方法；计时器时间一般写20ms或以上，太短浏览器可能反应不过来，导致速度比预想的要慢 停止循环计时器的方法：clearInterval()，用法是先创建一个接受计时器返回值的变量timer，在需要停止计时器的地方使用clearInterval()并传入变量timer就可以了，例如： 12345678var i =0;var timer = setInterval(function ()&#123; //计时器的返回值就是一个序号 document.title = i; i++; if(i===10)&#123; clearInterval(timer); //停止对应序号的计时器 &#125;&#125;,1000); 注意：多次开启计时器时，若每次开启前没有关闭之前的计时器会导致我们timer里保存的是最后一个计时器的返回值，从而只能关闭最后一个计时器，解决方法就是每次调用时先关闭之前的计时器(尤其计时器是由用户控制的时候) 延时计时器：延时传入的毫秒时间执行一次传入的函数 语法：setTimeout(函数,毫秒); 循环计时器和延时计时器都要等一段时间后才执行第一次代码，若需要立即调用一次则需要在页面刷新后直接调用一次函数 对应的延时计时器的清除方法：clearTimeout(timer); 用clearTimeout()停止延时计时器后，若延时计时器的函数还未调用，那么函数便不会被执行了 延时计时器配合递归可以做出和循环计时器一样的效果，并且比循环计时器拥有更好的性能 面试题~ 管理和封装计时器 封装一个doMove函数，用来做动画效果 用计时器移动元素时需要注意： 判断终点位置时不能用==，若总长不能整除步长会停不下来；如果用&gt;=虽然会停下来，但不能直接赋值，该限制应该在赋值之前，否则在视觉上有个超过终点后的后退效果 每次开启计时器时应该注意先清除之前的计时器 timer定义成自定义属性(oDiv.timer)，并在定义时清除一下这个自定义属性，clearInterval可以清除null和未定义，这样做的好处是不靠任何外面的变量，为的是后面的封装 封装的过程我们要分清代码中哪些数据是变化的，并把他们变成参数 事件和计时器调用函数时函数名是不能加()的(因为函数名+()就变成返回值了)，如果需要传参必须将该事件调用改成调用匿名函数，然后在匿名函数里面直接调用该函数的办法 传入的正值和负值对用户来说并不友好，用户还要根据方向来判断需要传入值得正负，我们可以把代码改成判断当前位置和目标点位置来确定 我们在封装时的大量判断代码在方便用户的同时提高用户体验，而且也方便自己后来使用 回调函数：就是一个函数执行完毕后再执行的另外一个函数。在封装的函数内部回调函数不一定有，因此我们一般做一个判断，如果有回调则执行，没有回调则什么都不会发生 练习： 1. 一个img标签，每隔1.5秒自动切换一张图片，并且鼠标移入时让自动切换停止，鼠标离开继续切换（准备四张图片） ​ JS部分： 12345678910111213141516var oImg = document.getElementsByTagName("img")[0]; var arr = ["img/1.png","img/2.png","img/3.png","img/4.png"]; var i=0; var timer = setInterval(function()&#123; oImg.src = arr[i++]; i == arr.length &amp;&amp; (i=0); &#125;,1000) oImg.onmouseover = function ()&#123; clearInterval(timer); &#125; oImg.onmouseout = function ()&#123; timer = setInterval(function()&#123; oImg.src = arr[i++]; i == arr.length &amp;&amp; (i=0); &#125;,1000) &#125; ​ HTML部分： 1&lt;img src="img/1.png" alt="" width="390" height="480"&gt; 2. 页面刷新1.5秒后弹出一个广告，并在右上角加个关闭按钮。要求弹窗展示2秒后自动消失，若在那之前点击了关闭按钮则立即关闭弹窗并停止延时计时器 ​ JS部分： 1234567891011setTimeout(function()&#123; oDiv.style.display = "block"; var timer = setTimeout(hiddenDiv,2000); oSpan.onclick = function () &#123; hiddenDiv(); clearTimeout(timer); &#125;&#125;,1500)function hiddenDiv()&#123; oDiv.style.display = "none";&#125; ​ HTML部分： 123&lt;div&gt; &lt;span&gt;X&lt;/span&gt;&lt;/div&gt; ​ CSS部分： 123456789101112131415161718192021div&#123; width: 300px; height: 200px; background-color: gray; position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125;span&#123; position: absolute; top: 5px; right: 5px; width: 25px; height: 25px; border: 1px red solid; border-radius: 15px; text-align: center; line-height: 25px; cursor: pointer;&#125; 3. QQ显示详细内容效果(显示内容后延迟消失效果)，从展示内容上离开后0.6秒消失 ​ JS部分： 12345678910111213141516aDiv = document.getElementsByTagName("div");var timer = 0;function fn1()&#123; aDiv[0].style.display = "block";&#125;function fn2()&#123; aDiv[0].style.display = "none"; clearTimeout(timer);&#125;aDiv[1].onmouseover = aDiv[0].onmouseover = function ()&#123; clearTimeout(timer); fn1();&#125;aDiv[1].onmouseout = aDiv[0].onmouseout = function ()&#123; timer = setTimeout(fn2,600);&#125; ​ CSS部分： 1234567891011121314151617div:nth-child(1)&#123; width: 200px; height: 200px; background-color: red; position: absolute; top: 0; left: 0; display: none;&#125;div:nth-child(2)&#123; width: 200px; height: 550px; background-color: yellow; position: absolute; top: 0; left: 220px;&#125; ​ HTML部分： 12&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 4. 在页面上布局平铺20个50X50红色的方块，点击我们的浏览器的窗口时让每个方块每隔200毫秒以每30毫秒7像素的速度掉下来一个，直到所有的方块掉到500的位置 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js时间对象和倒计时]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[时间对象 获取当前时间(既计算机读到这句函数时)系统的时间对象 12var myTime = new Date();//objectDate() //直接调用也会返回一个当前时间的字符串(无论传什么参数) 注意：时间对象是对象类型，而获取的时间是数字类型： 12345678910var iYear = myTime.getFullYear(); //获取年var iMonth = myTime.getMonth()+1; //获取月，月份是0-11的数字，需要在结果上+1var iDate = myTime.getDate(); //获取日var iWeek = myTime.getDay(); //获取星期，星期是0-6的数字，需要转换一下显示方式才能用var weeks = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];var sWeek = weeks[iWeek];var iHours = myTime.getHours(); //获取时var iMin = myTime.getMinutes(); //获取分var iSec = myTime.getSeconds(); //获取秒var iMsec = myTime.getMilliseconds(); //获取毫秒 时间对象上还能获取的特殊值string类型，如： 123var sDate = myTime.toLocaleDateString(); //获取年月日(字符串)var sTime = myTime.toLocaleTimeString(); //获取时分秒(字符串)var sAllTime = myTime.toLocaleString(); //获取年月日时分秒(字符串) 但往往上面得到的未必是我们需要的格式，因此一般都是将前面获取的所有数字进行拼接成时间字符串： 1234tFormat(iYear) +'/'+tFormat(iMonth)+'/'+tFormat(iDate)+' '+sWeek+' '+tFormat(iHours)+':'+tFormat(iMin)+':'+tFormat(iSec);function tFormat(n)&#123; return n &lt; 10 ? "0"+n : ""+n; &#125; 注意：通常时间格式使用的数字应该是两位数，因此需要把所有的个位数前面补’0’，我们可以自己封装一个小于10前面加0的函数tFormat 时间戳：是1970日1月1日0时0分0秒到现在的时间的毫秒数，下面三个方法等价： 123new Date().getTime(); new Date().valueOf();Date.now(); //ES5的方法 用途：可以用来判断一段程序运行的时间差，或者每次需要得到一个不同的数字时使用 倒计时 用在团购，抢购等网站，原理是现在的时间点(一直在变)与终点(不会变)两个时间的差就是倒计时(毫秒) 如果在实例化时间对象时给其传参就可以设置一个时间对象，有 如下几种格式： 1234567var iNew = new Date(毫秒数); //将毫秒数的对应时间返回，可以是一个负数，表示1970年1月1日之前的时间。var iNew = new Date('2016-08-01');//假设用户处于格林尼治国际标准时的时区。ES6规定凡是没有指定时区时认为用户处于本地时区。var iNew = new Date(2016,8,1,9,48,12); //数字形式，这里的月也是当前月份-1var iNew = new Date('September 1,2016 9:48:12'); //字符串形式Date.parse('January 26, 2011 13:51:50'); //如果要把一个时间字符串转换成毫秒数需要用Date.parse方法 Date.parse('2011-10-10'); //如果Date.parse解析失败则返回NaNDate.parse('2011-10-10T14:48:00'); 另外一种方式是直接在当前时间对象上设置新时间(该类方法返回的是设置后时间的时间戳)，如： 123456789var iNow = new Date();iNow.setDate(15); //将时间设置为本月15日iNow.setDate(iNow.getDate()+5); //设置日期为当前日期后5天iNow.setFullYear() //设置当前年份(四位数字，月日是可选参数)iNow.setHours() //设置当前小时数(24小时制,0-23)iNow.setMilliseconds() //设置当前毫秒数iNow.setMinutes() //设置当前分钟数iNow.setMonth() //设置当前月份(注意从0开始:0-Jan,1-Feb...)iNow.setSeconds() //设置当前秒数 这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就表示下一年的4月；设置为-2，就表示上一年的11月。 计算时间差，无论用哪种方法设置了未来时间，用未来时间-当前时间就是两者时间差(毫秒)： 123456-- alert( myDate &gt; today ? "今天在2018年9月1日之前" : "今天在2018年9月1日之后" ); //两个时间对象比较大小 var t = (iNew - iNow)/1000; //计算差值，用math.floor向下取整 var iD = Math.floor(t/86400); //毫秒转天 var iH = Math.floor(t%86400/3600); //毫秒转时 var iM = Math.floor(t%3600/60); //毫秒转分 var iS = t%60; //毫秒转秒 倒计时完整思路： 核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时，但是不能拿时分秒相减，比如05分减去25分，结果会是负数 用时间戳来做。剩余时间的毫秒数 = 用户输入时间总的毫秒数 - 现在时间总的毫秒数 把剩余的时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒） 转换公式如下： 1234d = parseInt(总秒数/ 60/60 /24); // 计算天数h = parseInt(总秒数/ 60/60 %24); // 计算小时m = parseInt(总秒数/ 60 %60); // 计算分钟s = parseInt(总秒数 %60); // 计算当前秒 倒计时效果： 12345678910111213141516function countDown(time) &#123; var nowTime = +new Date(); // 返回的是当前时间总的毫秒数 var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数 var times = (inputTime - nowTime) / 1000; // times就是剩余时间总的秒数(/1000表示毫秒转换为秒) var d = parseInt(times/ 60 /60 /24); // 计算天数 // 前面补0 d = d &lt; 10 ? '0' + d : d; var h = parseInt(times/ 60 /60 %24); // 计算小时 h = h &lt; 10 ? '0' + h : h; var m = parseInt(times/ 60 %60); // 计算分钟 m = m &lt; 10 ? '0' + m : m; var s = parseInt(times%60); // 计算秒 s = s &lt; 10 ? '0' + s : s; return (d + "天" + h + "时" + m + "分" + s + "秒");&#125;console.log(countDown("2019-8-23 07:00:00")); 练习： 1. 小明情人节给女朋友做了一段js，并定了饭店，可女朋友没有去，请问原因是什么： 1234var oTime = new Date();if (oTime.getMonth() === 2 &amp;&amp; oTime.getDate() === 14) &#123; alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');&#125; 2. 用任意方法设置一个未来时间：今天五天之后，6小时后 1234var oTime = new Date();oTime.setDate(oTime.getDate()+5);oTime.setHours(oTime.getHours()+6);console.log(oTime); 3. 用计时器把当前时间的时分秒每1秒钟在页面的p标签中展示一次时间格式(xx:xx:xx的格式)，做出一个时钟效果，第一秒页面也要展示一次时间 12345678910111213var oP = document.getElementsByTagName("p")[0];clock();setInterval(clock,1000);function clock ()&#123; var iTime = new Date(); var iHours = iTime.getHours(); //获取时 var iMin = iTime.getMinutes(); //获取分 var iSec = iTime.getSeconds(); //获取秒 oP.innerHTML = add0(iHours) + ":" + add0(iMin) + ":" + add0(iSec);&#125;function add0(num)&#123; return num&lt;10 ? "0"+ num : "" + num;&#125; 4. 设置一个未来时间，做一个秒杀倒计时，而且显示的所有数字和“:”用图片显示 12 5. 倒计时：距离放假还有::* 123456789101112131415161718var oSpan = document.getElementsByTagName("span")[0]; var oTimeNew = new Date(); oTimeNew.setHours(16); oTimeNew.setMinutes(30); oTimeNew.setSeconds(0); clock(); var timer = setInterval(clock,1000); function clock()&#123; var t = (oTimeNew - new Date())/1000; var iH = Math.floor(t%86400/3600); //毫秒转时 var iM = Math.floor(t%3600/60); //毫秒转分 var iS = t%60; //毫秒转秒 --&gt; oSpan.innerHTML = add0(iH) + ":" + add0(iM) + ":" + add0(iS); t == 0 &amp;&amp; clearIntervaltimer(timer); &#125; function add0(num)&#123; return num&lt;10 ? "0"+ num : "" + num; &#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js特殊函数和运算符]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[自执行(立即执行/自调用)函数 自执行函数语法： 12(function ()&#123;…&#125;)();(function ()&#123;…&#125;()) 这两种自执行函数的写法，在函数体后面加括号就能立即调用，这个函数必须是函数表达式，不能是函数声明 自执行函数可以正常传参，第一个括号是形参的位置，第二个括号是实参的位置；它的内部也是域，变量是局部变量，很多框架里使用自执行函数来防止全局变量的污染；我们也可以用自执行函数将循环for中的i锁定在自执行函数内，我们之前则是使用自定义属性来实现类似的效果的 1234 var a = 10; (function (b)&#123; //var b = a = 10; alert(b); &#125;)(a); 数学函数 Math.floor()：向下取整(下舍去) Math.ceil()：向上取整(上进入) Math.round()：四舍五入 Math.abs()：取绝对值 Math.max()：比较(取大) Math.min()：比较(取小) Math.sin()： 正弦函数(参数为弧度) Math.cos()： 余弦函数(参数为弧度) Math.tan()： 正切函数(参数为弧度) Math.PI： 圆周率(无理数pi) Math.sqrt(x)： x的平方根(开方) Math.pow(x,y)： x的y次方(ES7中用x**y表示) Math.random()：0~1的一个随机数，下面是几个随机整数的公式： 123Math.round(Math.random()) //让结果在0和1随机出现Math.round(Math.random()*a) //让结果在0到a的整数中随机Math.round(Math.random()*(a-b)+b) //让结果在b到a的整数中随机 b大a小 Num.toPrecision(x)： 将Num固定为x位数字(小数多余部分会四舍五入，整数多余部分会用科学计数法后四舍五入) Num.toFixed(x)： 将Num的小数部分取x位有效数字(多余部分会四舍五入，不足部分会补0) 高阶函数和递归函数 函数其实都指向某个变量。函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数： 1234function add(x, y, f)&#123; return f(x) + f(y); &#125; //这里的f相当于函数表达式：var f = Math.absadd(-5, 6, Math.abs); //11 （取绝对值） 所谓的递归函数就是在函数体内调用本函数。使用递归函数一定要注意，处理不当就会进入死循环。递归函数只有在特定的情况下使用 ，比如阶乘问题： 12345678function recursion(num)&#123; if (num&lt;=1)&#123; return 1; &#125; else&#123; return num * recursion(num-1); &#125; &#125; 但我们把函数指针改变并修改原指针时会出错，原因是递归调用的时候原指针已改变了。解决办法是在函数内部调用当前函数用arguments.callee代替函数名，callee属性的初始值就是正被执行的 Function 对象。它是 arguments 对象的一个成员，表示对函数对象本身的引用。 但是访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。因此我们在使用递归的时候还是用函数名的写法，同时避免上面例子的写法就可以了 运算符 算术：+(加)、-(减)、*(乘)、/(除)、%(求余) 三元运算：a ? b : c既if/else特殊写法，等同于if ( a ){ b }else( c ) 赋值：=(将=右边的值赋给左边)、+=(将+=左右两边求和后赋给左边)、-=、*=、/=、%=(后面的如同+=) 判断：&lt;、&gt;、&lt;=、&gt;=、==、!=、===、!==，=== 和 !== 只有在相同类型下,才会比较其值，类型不同直接返回布尔值 逻辑：&amp;&amp;——逻辑”与”操作；||——逻辑”或”操作；!——取反操作 a&amp;&amp;b逻辑”与”定义：从左向右读到false就返回(后面数据不会继续判断)，如所有数据都是ture则返回最后一个(因此都为true时返回的是true) a||b逻辑”或”定义：从左向右读到true就返回(后面数据不会继续判断)，如所有数据都是false则返回最后一个(因此都为false返回的是false) 注意：虽然返回结果是根据布尔值决定的，但js的逻辑运算返回的是数据，而不是布尔值，这与其他编程语言不一样(如PHP返回的就永远是布尔值) 运算优先级：()可以让其内部表达式先执行，如算式或逻辑运算等 练习： 1. 封装一个函数，要求参数传入班级人数n，返回值为随机学号(该学号必须为整数且大于等于1，小于等于总人数n) 12345678function fn1(n)&#123; var b = []; for(var i=0;i&lt;n;i++)&#123; b[i] = Math.round(Math.random()*(1-n)+n); &#125; return b;&#125;console.log(fn1(10)); 2. 菲波那切数列：1、1、2、3、5、8、13、21，写一个函数，参数为数列的位数，弹出值？ 123456789function fibonacci(n)&#123;//var n; if(n==1||n==2)&#123; return 1; &#125; else&#123; return fibonacci(n-2)+fibonacci(n-1); &#125;&#125;console.log(fibonacci(8)); //21 3. 以下逻辑计算后，变量a，b，c的值分别为多少： 1234var a = '' || null || 3 || 4; //3var b = 4 &amp;&amp; 5 &amp;&amp; null &amp;&amp; '0'; //nullvar c = 5 &amp;&amp; false || 4 &amp;&amp; null; //nullvar d = 5 &amp;&amp; (false || 4) &amp;&amp; null; //null 4. 做一个按钮切换新闻的效果，每次显示5条(要求设置一个新闻数组，里面有18条新闻) 123456789101112131415161718192021222324var arr = ["新闻1","新闻2","新闻3","新闻4","新闻5","新闻6","新闻7","新闻8","新闻9","新闻10","新闻11","新闻12","新闻13","新闻14","新闻15","新闻16","新闻17","新闻18"];var oDiv = document.getElementsByTagName("div")[0];var oUl = document.getElementsByTagName("ul")[0];var str = "";var aBtn = oDiv.getElementsByTagName("button");for(var i=0;i&lt;Math.ceil(arr.length/5);i++)&#123; str += "&lt;button&gt;第" + (i+1) + "页&lt;/button&gt;";&#125;oDiv.innerHTML = str;for(var i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].index = i; aBtn[i].onclick = function ()&#123; fn1(this.index); &#125;&#125;function fn1(a)&#123; var str = ""; //创建li并且每次显示5条 for(var i=a*5;i&lt;=a*5+4&amp;&amp;i&lt;arr.length;i++)&#123; str += "&lt;li&gt;" + arr[i] + "&lt;/li&gt;"; &#125; oUl.innerHTML = str; &#125;fn1(0); 5. 分别使用三元运算、数学方法和逻辑运算3个方法完成下面问题：封装一个函数，要求参数n小于100时，返回值为n，参数大于等于100时，返回值为100(n为大于0的整数) 123456789function fn1(n)&#123; //三元运算 return n&lt;100 ? n : 100; //数学方法 return Math.min(n,100); //逻辑运算 return n&lt;100 &amp;&amp; n ||100; return n;&#125; 6. 用js创建22个li元素，背景颜色设置为var arr=[“red”,”black”,”blue”,”yellow”,”green”]中的颜色循环，然后为每个li元素再加上鼠标移入时背景变灰，移开时变回去的效果 ​ JS部分： 123456789101112131415161718var arr=["red","black","blue","yellow","green"];var oUl = document.getElementsByTagName("ul")[0];var aLi = oUl.getElementsByTagName("li");var str = "";for(var i=0;i&lt;22;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].index = i; aLi[i].style.backgroundColor = arr[i%5]; aLi[i].onmouseover = function ()&#123; this.style.backgroundColor = "grey"; &#125; aLi[i].onmouseout = function ()&#123; this.style.backgroundColor = arr[this.index%5]; &#125;&#125; ​ HTML部分： 1&lt;ul&gt;&lt;/ul&gt; ​ CSS部分： 1234567891011 ul&#123; margin: 0; padding: 0; list-style: none;&#125;li&#123; width: 100px; height: 100px; float: left; margin: 0 2px 2px 0;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取作用域的数据和闭包]]></title>
    <url>%2F2019%2F07%2F27%2Fjs%E8%8E%B7%E5%8F%96%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 虽然有作用域链让我们在低级域从高级域中拿值，但是两个函数(同级域)或在高级域从低级域拿值却做不到，如： 12345 function fn1()&#123; var a = 'abc'; &#125; //在全局里a找不到fn1();console.log(a); 我们可以用全局变量从低级域中拿值，通过传参到另一个函数内拿值 1234567var b =0;function fn1()&#123; var a = 'abc'; b = a; &#125;fn1();console.log(a); 除此之外还可以用闭包，要理解闭包，首先必须理解js特殊的变量作用域。js语言的特殊之处，就在于通过作用域链函数内部可以直接读取全局变量。另一方面，在函数外部无法读取函数内的局部变量。 用闭包如何从外部读取局部变量，我们可以在函数的内部，再定义一个函数： 12345678function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; f2(); // 999&#125;f1(); f2被包在函数f1内部，f1内的所有局部变量对f2都是可见的。反过来就不行，f2内的局部变量对f1就是不可见了。这就是js特有的”链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量了，如： 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1(); result(); 闭包的概念：上面代码中f2函数被声明在f1函数内(很多书中也管f2叫闭包，其实是一个意思)，就是闭包。 闭包的最大用处有两个： 可以读取函数内部的变量； 让这些变量的值始终保持在内存中，如： 123456789101112131415var nAdd;function f1()&#123; var n=999; nAdd=function()&#123; n+=1; &#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); //n=999nAdd();result(); //n=1000 f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1和它的局部变量也始终在内存中，不会在调用结束后，被垃圾回收机制回收 使用闭包的注意点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除(将闭包内部的变量设置为null，让变量失去引用，会被系统自动回收)。 闭包会导致在父函数外部，能够改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Public Method)，把内部变量当作它的私有属性(private value)，一定要小心，不要随便改变父函数内部变量的值。(这些概念会在后面说明) 练习： 查看下面代码，说出结果： 1234567891011121314151617181920var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123;return this.name;&#125;;//this是window &#125;&#125;;alert(object.getNameFunc()()); //the window 直接调用var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; //this是object &#125;; &#125;&#125;;alert(object.getNameFunc()()); //My Object 对象调用]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数的返回值和arguments对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Carguments%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[函数的创建形式 函数声明：使用function关键字声明一个函数，再指定一个函数名。叫做函数声明： 1function fnName () &#123;…&#125;; 函数表达式：使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式： 1var fnName = function ()&#123;…&#125;; 匿名函数：使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式： 1function ()&#123;…&#125;; 匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等 函数声明和函数表达式的执行顺序： 12fnName();function fnName()&#123; ... &#125; 正常，因为预解析’提升’了函数声明的函数，函数可在函数声明之前调用 12fnName();var fnName=function ()&#123; ... &#125; 报错，变量fnName预解析时被初始化为undefined，还未保存对函数的引用，因此函数表达式的函数必须在函数表达式赋值之后调用 函数的返回值 函数内return关键字后面的值就是返回值，用函数名()就可以得到函数的返回值，如： 1234function fn1()&#123; return 100;&#125;alert(fn1()); //弹出100 return关键字后面的值可以是任何数据类型：字符串、数字、布尔值、函数、对象([]/{}/null)、未定义，用typeof(fn1());就可以判断返回值的类型 返回函数时，实际上就是返回了该函数的引用，再加上()就可以调用这个函数了(因此下面fn2()相当于返回值函数的函数名)，如： 123456function fn2()&#123; return function()&#123; alert(1); &#125;&#125;fn2()(); //前面fn2()是fn2的返回值，后面的()代表调用该返回值 注意：这种定义到另一个函数内部的函数并返回其实就是闭包 也可以给上面两个函数分别传参，如： 123456function fn2(a)&#123; return function(b)&#123; alert( a + b ); &#125;&#125;fn2(20)(10); //a和b应该分别对应什么 利用传参和返回值可以封装很多效果，如jq里面的$就是用这种方式来实现的，我们也可以这样累积出来一个js库，反复使用 返回值需要注意的事项： 只有函数代码块里才可以用return，如果一个函数没有return或return后无返回值，则会返回一个未定义 return返回值之后的任何代码都不会执行 arguments（实参的集合） 当函数没有设置形参时，但调用的时候却传了实参，那么实参依然会被传入函数，但是没有形参，于是被保存在了arguments(实参的集合，也是类数组的一种)里，可以对其使用.length、[]等 当函数的参数数量不确定的时候，就非常适合使用arguments arguments.length是函数实参的数量，而函数名的长度(fn1.length)则是形参的数量 arguments与形参同值：当你设置了形参，并改变了该形参的值，那么该形参对应的arguments的值也同时发生变化；反之你修改了arguments的值，那么该值对应的形参也会发生变化 1234567function fn1(a,b)&#123; a = 10; console.log(arguments[0]); //输出10 arguments[1] = 20; console.log(b); //输出20&#125;fn1(1,2); 练习： 1. 封装函数，数字参数n，每次调用时返回一个1到n的数组 12345678function fn1(n)&#123; var arr = []; for(var i=0;i&lt;n;i++)&#123; arr.push(i+1); &#125; return arr;&#125;console.log(fn1(6));//[1,2,3,4,5,6] 2. 封装函数，传两个数字参数a和b，每次调用时返回一个从小到大的数组 1234function fn1(a,b)&#123; return a&lt;b ? [a,b] : [b,a];&#125;console.log("按从小到大排序结果为：" + fn1(-3,-5));//返回[-5,-3] 3. 封装函数，要求：参数的数量任意，简单的加减法计算器，要求：最后一个参数为”+”或”-“，返回第一个参数与后面参数依次加法或者减法的结果 1234567891011121314151617function fn1(a)&#123; var iNum = arguments[1]; switch(a)&#123; case "+": for(var i=2;i&lt;arguments.length;i++)&#123; iNum += arguments[i]; &#125; break; case "-": for(var i=2;i&lt;arguments.length;i++)&#123; iNum -= arguments[i]; &#125; &#125; return iNum; &#125; console.log(fn1("+",3,4,5,6)); console.log(fn1("-",20,6,3));]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数的参数和作用域]]></title>
    <url>%2F2019%2F07%2F26%2Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[函数的参数 函数在声明和调用时，有个小括号，这里就是放置参数的地方： 1234function fn1(a)&#123; //相当于在函数的内部 var a alert(a);&#125;; fn1(100); //函数调用的时候为a赋值 a = 100 注意：函数声明时的a叫做形参：形式上的参数，用一个变量代表值的参数，只会出现在函数声明的时候；函数调用里的100叫做实参，给函数实际传递的参数值，只会出现在函数被调用的时候 因为形参相当于变量，因而实参可以存任何数据类型：数字、字符串、布尔值、函数、对象、未定义等；参数可以有多个，参数之间用”,”分割，如： 1234fn1(100,"px"); function fn1(a,b)&#123; alert(a+b); &#125; 函数的封装：由顺序、选择和循环三种基本结构组成，功能相对独立的一个模块，如下，根据参数的类型函数会执行不同的操作 1234567891011121314var m = 100;//数字var n = "num";//字符串var c = function ()&#123;console.log(1);&#125;//函数function fn1(a)&#123; switch(typeof(a))&#123; case 'number': alert(a+20); break; case 'string': alert(a.charAt(2)); break; case 'function': a();//调用函数 default: console.log(a); &#125; &#125;fn1(m);//函数调用fn1(n);fn1(c); 函数的封装的注意事项： 尽量保证HTML代码结构一致(否则很难重用代码) 需要把核心程序实现，再用函数包裹起来 把每组中不同的值找出来，通过传参分别实现效果 运算符号是不能作为参数传递的，只能在函数内部通过判断的方式来分别执行 作用域 域：空间、范围、区域。如：js必须放在script里，css放在style里，它的作用就是(在一个范围内)读和写 浏览器有读js的解析器，当进入script标签后： 第1步–预解析：找到全局的var和function(变量提升)，先检查function函数名和内容并储存，当发现重名时，后面的函数覆盖前面的函数；再检查var的变量储存并初始化值undefind，但是发现重名时会跳过储存(不管重复的是变量名还是函数名) 第2步–逐行读代码：变量被赋值之前的值是初始化时的undefind，直到读到=、+、-、*、/、%、++、–、！等表达式才会获得新值，而读到函数声明时则什么都不会做，直到函数被调用才会执行其内容代码 看一个例子，并分别分析下面代码中的alert(a)都弹出什么： 12345678910111213alert(a); //1、第一次弹出a，再声明变量a 弹出function a()&#123; alert(4); &#125;var a = 1;alert(a); //2、第一次弹出a，再为a赋值 弹出1a = 1;alert(a); //3、多次弹出a，再中间多次声明变量和函数a var a=1;alert(a); //1function a()&#123; alert(2); &#125;alert(a); //1var a = 3;alert(a); //3function a()&#123; alert(4); &#125;alert(a); //3 注意：没有var的写法只存在于面试中，我们写的代码中不允许出现 在script标签里定义的变量是全局变量和函数，若写有两个script标签则是2个域，每个域的解析独立进行：上面script标签输出不了下面script声明的变量；下面script标签可以输出上面script声明的变量 另外一个函数的内部也是一个域，因此函数被调用时也会第一时间开始域解析，函数内部的变量是局部变量，该变量会在函数调用结束时销毁。注意：函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。 作用域链：在一个域内没有找到某变量时，会由里到外，自上到下去更高级的域中去寻找，继续分析下面代码： 12345678910111213141516var a=1; //1、函数内外都声明有a变量function fn1()&#123; alert(a); var a = 2; &#125;fn1();alert(a);var a=1; //2、全局声明a变量，函数未声明a变量function fn1()&#123; alert(a); a = 2; &#125;fn1();alert(a);var a=1; //3、全局声明a变量，函数有a形参function fn1(a)&#123; alert(a); a = 2; &#125; fn1();alert(a);var a=1; //4、全局声明a变量，函数未声明a变量，调用有a实参function fn1()&#123; alert(a); a = 2; &#125;fn1(a);alert(a); 注意：if(){}和for(){}的花括号不是域；匿名函数的{}里是一个域；当js出现错误的时候，如果不是代码写错了，那就是代码的解析机制想错了 练习： 1. 封装一个函数，3个参数（a , b , c），如果参数a的结果为”+”，则输出b和c的和；如果参数a的结果为”-“，则输出b和c的差 1234567function fn1(a,b,c)&#123; switch(a)&#123; case "+": console.log(b+c);break; case "-": console.log(b-c);break; &#125;&#125;fn1("+",5,10); 做一个根据图片数量生成对应数量按钮，并通过点击按钮控制图片的切换，用传参的方式封装函数，要求并在页面中设置两个图片切换，区别1图片数量不同，区别2切换的方式不同(一个hover效果，一个click效果)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-十一、使用Apache部署静态网站]]></title>
    <url>%2F2019%2F07%2F23%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%8D%81%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8Apache%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[十一、使用Apache部署静态网站 web网站服务又称为www服务（world wide web） web服务原理：是一种被动服务，只有接收了互联网中其他计算机发出的请求后才会响应，然后web服务器才会使用HTTP（超文本传输协议）或HTTPS（超文本安全传输协议）将指定文件传送到客户机的浏览器上解析后成为网页 常见的web服务程序 (1) IIS7：Internet information services 7，是Windows系统中默认web服务程序，第一款图形化的网站管理工具 (2) Apache：是一种跨平台的安全性广泛被认可的且拥有快速、可靠、简单的API扩展的web部署软件，是一种常用的web服务软件 (3) Nginx：是一款轻量级的网站服务软件，性能稳定、功能丰富，系统资源占用率低、内存占用少且并发能力强 网站组成 (1) 页面源程序：又称为web页，通过网页编写软件编写的网页源文件，HTML，css，脚本等 (2) 主机空间：用于存放网页源代码并能够将网页内容展示给用户 ​ A. 虚拟主机：在一台服务器中分出一定的磁盘空间供用户放置网站、存放数据等，仅提供基础的网站访问等简单功能，成本较低，节省维护时间，降低运维费用，适用于小型企业 ​ B. VPS：在一台服务器中虚拟出多个“逻辑计算机设备”，每一个用户面对的都是一台“独立”服务器，可以安装操作系统，部署功能服务软件，适用于小型企业 ​ C. 云服务器（ECS）：整合硬件、计算、存储、网络、服务等功能，能够弹性的进行计算服务，使用时同VPS，区别ECS是建立在一个大型计算机集群基础之上，每个服务器都有镜像，保证安全性，用户只需按量付费 ​ D. 独立服务器：租赁服务器，托管服务器，自行购买维护服务器 ​ (a) 塔式服务器 ​ (b) 机架式服务器：U：是一种表示机架式服务器外部尺寸的单位，是unit的缩略语，厚度以4.445cm为基本单位，1U就是4.445cm，2U则是1U的2倍为8.89cm (3) 域名及域名解析 安装Apache服务器程序 (1) 注意：Apache为服务名称，其软件名称为httpd (2) 过程： ​ A. 搭建DVD光盘yum仓库 ​ (a) mount /dev/sr0 /media ​ (若找不到媒体，在虚拟机右下角点击光盘图标单右后点击连接) ​ (b) cd /etc ​ mv yum.repos.d yum.repos.d.back ​ mkdir yum.repos.d ​ cd yum.repos.d ​ (c) vim DVD.repo 输入以下内容： ​ [DVD] ​ baseurl=file:///media ​ enabled=1 ​ gpgcheck=0 ​ (d) yum makecache ​ B. 安装httpd服务程序：yum install -y httpd ​ C. 启动httpd服务程序：systemctl start httpd ​ D. 开机启动httpd服务程序：systemctl enable httpd ​ E. 检测httpd安装是否成功：点击Linux浏览器，地址栏中输入127.0.0.1 httpd服务程序的配置 (1) 配置目录 ​ A. 服务目录：/etc/httpd ​ B. 配置文件：/etc/httpd/conf/httpd.conf ​ C. 网站数据：/var/www/html ​ D. 访问日志：/var/log/httpd/access.log ​ E. 错误日志：/var/log/httpd/error_log (2) 主配置文件分析 ​ A. 路径：/etc/httpd/conf/httpd.conf ​ B. 打开方式：vim /etc/httpd/conf/httpd.conf ​ C. 结构分析： ​ (a) 注释行：#开头，起到声明的作用 ​ (b) 全局配置：对所有网页程序都生效 ​ (c) 局部配置：以&lt;&gt;作为定界符，只在局部网页或功能下生效 ​ D. 主要参数： ​ (a) ServerRoot ：服务目录 ​ (b) ServerAdmin：管理员邮箱 ​ (c) User：运行服务的用户 ​ (d) Group：运行服务的工作组 ​ (e) ServerName：网站服务器的域名 ​ (f) DocumentRoot：网站数据目录 ​ (g) Listen：监听的IP地址与端口号（80） ​ (h) DirectoryIndex：默认的索引页页面 ​ (i) ErrorLog：错误日志文件 ​ (j) CustomLog：访问日志文件 ​ (k) Timeout：网页超时时间，默认为300秒 ​ (l) Include：需要加载的其他文件 (3) 部署个人网站 ​ A. 放置个人网页 ​ (a) 在/下建立目录：mkdir /web1 ​ (b) 在图形化界面中将Windows的web页复制粘贴到Linux的/web1目录中 ​ B. 修改http配置文件的网页默认存储目录 ​ (a) vim /etc/httpd/conf/httpd.conf ​ (b) 定位第119行，将DocumentRoot &quot;/var/www/html&quot;中的&quot;/var/www/html&quot;改为&quot;/web1&quot; ​ (c) 定位第124行&lt;Directory &quot;var/www&quot;&gt;中的&quot;var/www&quot;改为&quot;/web1&quot; ​ (d) 保存退出 ​ (e) 重启httpd服务：systemctl restart httpd ​ C. 关闭防火墙：systemctl stop filewalld ​ D. 关闭SELinux ​ (a) SELinux：Security-Enhanced Linux，美国国际安全局在Linux社区帮助下开发的一个“强制访问控制的安全子系统”，用于让系统中的各个服务进程都收到约束，即仅能访问到所需要的文件 ​ (b) 常用命令： ​ ◆ 查询当前SELinux状态：getenforce ​ ◆ 模式一：Enforcing ， 安全策略强制启用模式，将会拦截服务的不合法请求 ​ ◆ 模式二：Permissive ， 遇到服务越权访问只会发出警告而不强制拦截 ​ ◆ 模式三：Disabled ， 对于越权的行为不警告，也不拦截 ​ ◆ 关闭SELinux：setenforce 0 ​ E. 输入ip addr查看本机IP，通过IP地址在浏览器中查看网页 (4) 设置手动强制域名解析 ​ A. 在Windows中定位文件：C:\Windows\System32\drivers\etc\hosts ​ B. 点击hosts文件后单击右键以记事本打开 ​ C. 在最后一行添加一行记录： ​ (a) 格式：IP 域名 ​ (b) 例：192.168.122.1 www.ylx.com ​ (c) 保存退出 ​ D. 在Windows中打开浏览器输入上述域名也可访问网站 ​ E. 注意：以上方法仅限于实验，实际工作中需要购买DNS域名解析服务及域名]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-十、操作系统基础知识]]></title>
    <url>%2F2019%2F07%2F23%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%8D%81%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[十、操作系统基础知识 概念：管理计算机软硬件资源，提供系统设备接口及工作界面 (1) 管理者作用 ​ A. 管理硬件资源 ​ (a) 管理CPU运算时间 ​ (b) 管理内存的存储空间 ​ B. 提供使用方法 ​ (a) 工作界面：图形化界面（GUI）、命令行界面（CLI） ​ (b) 提供接口 ​ ◆ 软件接口：API ​ ◆ 硬件接口 操作系统功能 (1) 进程管理：管理CPU运行时间（轮转、同步、死锁等） (2) 内存管理：管理内存存储空间（申请、释放、扩展、安全等） (3) 设备管理：管理除了CPU、内存之外的所有设备（磁盘等） (4) 文件管理：文件系统（FAT32 NTFS） (5) 用户界面管理：提供shell界面及方式 (6) 网络管理：网络创建、地址规划、连接等 Linux系统架构 (1) 组成：硬件、内核、系统调用、应用程序（从外到内） (2) 图： (3) kernel结构： ​ A. 图： ​ ​ B. system call interface（SCI）：系统调用接口，由一系列的预先编写好的函数库构成，系统调用把应用程序的请求传给内核调用相应的内核函数完成所需的处理，将处理结果返回给应用程序 ​ C. PM ：进程管理，创建销毁进程，管理进程的执行 ​ D. MM ：内存管理，管理内存空间的申请、回收等功能，并完成地址映射转换 ​ E. VFS ：虚拟文件系统，位于应用程序与实际多种文件系统之间，为文件系统提供了一个通用的接口抽象，如图： ​ ​ ​ F. NS ：网络堆栈，遵循模TCP/IP本身的分层体系结构，提供和管理网络连接，提供对多种网络通信标准的访问并支持许多网络硬件 ​ G. DD ：硬件设备驱动，提供大量预制设备驱动程序，识别管理外部硬件设备 Linux系统的基本组成 (1) 组成：内核 + 根文件系统 (2) 内核：是Linux的整个核心，确切的说内核即是Linux，其他程序都是通过调度内核来实现其功能 (3) 根文件系统：根目录及文件系统 Linux系统启动流程 (1) 系统自检 ​ A. 作用：当按下开机键后，立刻加电，自检程序会检查硬件设备的状态是否正常，重点检查CPU及内存 ​ B. 自检失败：内存损坏、接触不良，键盘未安装，CPU异常 (2) 加载主引导记录 ​ A. 确定引导设备：硬盘、光盘、U盘、网络 ​ B. 从引导介质中加载引导程序 ​ C. 使用Bootloader（引导加载器）进行引导 (3) 加载内核 (4) 加载根文件系统 (5) 启动初始化进程及后续服务 ​ A. 内核文件加载以后，就开始运行第一个程序systemd，它的作用是初始化系统环境，由于systemd是第一个运行的程序，它的进程编号（pid）就是1，其他所有进程都从它衍生，都是它的子进程 ​ B. 配置文件：/usr/lib/systemd/system ​ /etc/systemd/system (6) 加载终端：6个终端 ​ A. 1个GUI，5个tty ​ B. 6个tty (7) 开始登录 ​ A. 图形化界面登录 ​ B. 命令行登录界面 ​ C. 远程登录 (8) 加载环境变量 (9) 显示命令提示符，等待用户输入命令 网络基本概念 (1) 概念：以资源共享为根本目的，遵循相同通信协议，以大量自治计算机组成的资源集合 (2) 组成： ​ A. 广域网（WAN）：直径大于50KM以上的远程网络 ​ B. 城域网（MAN）：使用双环型结构的作用于一个城市的网络集合 ​ C. 局域网（LAN）：直径小于5km以内的网络，易于创建、修改、扩展 (3) TCP/IP协议： ​ A. 网络模型：四层 ​ B. 结构： 应用层 4 传输层 3 互联层 2 物理层 1 ​ C. 作用： ​ (a) 应用层：创建网络连接，管理连接，相应用户的网络服务（软件） ​ (b) 传输层：使用TCP或UDP传输报文（传输方式） ​ (c) 互联层：使用IP地址进行路由转发，路由选择（传输设备） ​ (d) 物理层：使用二进制透明传输比特流（传输介质） (4) IP地址：（IDDR） ​ A. 作用：用于互联网上表示唯一的连接 ​ B. 注意： ​ (a) 一个IP地址只能表示一个主机位置 ​ (b) 一个主机可以拥有多个IP地址 ​ C. 组成： ​ (a) 32位二进制组成，点分十进制表示 ​ (b) 例：二进制形态： 1100 0000 1010 1000 0000 0001 0000 0001 ​ 点分十进制形态：192.168.1.1 ​ (c) IP地址=网络号+主机号，上例中192.168.1为网络号，主机号为1 ​ D. 分类： ​ (a) 原则：将IP的网络：主机号字段按照1:3、2:2、3:1的方式划分成以下五种类别的IP地址 ​ (b) 类别： 名称 第一字节范围 NET:HOST 主机数 应用 A类 1-126 1:3 16777214 大型网络 B类 128-191 2:2 65534 中型网络 C类 192-223 3:1 254 小型网络 D类 留 作 它 用 E类 留 作 它 用 ​ E. 实际LAN的IP地址规划 ​ (a) 常见Router的IP地址：192.168.1.1或192.168.0.1 ​ (b) IP地址处于同一网络互通原则：网络号必须相同 ​ (c) 实际主机IP地址范围：192.168.1.2–192.168.1.254 ​ (d) 习惯客户机升序设置IP，服务器倒序设置IP ​ (5) 子网掩码：（NETMASK） ​ A. 组成：32位二进制，点分十进制表示，由左向右为连续1，再是连续0，如：255.255.255.0拆分为二进制：1111 1111 1111 1111 1111 1111 0000 0000（1和0不能交叉） ​ B. 作用：子网掩码中数字1对应的IP地址数字表示网络号，数字0对应的IP地址数字表示主机号 ​ C. 网络地址： ​ (a) 组成：网络号+0 ​ (b) 例：192.168.1.0 10.0.0.0 ​ (c) 作用：表示该网络的名称，用于区分网络，IP地址的网络地址不同不能通信 ​ (d) 计算IP地址的网络地址：IP地址与子网掩码二进制状态下按位相与，如：192.168.10.1 &amp;255.255.255.0结果为192.168.10.0（1&amp;任意数=任意数本身） ​ D. ==标准子网掩码：== ​ (a) A类：255.0.0.0 /8 ​ (b) B类：255.255.0.0 /16 ​ (c) C类：255.255.255.0 /24（一个255是8个1，一共24个1） ​ E. ==子网掩码简略写法：== ​ (a) 格式：/数字 ​ (b) 数字：子网掩码中二进制状态下由左向右连续1的个数，共32位，剩余补0 ​ (c) 例：192.168.10.129/24 ​ ◆ IP地址：192.168.10.129 ​ ◆ 子网掩码：255.255.255.0 ​ (6) 网关地址（GATEWAY）：一般为路由器或服务器的地址 ​ (7) 域名解析： ​ A. 原因：计算机设备只识别IP地址，不识别域名网址，对于使用者由于域名网址便于使用和记忆则愿意使用域名网址 ​ B. 作用：在互联网中存在着一种既独立又协作的域名解析服务器来完成域名与IP的相互转换映射 ​ C. 分类： ​ (a) 正向解析：域名-&gt;IP ​ (b) 反向解析：IP-&gt;域名 ​ D. 常见的域名解析服务器地址： ​ (a) 默认：路由IP地址（192.168.1.1） ​ (b) 8.8.8.8 （Google公司） ​ (c) 114.114.114.114 （工信部） HTTP协议 (1) 超文本传输控制协议 (2) 作用：传输web页 (3) 端口：80 (4) 架构：客户机/服务器（C/S） (5) URL：统一资源定位符格式，用于表示网址 ​ A. 例：HTTP://www.baidu.com/index.html ​ B. 结构：协议名://域名/文件名]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-九、软件下载及安装]]></title>
    <url>%2F2019%2F07%2F22%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B9%9D%E3%80%81%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[九、软件下载及安装 安装方式 (1) 原码安装 ​ A. 原理：软件编写者或厂商编写放出的原始代码文本文件 ​ B. 方式：解压缩Tarball文件，并且安装前需要进行检测操作系统、设定编辑环境参数、编译、设置等工作再进行安装 ​ C. 特点：软件安装自由，可以制定相关功能，但操作量大，麻烦，对安装人员的技术要求较高 (2) RPM安装 ​ A. RPM ：Red Hat Package Manager （红帽软件管理器） ​ B. 原理：软件发布者在他自己的系统中编译好用户所需的软件，再进行发布交由用户使用，由于软件制作者使用的硬件和使用者是一样的，则省略的原码的相关步骤 ​ C. 特点：简化安装步骤，但必须设置好软件安装的依赖性 (3) YUM安装 ​ A. 原理：将RPM安装的软件及依赖软件的相关信息组成数据库存储在网络服务器中，用户安装软件时会首先查询该服务器的数据库，将安装软件及依赖软件一同打包下载 ​ B. 特点：软件安装简单，但无法自定义软件 RPM软件安装 (1) 过程 ​ A. 读取RPM包头中的数据，进行查询软件依赖性 ​ B. 依赖性若满足则安装软件 ​ C. 若不满足则安装失败 (2) 要求 ​ A. 软件编译打包的环境必须与用户使用的环境相同 ​ B. 软件安装依赖性必须满足 ​ C. 卸载软件时最底层软件不能先卸载，否则系统会出错 (3) RPM文件 ​ A. RPM文件：扩展名为*.rpm，已经编译可以直接安装，但不能修改其中参数，不能重新编译 ​ B. SRPM文件：扩展名为*.src.rpm，未编译的原码文件，不可以直接执行，但可以根据当前环境和需求进行参数修改 ​ C. RPM软件包的名称解释 ​ (a) 例：python-iniparse -0.4 -9 .el7.x86_64.rpm ​ (b) python-iniparse ：软件名称 ​ (c) -0.4 ：版本号 ​ (d) -9 ：编译次数 ​ (e) .el7.x86_64.rpm ：适用的平台 ​ (f) 注意： ​ ◆ x86_64 ：64位平台 ​ ◆ i386 ：32位平台 ​ ◆ noarch ：通用平台，64位及32位都可使用 (4) RPM软件安装命令 ​ A. 格式：rpm -参数 软件名称.rpm ​ B. 参数： ​ (a) -i ：安装软件 ​ (b) -v ：查看安装信息 ​ (c) -h ：显示安装进度 ​ (d) –nodeps ：发生安装依赖时，强制安装，但可能安装后的软件无法使用 ​ (e) –force ：安装时提示已安装，则覆盖安装 ​ (f) -q ：查询软件是否安装 ​ C. 例：手动安装gcc软件：（非常麻烦） ​ (a) 新建待安装软件包目录：mkdir ~/gcc ​ (b) 挂载光盘：mount /dev/sr0 /media ​ (c) 进入软件包目录：cd /media/Packages ​ (d) 拷贝7个依赖软件： 1234567cp mpfr-3.1.1-4.el7.x86_64.rpm ~/gcccp libmpc-1.0.1-3.el7.x86_64.rpm ~/gcccp kernel-headers-3.10.0-693.el7.x86_64.rpm ~/gcccp glibc-headers-2.17-196.el7.x86_64.rpm ~/gcccp glibc-devel-2.17-196.el7.x86_64.rpm ~/gcccp cpp-4.8.5-16.el7.x86_64.rpm ~/gcccp gcc-4.8.5-16.el7.x86_64.rpm ~/gcc ​ (e) cd ~/gcc ​ (f) 按下列顺序安装软件： 1234567rpm -ivh mpfr-3.1.1-4.el7.x86_64.rpmrpm -ivh libmpc-1.0.1-3.el7.x86_64.rpmrpm -ivh kernel-headers-3.10.0-693.el7.x86_64.rpmrpm -ivh glibc-headers-2.17-196.el7.x86_64.rpmrpm -ivh glibc-devel-2.17-196.el7.x86_64.rpmrpm -ivh cpp-4.8.5-16.el7.x86_64.rpmrpm -ivh gcc-4.8.5-16.el7.x86_64.rpm ​ (g) 检测gcc ：rpm -q gcc (5) RPM软件卸载 ​ A. 格式：rpm -e 软件名.rpm ​ B. 注意： ​ (a) 软件安装时有依赖性，卸载时依然有依赖性，应从最上层软件开始卸载，否则会出现问题 ​ (b) 若强行卸载则会破坏rpm的软件数据库，从而导致系统异常 ​ (c) 修复rpm数据库的方式：rpm --rebuilddb YUM软件安装 (1) YUM原理：Linux系统将软件编译好之后放到服务器中，并将该软件的依赖关系记录成表格也存储到服务器中，用户下载软件时会将该软件的信息下载到本地并与RPM数据库作比对，分析依赖软件的状态，一次性打包下载所有软件 (2) YUM仓库：记录软件依赖性等信息的数据库 (3) YUM常用命令： ​ A. 浏览： ​ (a) yum repolist all ：列出所有yum软件仓库 ​ (b) yum list all ：列出仓库中所有软件包 ​ (c) yum info 软件包名称 ：，列出软件包安装信息 ​ B. 安装： ​ (a) yum install 软件包名 ：安装软件包 ​ (b) yum install -y 软件包名 ：安装并确认 ​ ◆ yum install java ​ ◆ yum install -y python ​ C. 更新： ​ (a) yum update ：升级所有软件 ​ (b) yum update 软件包名 ：升级更新指定软件 ​ (c) 例：yum update kernel ​ yum update bash ​ D. 卸载：yum remove 软件包名 ​ E. *yum命令安装下载RPM包： ​ (a) 格式1：yum install 软件包名.rpm ​ (b) 格式2：yum installl URL/软件包名.rpm ​ 安装wps Linux版： ​ 网址：https://wdl1.cache.wps.cn/wps/download/ep/Linux2019/8722/wps-office-11.1.0.8722-1.x86_64.rpm ​ yum install https://wdl1.cache.wps.cn/wps/download/ep/Linux2019/8722/wps-office-11.1.0.8722-1.x86_64.rpm (4) YUM安装软件包组： ​ A. 命令格式： ​ (a) yum grouplist ：列出所有可以使用的包组 ​ (b) yum grouplist 包组名 ：列出软件包组的软件信息 ​ (c) yum groupinstall 包组名 ：安装软件包组 ​ (d) yum groupremove 包组名 ：卸载软件包组 ​ B. 意义：安装大型项目时，所需的软件很多，此时通过单个软件安装非常麻烦，如：GNOME x-WINDOWS等大型软件，可以通过软件包组进行安装 ​ C. 安装图形化界面 ​ (a) 查询：yum grouplist ​ (b) 安装：yum groupinstall GNOME Desktop ​ (c) 启动：startx (5) yum配置文件分析： ​ A. 路径：/etc/repos.d/CentOS-Base.repo ​ B. 分析： ​ (a) [base] ：表示yum软件库的名称，[]不能省略，内容任意，但不能相同 ​ (b) name ：描述软件库意义，可省略 ​ (c) mirrorlist= ：映射方式，可省略 ​ (d) baseurl = ：表示软件库的域名网址，非常重要！ ​ (e) enable=1 ：启用该库，enable=0 ：不启用 ​ (f) gpgcheck=1 ：检查软件的数字签名，gpgcheck=0 ：不检查 ​ (g) gpgkey= ：检查数字签名时所需的公钥文件位置，不检查数字签名时，可省略 ​ (h)注意：其他库如：升级库（update）、附加库（extras）意义同此库（base） ​ C. 利用本地光盘镜像搭建yum仓库：（断网可用） ​ (a) 挂载本地光盘：mount /dev/sr0 /media ​ (b) 清空yum缓存：yum clean all ​ (c) cd /etc ​ (d) 备份原有配置文件目录：mv yum.repos.d yum.repos.d.back ​ (e) 新建配置文件目录：mkdir yum.repos.d ​ (f) cd yum.repos.d ​ (g) 新建yum配置文件：vim DVD.repo 输入以下内容： ​ [DVD] ​ baseurl=file:///media ​ enabled=1 ​ gpgcheck=0 ​ 保存退出 ​ (h) 新建yum缓存：yum makecache ​ (i) 查看是否启用：yum repolist all ​ (j) 尝试下载安装软件：yum install tftp ​]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js布尔值和自定义属性]]></title>
    <url>%2F2019%2F07%2F21%2Fjs%E5%B8%83%E5%B0%94%E5%80%BC%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据类型转换 布尔值类型: Boolean(value)把值转换成Boolean型 Boolean方法和之前的Number方法和String方法进行数值类型转换时，都将创建一个新值，存放由原始值直接转换成的值。 在进行比较时，也会得到一个布尔值，如&gt;、&lt;、或都会让字符串和数字的比较结果正确显示，但两个字符串不行(因为字符串是没有固定大小的原始类型)，如：’10’&gt;9和’10’&gt;’9’，前者为true后者为false，字符串之间的比较是从左向右一位一位的比较unicode编码大小 !取反，布尔值的隐形转换方法，取反之前若转换布尔值为真，则取反后的结果一定是布尔值且为假 ==如果两边数值相同(即使不同类型，如：’2’和2(，就相等，在判断前将两边转换成了数字 ===会判断类型，类型不同即使数值相同也返回false 布尔值转换规则： 数据类型–数字：除了NaN和0都是真 数据类型–字符串：所有非空字符串都是真 数据类型–布尔值：true和false 数据类型–对象(函数)：true 数据类型–对象(element)：能找到的就是true，找不到的是false(找不到的就是null)； 数据类型–对象([]和{})：true 数据类型–对象(null) ：false 数据类型–未定义(undefined)：false 比较：比较会在判断前==将两边转换成数字==然后比较其值，但是有几种情况比较特殊 如果两边有null和undefined时，不会发生转换数字的，因此null和undefined只与自己和对方相等 由于字符串没有固定大小，因此转数字会变成NaN，所以它也不会发生数字类型转换，而是从左向右一位一位的比较unicode编码大小 由于对象转换数字也是NaN，因此如果两边都为对象的时候也不会发生数字类型转换，而是按照对象在内存中的地址比较，地址相同即相等，否则不等 数据类型转换的注意事项： 不要用new Number()/Boolean()/String()等构造函数实例化的方式去创建包装对象，因为这样创建出来的是object类型 判断Array（数组是数组）使用Array.isArray(arr) 判断null请使用myVar === null number对象(非变量(调用toString()报SyntaxError： 1234123.toString(); // 报SyntaxError//遇到这种情况，要特殊处理一下：123..toString(); // '123', 注意是两个点！(123).toString(); // '123' 自定义属性 人为给元素上定义本来不存在的属性就是自定义属性，自定义属性一般根据语义去取名，语法： 1元素.自定义属性 = 123; 注意：自定义属性的操作如同原本属性一样 可以为元素添加任意数量的自定义属性，它是js向html添加值的方式之一 使用范例：索引值 123for(var i=0;i&lt;n;i++)&#123; 元素[i].index = i; //为每一个对象建立"匹配"/"对应"关系&#125; 注意：后面循环几乎都会用到索引值 循环中的问题，如果在循环时绑定事件函数，循环是在页面刷新时执行的，而函数执行时循环已经结束，这时i的值已经变成最后一个数字，在函数内使用就是出现问题。 解决方法就是使用自定义属性，将i的值在循环时保存下来，在函数内部需要的时候使用该自定义属性 练习： 1. 如何让’10’&gt;’9’正确的比较出大小，试着用多种方法来实现 看下面代码说出结果： 12345console.log(2==true);console.log(null==0);console.log("123"=="0123");console.log([]==[]);console.log([]==![]); 2. 做3个按钮，起始value为0，每次点击时对应按钮的value值+1 3. 在上题的基础上增加一个数组[“A”,”B”,”C”,”D”]，要求每个按钮在点击时，让其value值显示为数组数据的循环(A-&gt;B-&gt;C-&gt;D-&gt;A循环) 4. 在点击按钮(3个)时用索引值把arr(3个)里的数据输入到p(3个)标签里 5. 写一个img标签并将其图片信息和图片数量等进行布局；按照图片数量动态生成按钮，并写个数组保存图片信息；设置active的样式为红色背景白色字体，第一个按钮的class=”active”，并在点击其他按钮时切换active；尽量使用函数去把代码合并，并在点击按钮时用索引值的一一对应来做当图片切换时同步切换图片信息和图片的数量]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（转）Markdown语法]]></title>
    <url>%2F2019%2F07%2F20%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文转自：简书作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed一、标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字 这是倾斜的文字 这是斜体加粗的文字 这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十、流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ```]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型详解和数据类型转换]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据类型详解 未定义：undefined，如 var n ; 就是一种状态，通常指出错了，出现的情况： 当变量定义但未赋值时，该变量的值被格式化为undefined； 对一个没有声明的变量调用typeof时，返回值也是undefined； 当函数无明确返回值时，返回值也是undefiend 空对象：null，如 var n = null; 不存在的object，通常是人为设置的空 虽然null判断类型为对象，但是它不能添加自定义属性 表示尚未存在的对象，如果函数要返回对象，那么找不到该对象时，返回的值通常是null 字符串类型：string，如 var s =&quot;nihao&quot;; 由零或多个 16位 Unicode 字符组成的字符序列 string是唯一没有固定大小的原始类型，字符串的字面量声明可以由双引号””或单引号’’组成 length属性：输出字符串的长度，空格也算长度 charAt()方法：输出()里下标处的字符（在最新的js版本中支持使用数组的[]来获取下标处的字符，s[i]） 布尔值：boolean，如 var b = true; 只有true和false两个值。在if判断的条件和for循环的两个;之间都是布尔值，这些需要布尔值的地方会自动被转换 数字类型：number，如 var i = 100; 不区分整形和浮点，number可以表示32位的整数，也可以表示64位的浮点数。 对象类型：object（包括Array、Function、Date、Json等），如 var obj1 = {}; 对象（object）是js的基本数据类型之一。它是一种复合值：把多个值（原始值或者其他对象）聚合在一起，并通过名字（key）访问这些值。 对象也可看做是属性的无序集合，每个属性都是一个名/值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射 object可以像我们页面元素一样添加自定义属性，如：obj.abc = 123; 或 obj={&quot;abc&quot; : 123}; 我们之前获取元素通过点操作（obj .name）和通过中括号操作（obj[&quot;name&quot;]）同样适用于所有对象 当一个函数被一个对象所拥有，那么该函数也被称为方法，同时该函数被调用时内部的this指向会指向该对象 数据类型转换 如页面元素的block、inline这些类型，当我们需要相应的类型时就要进行数据类型转换 在JavaScript中，boolean值，数字和字符串的原始值都是伪对象，这意味着它们实际上具有属性和方法，如：”blue”.length; 转换字符串类型： 三种值类型（字符串、数组和布尔值）都具有toString方法，可以将自身转换为字符串，如Number的toString方法: 注意：null和undefined没有toString方法 12var iNum = 10;console.log(iNum.toString()); //输出字符串"10" String()强制类型转换与toString()方法的唯一不同之处在于，对null或undefined值强制类型转换可以生成字符串而不引发错误，如: 12var s1 = null.toString(); //错误var s2 = String(null); //得到"null" 与上面强制类型转换（即显形转换）对应的字符串的隐形转换+（字符串连字符） 123var s = "100"; alert(s + 100) ; //输出"100100"alert(null + "1"); //将数字1本身转换为字符串 注意：由于+是字符串连接符，因此我们要做数字相加时，必须保证加号两边的都是数字 转换数字类型： Number()方法，尽可能的将传入的值整体转换成数字。其转换规则为： 数据类型–字符串：””（空）和” “（空格）都会转换成0；数字字符串会转换成对应数字；非数字字符串转换成NaN（not a number），NaN != NaN 数据类型–布尔值：true和false会变成1和0 数据类型–空对象：null会被变成0 数据类型–对象(函数、json和其他对象)：NaN 数据类型–未定义：undefined（未定义）会变成NaN 数据类型–数组：如果为空转换成0；只有一个数据（字符串、null或undefined）时字符串会根据之前的规则一样去转，空、null和undefined会转换成0；有多个数据时转成NaN 使用方法如： 123456var s = "100";alert（Number（s）+100）; //输出结果为数字200console.log(Number(null)); //输出结果是0cnsole.log(Number(undefined)); //输出结果是NaNconsole.log(Number("100px"-1)); //输出结果为NaN Number不合适的地方：当一个字符串是var b = &quot;100px&quot;，会变成NaN，因此转换字符串时Number用的比较少，而一般用下面两个方法 parseInt()：将字符串转换成整数，转换规则为： 会从左到右依次判断每个字符，碰到非数字后会将前面的数字输出(会认识一些特殊符号，如+-空格) 若数据不是字符串会返回NaN 只会保留整数，小数点和其后面的部分会被舍去 最好写成parseInt(b,10)，后面代表10进制 123var i = "fff";/* 将16进制数转换为十进制数 */console.log(parseInt(i,16)); parseFloat()：与parseInt一样，但是会保留第1个小数点后面的数字 123456var i1 = "10";var i2 = "10.01";var i3 = "100px";//字符串转数字的强制类型转换console.log(parseInt(i3));console.log(parseFloat(i2)); 除上面的强制类型转换方法，+(正号)、-(负号)、-、*、/、%、++、–也会让数字字符串和数字字符串或数字的运算结果变成数字类型，既数字类型的隐形转换注意：+在两边有字符串时会变成字符串的隐性转换，但是作为正号或者两边没有字符串时，也是数字类型的隐形转换 12345var a = 10;var b = "10";/* 表示a加正c，也就是把字符串10转换为数字10 */console.log(a+ +c); //输出结果为数字20console("100px"-1); //输出结果为NaN，跟number方法一样 无论是哪种转换方法，转换数字失败就会返回NaN，NaN（not a number）它是转换数字类型转换失败的产物，但依然变成了number类型，它一旦出现代表你的代码进行了非法的操作 NaN转换布尔类型为false，它与它本身不相等（而其他所有类型与自己都相等） isNaN():is not a number，用来判断一个number类型是不是非数字，不是数字返回true，是数字则返回false。若判断的值不是number类型，会找Number判断，如果转换后的结果是NaN则返回true 练习： 1. 做一个input输入框和按钮，判断输入值是不是都是由数字字符组成的字符串，当判断的结果是数字时，再弹出是不是整数 ​ a. HTML部分： 12&lt;input type="text" id="btn1"&gt;&lt;input type="button" id="btn2" value="确定"&gt; ​ b. JS部分： 123456789101112131415161718var oBtn1 = document.getElementById("btn1");var oBtn2 = document.getElementById("btn2");oBtn2.onclick = function ()&#123; // if(parseFloat(oBtn1.value)== oBtn1.value) if(Number(oBtn1.value) == Number(oBtn1.value)) &#123; alert("是数字字符组成的字符串"); if(parseInt(oBtn1.value) == oBtn1.value)&#123; alert("是整数"); &#125; else&#123; alert("不是整数"); &#125; &#125; else&#123; alert("不是数字字符组成的字符串"); &#125;&#125; 2. 看下面题，说出结果： 1 + “23”; 结果：123 null * 0; 结果：0 true + “ “; 结果：true空格 true * “ “; 结果：0 undefined + 0; 结果：NaN 20 + -“20”; 结果：0 20 + +”20” 结果：40 3. 有一个数组arr = [ ‘100px’, ‘abc’-6, [], -98765, 34, -2, 0, ‘300’, , function(){alert(1);}, null, document, [], true, ‘200px’-30,’23.45元’, 5, Number(‘abc’), function(){ alert(3); }, ‘xyz’-90 ]; 要求： 1、找到arr里所有的数字：-98765, 34, -2, 0, 5 2、找到可以转成数字的：&apos;100px&apos;, -98765, 34, -2, 0, &apos;300&apos;, &apos;23.45元&apos;, 5 3、把转成数字以后，最大值判断出来：300 4、把 NaN 所在的位置找出来：1 14 17 19&lt;/font&gt;1234567891011121314151617181920212223242526272829303132333435363738394041var arr = [ '100px', 'abc'-6, [], -98765, 34, -2, 0, '300', , function()&#123;alert(1);&#125;, null, document, [], true, '200px'-30,'23.45元', 5, Number('abc'), function()&#123; alert(3); &#125;, 'xyz'-90 ];var arr1 = [];var arr2 = [];var arr3 = [];var find = [];for(var i=0;i&lt;arr.length;i++)&#123; // 找到arr里所有的数字 if((typeof(arr[i]) == "number") &amp;&amp; !isNaN(arr[i]))&#123; arr1.push(arr[i]); &#125; // 找到可以转成数字的 else if(!isNaN(parseFloat(arr[i])) )&#123; arr2.push(arr[i]); &#125; //把 NaN 所在的位置找出来 else if(isNaN(Number(arr[i])) &amp;&amp; (typeof(arr[i]) == "number"))&#123; find.push(i); &#125;&#125;for(var i in arr1)&#123; arr2.push(arr1[i]);&#125;//转成数字for(var i in arr2)&#123; arr3[i] = parseFloat(arr2[i]);&#125;// 把转成数字以后，最大值判断出来：300var max = arr3[0];for(var i=1;i&lt;arr3.length;i++)&#123; if(max&lt;arr3[i])&#123; max = arr3[i]; &#125;&#125;console.log(arr1);console.log(arr2);console.log(arr3);console.log(max);console.log(find);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js流程控制、JSON和this]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%81JSON%E5%92%8Cthis%2F</url>
    <content type="text"><![CDATA[流程控制语句 流程控制就是程序代码执行顺序：顺序结构：按照书写顺序来执行，是程序中最基本的流程结构；循环：[do ]while/for[ in]；判断：if/switch while的循环和for循环的写法区别： 1234567891011121314var i=0; //while方法while(i&lt;3)&#123; alert(i); i++;&#125; var i=0; //do while方法do&#123; //先执行do里的在判断，因此至少会执行一次 alert(i); i++;&#125;while(i&lt;3)for(var i=0;i&lt;3;i++)&#123; //for方法 alert(i);&#125; switch判断和if判断的写法区别： 123456789101112switch(str)&#123; //switch方法 case "js": break; case "html": break; default: alert(str);&#125;if(str=="js")&#123; //if方法&#125;else if(str=="html")&#123;&#125;else&#123; alert(str);&#125; 关键字：case (判断变量的值)；break(跳出，上面判断成功后不再继续判断后续)、 default(否则，上面判断都未通过时执行)；continue(跳过)例如： 123456for(var i=0;i&lt;6;i++)&#123; if(i==4)&#123; break; &#125; //当i为4的时候跳出该循环，若用continue则是跳过后续代码，继续循环 alert(i);&#125; JSON对象 JSON是JavaScript Object Notation的缩写：它被发明之前一直是用XML来传递数据，一种纯文本格式，本身不复杂，但加上各种规范以后变得非常复杂。 道格拉斯·克罗克福特(Douglas Crockford)在2002年发明了JSON这种超轻量级的数据交换格式。它基于ECMAScript的一个子集，采用完全独立的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、C#、Java、JavaScript、Perl、Python等)，这些特性使JSON成了理想的数据交换语言。易于阅读和编写，同时也易于机器解析和生成，并能提升网络传输速率。由于JSON非常简单，很快风靡Web世界。 json的语法：key==&gt;value 123456var json = &#123; "name" : "cromwell", "say" : function ()&#123; alert("hello"); &#125;&#125;; “:”前面是属性名，后面可以是任何数据格式(例子中是字符串和函数)，json.name可输出该属性的值，json.say()可调用该函数，非常方便。注意：定义的属性名称在严格模式下必须使用””，兼容性和安全性好；json[]调用数据的时候和对象的属性写法相同既： 12json["name"]; //获取json属性name的值json.name = "新值"; //可以用来改写json的name属性的值，赋值 用json可以包括数组，数组也可以包括json，如： 12var arr=[&#123;"name":"abc","age":20&#125;,&#123;"name":"bcd","age":30&#125;]; //数组嵌套jsonvar json = &#123;"a":[1,2,3],"b":[4,5,6,7]&#125;; //json嵌套数组 这时我们如果想拿到name的值”abc”就要写成arr[0].name了 for in循环：我们获取一下json的length发现json没有长度，因此无法使用for循环遍历json。for循环里使用数字i作为循环的变量对应下标，而for in循环则使用attr就是属性名称来对应json的属性名： 1234 for(var attr in json)&#123; alert(attr+":"+json[attr]) &#125;;//window和document就是两个带有很多属性的对象，我们可以输出一下看看 注意：数组用for和for in都可以遍历，用for in时属性名称就是下标；嵌套式的json和数组需要for in和for循环配合来遍历 this是什么？ 全局对象的this，是一个比较特殊的存在。全局环境中的this，指向window。 在函数(fn1)内部的this分成三种情况： 直接调用：fn1()，其内部的this会指向undefined。但是在默认非严格模式中，当this指向undefined时，它会被自动指向全局对象既window 事件调用：obj.事件=fn1，内部的this指向调用函数的该对象 调用某对象拥有的函数：obj.fn1()，那么该函数在调用时，内部的this指向该对象，该写法也称为函数表达式，写法如下： 123function fn1()&#123;&#125; //函数声明var fn1 = function ()&#123;&#125; //函数表达式obj.fn1 = function ()&#123;&#125; //函数表达式 练习： ​ 1. 把JSON嵌套式的数组和JSON遍历出来 ​ JS部分： 12345678910111213141516171819202122232425//数组嵌套json var arr = [&#123; "a" : 1, "b" : 2, "c" : 3 &#125;,&#123; "d" : 4, "e" : 5, &#125;];//json嵌套数组var obj = &#123; "arr1" : ["a","b","c"], "arr2" : ["d","e"]&#125;;//先遍历数组，再for(var i=0;i&lt;arr.length;i++)&#123; for(var attr in arr[i])&#123; console.log(arr[i][attr]); &#125;&#125;;for(var attr in obj)&#123; for(var i=0;i&lt;obj[attr].length;i++)&#123; console.log(attr+ ":" + obj[attr][i]); &#125; &#125;; ​ 2. 创建一个全局属性(var a = &quot;tw&quot;)，创建一个对象(obj)即其属性(obj.a = &quot;to&quot;)和方法(obj.saya = function(){console.log(this.a)})，说出调用该方法时this是谁 ​ JS部分： 12]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组和循环]]></title>
    <url>%2F2019%2F07%2F20%2Fjs%E6%95%B0%E7%BB%84%E5%92%8C%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[数组(Array) 声明一个数组的变量： 12var arr1 = []; //字面量写法ar arr2 = new Array(); //构造函数实例化写法 注意：第一种写法等号右边就可以认为是字面量，字面量就是可以通过该值来判断它的类型；构造函数会在后面详细说明 数组是数据仓库，可以放任意多个任意数据类型的数据，甚至是其他数组；数据之间用”,”分隔；数组也是对象的一种，属性length为数组数据的数量，如： 1var arr = ["第一个数据","第二个数据","第三个数据"]; //可以通过arr[下标]来获取对应位置的数据 注意：js中(包括数组)，在计数的时候都是从0开始，所以arr[0]==&gt;”第一个数据” 数组的添加和修改方法： 12arr.push("第四个数据"); //从数组最后添加新数据("第四个数据")arr[0] = "第零个数据"; 类数组(伪数组) 用标签名来获取元素： 1document.getElementsByTagName(""); 注意：该方法获得的不是一个元素，因此不能直接拿来操作，可以用数组的[下标]来拿到你想操作的对象 例~ 获取p元素： 1var oP = document.getElementsByTagName("p")[0]; //获取p元素 它不是数组，却和数组很像，是类数组(也叫伪数组)的一种，伪数组可以被转化成数组，语法： 1Array.prototype.slice.call() //把类数组放在括号里并用变量接收数组结果 该方法(document.getElementByTagName)与document.getElementById的区别： document.getElementById： 前面必须是document； 获取的只有一个元素(id在同一个页面中也是唯一的)； 无法选中动态创建的元素(如通过innerHTML生成的标签) document.getElementsByTagName 前面可以是另一个元素； ByTagName获取的可能是多个(无论是一个和多个都会变成类数组)，需要加上[]和数字或者遍历(既循环)来控制； ByTagName可以选中动态创建的元素 另外特殊标签选取：在页面中唯一的标签如body、title：可以用document.body和document.title获取到该元素。注意：虽然html也是唯一标签，但是必须通过document.documentElement才能获取 循环 当我们需要重复执行某些代码或连续执行的代码有数字在变化时，就可以使用循环，语法： 1for(;;)&#123;反复执行的代码块......&#125; 注意：()里用两个;将其分成3个部分，第一个部分是初始变量，第二个为判断条件(为真就会继续循环)，第三个为变量的变化 循环经常被用做给数组或类数组遍历，如 1234var aDiv = document.getElementsByTagName("div");for(var i=0;i&lt;aDiv.length;i++)&#123; aDiv[i]...... //aDiv的每个数据执行某代码&#125; 注意：不要漏写[]，否则就变成让数组或类数组执行某代码了 例~我们先用for循环和body.innerHTML属性为body添加100个按钮，并一点一点增加数量，你会发现下面写法会使电脑速度越来越慢 1document.body.innerHTML += "&lt;input type='button' value='按钮'/&gt;"; 原因就是循环去修改DOM树的做法在数量过多时太耗性能，可以先循环将要添加的字符串预先连接后保存到str变量里，再一次修改DOM树就可以了 12345var str = ""; //用字面量的写法创建一个空字符串for(var i=0;i&lt;100;i++)&#123; str += "&lt;input type='button' value='按钮'/&gt;"; //在循环中反复拼接字符串&#125;document.body.innerHTML =str; //最后一次性将字符串添加到body里 JavaScript的for循环如果要遍历一个嵌套的数组，需要用两次for循环来遍历数据，执行第一个for时变量需小于arr.length，而执行第二个for时变量则需要小于arr[i].length，最后输出arr[i][j]： 123456var arr = [[1,2,3],[4,5,6],[7,8,9]];for(var i=0;i&lt;arr.length;i++)&#123; //第一次遍历出的arr[i]也都是数组，因此开启第二个循环 for(var j=0;j&lt;arr[i].length;j++)&#123; //遍历arr[i]，将其中的数据都遍历出来 arr[i][j]...... &#125;&#125; 注意：多个并列的for循环可以用相同的变量i，但是循环的嵌套就必须要换变量名了(如上面的j) 附： 123Math.ceil(); //向上取整Math.floor(); //向下取整Math.round(); //四舍五入 练习： ​ 1. （循环的DOM操作）在页面的body里创建20个li元素，让他们呈现一个楼梯效果 ​ a.HTML部分： 1&lt;ul id="ul1"&gt;&lt;/ul&gt; ​ b. CSS部分： 1234567li&#123; width: 50px; height: 50px; list-style: none; background-color: green; position: absolute;&#125; ​ c.JS部分： 1234567891011121314var str = "";var oUl = document.getElementById("ul1");/* 获取所有的li元素 */var aLi = document.getElementsByTagName("li");/* 生成li元素 */for(var i=0;i&lt;20;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;/* 再用循环设置定位 */for(var i=0;i&lt;20;i++)&#123; aLi[i].style.left = i*50 + "px"; aLi[i].style.top =i*50 + "px"; &#125; ​ 2. 将上题的li元素减少为7个，且呈现V形 ​ JS部分： 12345678910111213141516var str = "";var oUl = document.getElementById("ul1");var aLi = document.getElementsByTagName("li");for(var i=0;i&lt;7;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;7;i++)&#123; aLi[i].style.left = i*50 + "px"; if(i&lt;4)&#123; aLi[i].style.top =i*50 + "px"; &#125; else&#123; aLi[i].style.top = aLi[6-i].style.top; &#125;&#125; ​ 3. 动态创建50个li，每行显示10个li，每两个li间距1像素 ​ a.HTML部分： 1&lt;ul id="ul1"&gt;&lt;/ul&gt; ​ b. CSS部分： 123456789li&#123; list-style: none; width: 50px; height: 50px; background-color: green; position: absolute; top: 0; left: 0;&#125; ​ c. JS部分： 12345678910111213var oUl = document.getElementById("ul1");var oLi = document.getElementsByTagName("li");var str = "";for(var i=0;i&lt;50;i++)&#123; str += "&lt;li&gt;&lt;/li&gt;";&#125;oUl.innerHTML = str;for(var i=0;i&lt;oLi.length;i++)&#123; /* 每一列的个位数相等，只需要取余获得个位数即可 */ oLi[i].style.left = i%10 * 51+ "px"; /* 每一行的十位数相等，只需要除运算获得十位数即可 */ oLi[i].style.top = Math.floor(i/10) * 51 +"px";&#125; 4. **var arr1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];var arr2 = [&quot;d&quot;,&quot;e&quot;]得到var arr = [&quot;ad&quot;,&quot;ae&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;cd&quot;,&quot;ce&quot;]**4. var arr1 = [“a”,”b”,”c”];var arr2 = [“a”,”e”]得到var arr = [“ad”,”ae”,”bd”,”be”,”cd”,”ce”]，要求不能有重复项 ​ JS部分： 1234567891011121314var arr1 = ["a","b","c"];var arr2 = ["d","e"];var arr = [];for(var i=0;i&lt;arr1.length;i++)&#123; for(var j=0;j&lt;arr2.length;j++)&#123; if(arr1[i] == arr2[j])&#123; continue; &#125; else&#123; arr.push(arr1[i]+arr2[j]); &#125; &#125;&#125;console.log(arr);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型和判断]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[关键字、保留字和ECMAScript标准 class也是页面元素的属性之一，我们可以通过赋予元素不同的class来改变样式，但js元素的class属性写法却与其他的属性不同： 12元素.class //报错元素.className //正确写法 关键字：js里用到的语法单词(如：function var) 保留字：js里保留的单词(如：class ) 不要使用关键字和保留字来给变量命名，但是可以和其他单词组合使用，比如classOne className可以用来解决兼容问题，例如没有style.float的这种写法，style.styleFloat是ie写法；style.cssFloat是其他浏览器写法，那么我们设置元素的浮动时就可以用给元素添加class或移除class的方法来做 当你需要解决兼容问题时，要么知道做如何解决兼容问题(如封装带有兼容问题的代码)，要么会使用其他的解决方案(如用className绕过该问题)，有时我们要做一个兼容性很好的代码往往比代码本身要麻烦的多 js里的所有语言规范就是ECMAScript标准，例如function[]{}不能这么写，这是已经定义好的，必须遵守的 数据类型 js的数据类型，像HTML的标签就有各种类型：block、inline、inline-block，数据类型的目的是对他们能够做更准确的操作 JavaScript中有5种原始数据类型——Undefined(未定义)、Null(空对象)、Boolean(布尔值)、Number(数字)、String(字符串)和特殊一个引用型类型——Object(对象)： Undefined(未定义)表示一个变量不含值(一般非人为因素) Null(空对象)通过设置NULL来清空变量(人为设置) 注意：undefined实际上的从null派生来的，它们在定义上是相等的 1alert(null==undefined) //true 注意：==在js中用来判断值相等，如果两边数据类型不同会在判断大小时会发生数据类型转换，但是undefined和null不会发生转换，判断结果依然为true Boolean(布尔值)只有true(真)和false(假)两个值 Number(数字)不分整数和浮点 自增/自减： 123456num += x; //相当于num = num + x;num -= x; //相当于num = num - x;num++; //先赋值再自增1num--; //先赋值再自减1++num; //先自增1再赋值--num; //先自增1再赋值 String(字符串)用双引号或单引号括起来的部分，“+”可以用来做字符串的拼接 1alert("hello"+"world"); object(对象类型)指向性数据类型(包括Array、Function、Date、Json以及页面中所有元素等)会在后面详细说明 用typeof可以判断数据类型，对变量调用typeof将返回下列值之一：string,number,Boolean,object,function,undefined，这些结果都是字符类型的 12var i = 100;alert(typeof(i)); //"number" 注意：对null调用typeof会返回object,null被认为是对象的占位符；而对象中的函数会返回function，这两种是特殊情况。 if判断 判断的语法： 123456789if(条件)&#123;代码块&#125; //当条件为true时执行代码块if(条件)&#123;代码块1&#125;else&#123;代码块2&#125; //当条件为true时执行代码块1，否则执行代码块2 if(条件1)&#123;代码块1&#125;else if(条件2)&#123;代码块2&#125;......else&#123;代码块n&#125; //当条件1为true时执行代码块1，否则条件2为true时执行代码块2,......否则执行代码块n 判断的注意事项： js获取元素的href和src属性得到不是相对路径而是绝对路径，因此不能用来做判断 通常颜色值也不能用来做判断，因为有很多颜色值的输出方式，如英文单词、rgb和16进制数 元素的内容innerHTML也不能用来做判断(在低版本浏览器上会有兼容性的问题) 当需要判断上面这些值时可以使用布尔值开关的方式解决问题，既每次执行的时候将一个布尔值变量取反(取反的符号为!，作用是将真假转换)，每次判断根据新的布尔值结果执行相应代码 判断时若使用的条件需要运算，我们常用以下的运算符：”==”(数值相等)；”===”(绝对相等—类型数值都相等)；”&gt;”，”&lt;”，”&gt;=”，”&lt;=”(大于，小于，大于等于，小于等于)等 练习： ​ 1. （用户控制时间调用函数特效）做两个input输入框和一个input按钮，通过分别向两个输入框输入样式名和样式的值的方法来改变一个div的样式 ​ a. HTML部分： 1234567891011&lt;div class="wrap"&gt; &lt;p&gt;请为下面的div设置样式：&lt;button id="btn1"&gt;点击设置&lt;/button&gt;&lt;/p&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;div id="div2"&gt; &lt;div class="ctrl"&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式" id="te1"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="text" placeholder="请输入样式值" id="te2"&gt;&lt;/div&gt; &lt;div&gt;&lt;button id="btn2"&gt;变化&lt;/button&gt;&lt;button id="btn3"&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100.wrap&#123; width: 735px; height: 420px; background-color: #efefef; margin: 0 auto; padding: 25px; box-sizing: border-box; position: relative; &#125; p&#123; margin: 0; font-size: 24px; font-weight: bold; &#125; #btn1&#123; border: none; padding: 0; width: 100px; height: 40px; font-size: 14px; color: white; background-color: red; &#125; #div1&#123; width: 100px; height: 100px; border: #393129 4px solid; background-color: white; &#125; #div2&#123; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); position: absolute; left: 0; top: 0; display: none; &#125; .ctrl&#123; position: absolute; right: 25px; bottom: 30px; width: 340px; height: 240px; box-sizing: border-box; border: 20px #9c949c solid; background-color: white; padding-top:15px; padding-bottom: 20px; &#125; .ctrl div&#123; text-align: center; font-size: 16px; margin-bottom: 5px; &#125; .ctrl div:nth-last-child(1)&#123; margin-top: 21px; &#125; .ctrl div button&#123; width: 36px; height: 32px; box-sizing: border-box; &#125; #color1&#123; background-color: red; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color2&#123; background-color: yellow; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #color3&#123; background-color: blue; color: white; font-size: 14px; border: none; padding: 0; margin-left: 5px; &#125; #width1,#width2,#width3,#height1,#height2,#height3&#123; background-color: #efefef; border: 1px #c0c0c0 solid; color: #808080; font-size: 12px; margin-left: 5px; &#125; #btn2,#btn3&#123; width: 60px; height: 30px; background-color: #002952; color: white; &#125; ​ c. JS部分： 123456789101112131415var oBtn1 = document.getElementById("btn1");var oDiv2 = document.getElementById("div2");var oDiv1 = document.getElementById("div1");var oBtn2 = document.getElementById("btn2");var oBtn3 = document.getElementById("btn3");var oTe1 = document.getElementById("te1");var oTe2 = document.getElementById("te2");oBtn1.onclick = function ()&#123; oDiv2.style.display = "block";&#125;oBtn2.onclick = function ()&#123; var style = oTe1.value; var val = oTe2.value; oDiv1.style[style] = val;&#125; ​ 2. 做一个用两个按钮(加大、缩小)点击改变字体大小的效果，字体变换范围在12px-28px区间 ​ a.HTML部分： 12&lt;button id="btn1"&gt;变小&lt;/button&gt;&lt;button id="btn2"&gt;变大&lt;/button&gt;&lt;p id="p1"&gt;电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅电饭锅&lt;/p&gt; ​ b. CSS部分： 123p&#123; font-size: 20px;&#125; ​ c. JS部分： 1234567891011121314var iFont = 20;var oBtn1 = document.getElementById("btn1");var oBtn2 = document.getElementById("btn2");var oP = document.getElementById("p1");oBtn1.onclick = function ()&#123; if(iFont&gt;12)&#123; oP.style.fontSize = --iFont + "px"; &#125;&#125;oBtn2.onclick = function ()&#123; if(iFont&lt;28)&#123; oP.style.fontSize = ++iFont + "px"; &#125;&#125; ​ 3.（表单验证）输入框input的验证，为空时弹出”输入框内容不能为空” ​ a. HTML部分： 123&lt;input type="text" id="te1"/&gt;&lt;input type="text" id="te2"/&gt;&lt;button id="btn1"&gt;弹出&lt;/button&gt; ​ b. JS部分： 1234567891011121314// 弹出第一个输入框的值 + "在" + 第二个输入框的值 // 如果第一个输入框内为空，则弹出 "输入内容不能为空" var oTe1 = document.getElementById("te1"); var oTe2 = document.getElementById("te2"); var oBtn1 = document.getElementById("btn1"); oBtn1.onclick = function ()&#123; // if(oTe1.value == "")&#123; // alert("输入内容不能为空"); // &#125;else&#123; // alert(oTe1.value + "在" + oTe2.value); // &#125; // oTe1.value == "" ? alert("输入内容不能为空") : alert(oTe1.value + "在" + oTe2.value); alert(oTe1.value == "" ? "输入内容不能为空" : oTe1.value + "在" + oTe2.value); &#125; ​ 4. 布尔值开关（取反）实现下拉框 ​ a. HTML部分： 12&lt;button id="btn1"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 120px; height: 40px; &#125; div&#123; width: 120px; height: 350px; background-color: red; display: none; &#125; ​ c. JS部分： 123456789101112var oDiv = document.getElementById("div1");var oBtn = document.getElementById("btn1");var bOn = true;oBtn.onclick = function ()&#123; // if(bOn)&#123; // oDiv.style.display = "block"; // &#125;else&#123; // oDiv.style.display = "none"; // &#125; oDiv.style.display = bOn ? "block" : "none"; bOn = !bOn;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件函数和属性操作]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js选择器和事件函数 js的事件：鼠标事件、键盘事件、系统事件、表单事件、自定义事件等，如下常见的鼠标事件 鼠标左键点击：onclick 鼠标移入：onmouseover 鼠标移出：onmouseout 鼠标左键落下：onmousedown 鼠标左键抬起：onmouseup 鼠标移动：onmousemove 获取元素的方法：通过ID名称来获取元素，其中.代表”的”： 1document.getElementById('link'); –&gt;document get element by id ‘link’(既在文档上通过id的值来获取元素)，获取的元素可以配合事件：元素.onmouseover=元素在鼠标移入该元素时做什么，由于做的事情应该是该事件触发时执行，那么这些代码我们不能直接使用，而是放在函数内部 函数(function)：由事件去命令它做一些事(执行代码块)，它不会主动执行： 函数是执行某一任务的JavaScript 语句，可被其他部分调用。 下面是声明一个有名函数的方法： 123function functionName()&#123; //function==&gt;关键字；functionName==&gt;是给函数取的名字 代码块...... //代码块==&gt;是完成某一任务的代码 &#125;; 我们把完成特定功能的代码块放到一个函数里，再调用这个函数，就省重复输入大量代码的麻烦。 有名函数执行方法：例如函数名为abc的函数 12abc(); //直接调用执行，当逐行执行代码执行到这步时执行代码元素.事件 = abc; //当事件发生时执行该函数 注意：事件调用函数后面没有括号，使用括号会出错，原因会在后面说明 匿名函数：没有名字的函数，使用方法： 123元素.事件 = function ()&#123; 代码块......&#125; 注意：由于匿名函数没有函数名，因此不能直接调用，一般是用在事件调用及后面的传参、闭包等地方 当很多地方需要反复使用一段代码的时候，我们应该声明一个有名函数；若只在一个事件使用的函数则可以使用匿名函数 onload是加载事件，可用在一个图片或者body等对象加载上。我们在开头的地方说过JS的代码可以放在head或body里，但是我们刚才用来获取元素的方法如果放在head里，输出的元素却找不到了。原因就是html文件是同步代码(顺序执行)，当读取到获取元素时，实际HTML中的元素并不存在，解决方法：1、将放在head里的script中的代码包在一个函数内，在&lt;/body&gt;前script里调用(不推荐)；2、将放在head里的script中的代码放在window的onload的事件里执行(推荐)；3、把script标签放在&lt;/body&gt;前，这样还可以提高用户体验(推荐) 属性操作 其实我们获取的页面中的元素就是对象(对象：就是带有属性和方法的特殊数据类型)，而元素也就是标签本身就是有属性的如：&lt;input id=&quot;btn1&quot; type=&quot;button&quot;/&gt; 属性名(id和type)，属性值(btn1和button)； 12元素.属性; //读：获取某元素属性的值 元素.属性 = "新值"; //写：替换某元素属性的值 注意：“读”的值都是字符串类型；“写”是替换操作，不是添加，因此原值会消失 元素的内容，语法： 12元素.innerHTML;元素.innerHTML = "新内容" 注意：内容包括子元素，所以“写”的时候可以用来加入新元素 元素的值，语法： 12元素.value;元素.value = "新内容" 元素的样式，语法: 12元素.style.样式 = "新值";元素.style.cssText= 'width:200px'; //注意该写法里面的值和css的写法相同 注意：这两种方法都会把样式加在元素的行间样式中，而获取样式时，获取的也是行间样式，它不会去计算当前样式，因此一般只用来“写”不用来“读”；另外js里不能出现”-“，因此第一个方法中background-color需写成backgroundColor，第二个由于写法和css相同，因此不用修改 “[]”的一种用法类似”.”，由于”.”后面的值不能变(如.style.width的width不能用变量)，因此在需要我们用变量的时候会用到”[]”： 12元素.style.width; //用"."的写法元素.style["width"]; //用"[]"的写法，"[]"里可以是变量 注意：”[]”里如果是属性，必须加双引号；如果是变量，不可以加双引号 练习： ​ 1.做一个下拉框效果，鼠标点击按钮时，在该元素下显示一个下拉框区域 ​ a. HTML部分： 12&lt;button id="btn"&gt;下拉框&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910button&#123; width: 150px; height: 60px;&#125;div&#123; width: 150px; height: 400px; background-color: red; display: none;&#125; ​ c. JS部分： 12345var oBtn = document.getElementById("btn");var oDiv = document.getElementById("div1");oBtn.onclick = function ()&#123; oDiv.style.display = "block";&#125; ​ 2. 设置css和选择器 1.box&#123;width:150px; height:150px; background-color: red; &#125; 页面中设置一个textarea、button和div，在点击button时，将带有class(box)的div元素在页面的div里创建出来，即点击按钮时，将文本域中的值在div1的内容中展示出来 ​ a. HTML部分： 12&lt;textarea name="" id="te" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;button id="btn"&gt;按钮&lt;/button&gt; ​ b. CSS部分： 1.box&#123;width:150px; height:150px; background-color: red; &#125; ​ c. JS部分： 123456var oDiv = document.getElementById("div1");var oText = document.getElementById("te");var oBtn = document.getElementById("btn");oBtn.onclick = function ()&#123; oDiv.innerHTML = oText.value;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习要求和基本语法]]></title>
    <url>%2F2019%2F07%2F19%2Fjs%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B1%82%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js的组成 尽管ECMAscript是一个重要的标准,但它并不是JavaScript的唯一的部分，当然，也不是唯一被标准化的部分。 实际上，一个完整的JavaScript实现是由一下3个不同的部分组成的。 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) DOM和BOM就是前文说到的浏览器大战而产生的拥有大量不兼容的地方 js是什么 简单来说，JavaScript是一种可以用来给网页增加交互性的编程语言。也常被称为”脚本语言”。 学习它有很多用途和好处： 所有主流浏览器都支持JavaScript 基本所有的网页都会用到JavaScript 可以让网页呈现各种动态效果 不需要安装环境(浏览器都支持)，有文本编辑器就可以编写JavaScript代码 js的学习要求 非必要条件：数学功底，英文功底，其他程序语言的基础 必要条件：HTML+CSS2基础好，尤其CSS2的样式使用要求灵活 主观条件：多去网上看，多思考别人的方法，多练习实现效果。如何布局，如何设置脚本 例如让一个元素移出我们的视线的方法，而我们往往必须想到在当前条件下哪种是最优的选择： 设置透明度opacity为0 用visibility或display隐藏元素 用position和偏移值定位出可视区 width \ height设置为0，并溢出隐藏 js引入html和输出 html中的js代码必须放在script标签里面，script标签可以放在页面中head和body标签中。 一行结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束； “hello world!”是一串字符串，“//”是单行注释 &lt;/script&gt;这里结束JavaScript，并告诉浏览器后面的代码是html代码了： 123&lt;script&gt; document.write(&quot;hello world!&quot;); //获得文档窗口并在其中写入&quot;Hello, world!&quot;&lt;/script&gt; 注意：每行结尾的分号可有可无，好的代码编写习惯是加入分号，这会增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。 我们需要让多个html页面共享一个脚本时就把脚本保存到外部文件中。外部文件扩展名是.js。使用时在&lt;script&gt; 标签的src属性中设置该文件的路径。如： 1&lt;script src="myScript.js"&gt;&lt;/script&gt; 注意：外部JavaScript文件中不能出现&lt;script&gt;标签(标签都是html语言) 输出数据方式除了document.write外还有下面两个方法： 12alert("hello world"); //弹出一个确认框，里面显示"hello world"console.log("hello world"); //在控制台打印"hello world" 注意：控制台里输出的字符串和其他数据的颜色不同。 js语法特征 注释与Java，C相同，支持单行注释 //；与多行注释/…/ 变量是用于存储信息的容器，JavaScript区分大小写，a和A是两个不同的变量 js的变量是弱类型的，定义变量只用var运算符，可以将它初始化为任意值，也可以随时改变变量所存数据的类型，可以用“,”将多个变量定义在一个var中，如： 12345var color = "red"; //声明了一个字符串类型变量，但不需要声明其类型color = 16; //弱类型语言，在这里将color的值从字符串改成了数字var num = 25; //等号"="叫做赋值操作，意思是将等号右侧的值赋给左侧var visible = true;var a = "5", b = 5; //一个var声明了2个变量 注意：由于js引擎会在出错时自动停止，因此我们可以将上面alert输出方法逐行放置，如果alert未执行，说明上面的代码有错误。初学者应养成随时写随时测试的习惯，以防做完一堆代码都是不能用的。 js变量的命名规则 没人天天叫毕加索的全名，js里也可以用一个名字储存数据，将事件加在名字上可以大大减少代码量 变量的命名规则：变量必须以字母开头；虽然变量也能以$和_符号开头(不过不推荐这么做)；变量名称也对大小写敏感(a和A是不同的变量)。 变量使用var关键字声明：var 名字 = ，后面可以是数字，字符串或者一个对象等等 好的代码编写习惯是总是用var声明变量的，并且始终存放相同类型的值，常用的命名规则： Camel标记法：首字母是小写的，接下来的单词都以大写字母开头。 Pascal标记法：首字母是大写的，接下来的单词都以大写字母开头。 匈牙利标记法：在以Pascal标记法命名的变量前附加一个小写字母说明该变量的类型。如比较常用的:i表示整数；s表示字符串；b代表boolean值；o代表对象；a代表数组或集合]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的概述和历史]]></title>
    <url>%2F2019%2F07%2F19%2Fjavascript%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[JavaScript作为赋予网页活力与交互性的主要手段之一，已成为web设计师和开发人员的必备技能。但它诞生时其实是个屌丝，没有想到发展到如今的地位 JavaScript是被人误解和误用最多的主流编程语言，很多人将它看作Java等面向对象语言的功能不全的小兄弟。随着越来越多的程序员转向浏览器/服务器模式开发，加上WEB2.0和Ajax的兴起，人们开始认识到，JavaScript绝非一种容易学习和掌握的技术，它具有面向对象，过程和函数型语言三类语言的特性，灵活性与强大功能完美结合，迄今为止，它的潜力远远没有正真释放出来。 上古时代的浏览器Netscape中，主要是些丑陋的静态文本和简单的图片， 和现在的页面相比，差的实在太远了。 当互联网刚开始兴起时，用户的数据需要全部在服务器端处理，这在网速非常慢的当时使用户的上网体验非常痛苦。Brendan Eich( JavaScript的发明人)有一回注册用户，由于忘了填写性别，等待了38秒后服务器告诉了他。他很崩溃：”这么简单的问题浏览器不会告诉我，还得把数据提交到几千公里外的服务器在那里检查才能发现问题吗！”。于是他向老板反馈问题，老板说： “我也早有此意，你来设计一个类似java的脚本吧”，老板对java非常感兴趣。Brendan Eich对java 毫无兴趣，但为了应付公司的任务，他花了10天设计出个脚本语言，由于设计时间太短，一些细节考虑得不够严谨。 如果他能预见到未来这种语言会成为互联网第一大语言，全世界有成千上万的学习者，他一定会多花一点时间吧。1995年Natscape公司决定在即将发行的Netcape Navigator2.0中加入一个称之为LiveScript的脚本语言，用于客户端数据验证。 后来NetScript与SUN公司联手完成LiveScript实现，就在Netcape Navigator2.0即将发布前，Netscape将其更名为JavaScript，目的是为了利用Java这个因特网当时的时髦词汇，Netscape的赌注最终得到了回报，JavaScript从此变成了因特网的必备组件。Brendan Eich最初遇到的问题简直就是小菜一碟了， 做个简单的表单验证，就解决问题了。 除此以外JavaScript 还可以操作DOM树。有了这棵树，它可以定位到DOM树中任意一个节点， 然后对这个节点进行操作，例如隐藏节点、显示节点、改变颜色、获得文本的值，改变文本的值，添加一个响应点击事件的函数等等，几乎为所欲为。这些操作可以立刻展示出效果来，你完全不用刷新网页。这些操作完全是内部进行的，html源码并不会改变，所以有时候你打开html源码，会发现这些源码和你在浏览器中看的效果并不一致，那就是JavaScript在背后改变了这个DOM树了。 JavaScript还能控制浏览器，比如打开窗口，在一个窗口内前进、后退，获得浏览器的名称，版本等等。为啥要获得浏览器的名称和版本呢？因为JavaScript1.0的成功，Netscape在它的3.0版本中发布了1.1版，恰巧那个时候，微软决定进军浏览器，发布了IE3.0并搭载了一个JavaScript的克隆版，叫做Jscript(这个命名是为了避免与NetScape潜在的许可纠纷)，微软步入Web浏览器领域的这重要一步虽然令其声名狼藉，但也成为了JavaScript语言发展过程中的重要一步。 在Netscape 和IE 进行浏览器之战的期间，他们都争相在自己的浏览器中支持Javascript，并且为了锁定程序员，还开发了很多自己浏览器的独特功能，有些功能只能在IE用，有些只能在Netscape 用，所以必须的判断是什么浏览器，这样才能特殊处理。不管怎么说，这些功能让浏览器中的网页变的更加动态了，更加有趣好玩了。 在微软进入后，有3个不同的JavaScript版本同时存在：JavaScript，Jscript以及ScriptEase，当时JavaScript并没有一个标准来统一其语法或特性。因此在1997年，JavaScript1.1作为一个草案提交给欧洲计算机制造商协会(ECMA)，第39技术委员会(TC39)被委派来”标准化一个通用、跨平台、中利于厂商的脚本语言的语法和语义” 。 由来自Netscape，Sun，微软、Borland和其他一些对脚本编程感兴趣的公司的程序员组成的TC39锻炼出了ECMA-262，该标准定义了叫做ECMAScript的全新的脚本语言，从此Web浏览器就开始努力将ECMAScript作为JavaScript实现的基础。 互联网的发展超出了所有人的预料，JavaScript被应用在几乎每一个网站上，但它只能在浏览器中运行，没法像java 那样访问网络，也就没有办法调用服务器端的接口来获取数据。用户只能通过GET或者POST向服务器发送请求，这时候服务器返回的数据是整个页面，而不是页面中的一个片段，也就是说整个页面都得刷新一遍，哪怕是页面中只有一个文字的改变。 1998年，IE5中引入一个新的功能：XMLHttpRequest，这个新功能将允许JavaScript直接向服务器发出接口调用。这个过程就是访问一下服务器端处理登陆的接口，IE5先干别的事儿，JavaScript得到服务器端的返回数据以后，用下IE5的这个函数。这其实就是异步调用，如果服务器处理和网络速度都足够快的话，用户就会发现：咦，我没有刷新整个页面，竟然已经登录了啊。IE都没有料到，这个功能带来了一场革命：这种方式可以使得网页局部刷新，让用户浏览网页的体验极佳，尤其是Google 地图，Gmail 等应用让互联网应用火了起来。其他浏览器也迅速跟进，实现了类似功能，各种各样交互性极佳的网站如雨后春笋般出现。之后桌面应用慢慢的都被搬到了互联网上。上面的那种处理方式称为AJAX即”Asynchronous Javascript And XML”(异步的JavaScript和XML)，异步问题解决了，但是XML真正的数据很少，标签反而占了大头，把数据都给淹没了。 Javascript的语法，里边有个叫对象的东西, 它有一个花括号，在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义，属性由逗号分隔。这种结构完全可以表达上面的xml内容。而且还支持数组，这样表达多个对象也不在话下。更重要的是，如果采用这种结构， Javascript根本不用什么XML解析器去解析了，它就是Javascript语言的一部分。直接拿来用即可。这种简洁的格式叫做JSON, 并且和服务器约定，都用JSON来传输数据。 HTML结构层，CSS样式层，而Javascript (加上AJAX, JSON)行为层。前端编程三个部分形成了。ExtJS, prototype, JQuery这些框架把前端编程推向另外一个高峰。甚至出现了AngularJS ，实现了SPA(单一页面应用程序)。但Javascript依然只能在浏览器和网页上。这也是为什么总有的人将Javascript被贬为雕虫小技，对它不屑一顾。但在Javascript发明十几年以后，又一位大牛Ryan Dahl于2009年把Javascript放到了服务器端，这就是node.js。越来越多使用node.js的网站证明， javascript的确可以在服务器端立足，并且有一个巨大的优势：前端和后端都用javascript！]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端CSS3选择器和常用样式]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFCSS3%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSS3基础 说明：CSS3完全向后兼容，浏览器永远支持CSS2，CSS3就是CSS2的扩展版，W3C的CSS3规范虽然仍在开发，但许多新的CSS3属性已在现代浏览器中使用。主要包含：选择器、盒模型、背景和边框、文字特效、2D/3D转换、动画、多列等 CSS3属性选择器​ 以&lt;input type=&quot;text&quot;&gt;为例 input[type] ：只使用属性名，但没有确定任何属性值 input[type=&quot;value&quot;] ：指定属性名，并指定了该属性的属性值 input[type~=&quot;value&quot;] ：指定属性名，并且具有属性值，此属性值是一个以空格隔开的词列表，词列表中包含了一个value词 input[type^=&quot;value&quot;] ：指定了属性名，并且拥有属性值，属性值是以value开头的 input[type$=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type*=&quot;value&quot;] ：指定了属性名，并且有属性值，而且属性值中包含了value input[type|=&quot;value&quot;] ：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn） CSS3伪类 （常用）E:nth-child(n) ：表示E父元素的第n个子节点，且类型为E 特殊值：odd(匹配奇数行)等价于2n+1 even(匹配偶数行)等价于2n(下面的其他选择器同理) （常用）E:nth-of-type(n) ：表示E父元素的第n个E子节点 E:nth-last-child(n) ：表示E父元素的第n个子节点，从后向前算，且类型为E E:nth-last-of-type(n) ：表示E父元素的第n个E子节点，从后向前算 E:first-child ：表示E父元素中的第一个子节点，且类型为E，等价于E:nth-child(1) E:last-child ：表示E父元素中的最后一个子节点，且类型为E，等价于E:nth-last-child(1) E:first-of-type ：表示E父元素中的第一个E子节点，等价于E:nth-of-type(1) E:last-of-type ：表示E父元素中的最后一个E子节点，等价于E:nth-last-of-type(1) E:empty ：表示E元素没有子节点。注意：包含文本节点 E:only-child ：表示E父元素中只有一个子节点。注意：不包含文本节点 E:only-of-type ：表示E父元素中只有一个子节点，且这个唯一的子节点的类型必须是E。注意：不包含文本节点 E:target ：表示当前的URL片段的元素类型(id被a的href链接并被点击，也就是锚点——访问的a标签的链接为某元素的id)，这个元素必须是E E:disabled ：表示不可点击(获取焦点)表单控件 E:enabled ：表示可点击(获取焦点)的表单控件 E:checked ：表示已选中的checkbox或radio E:not(s) ：表示E选中的元素中的s不被匹配(s是标签名) E~F ：表示E元素毗邻的所有F元素(之后的所有同级元素，类似于nextAll())，下一个F元素则要用”+” 举几个例子~ 锚点和激活锚点（第12条）： ​ 题目：设置3个div盒子(150*150,红)，设置3个a标签，div盒子和a标签内容分别为div1,div2,div3 ​ 要求：1. 激活锚点：当点击a标签的内容时，跳转到对应的div盒子所在位置； ​ 2. 当div元素的锚点被激活时，背景颜色变为蓝色 ​ 提示：激活锚点：a标签的href里是#div（也就是div元素的id值） a. HTML部分： 123456&lt;a href="#div1"&gt;div1&lt;/a&gt;&lt;a href="#div2"&gt;div2&lt;/a&gt;&lt;a href="#div3"&gt;div3&lt;/a&gt;&lt;div id="div1"&gt;div1&lt;/div&gt;&lt;div id="div2"&gt;div2&lt;/div&gt;&lt;div id="div3"&gt;div3&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122232425262728293031323334/* 为了展示跳转效果，特意给body设置高度 */body&#123; height: 4000px;&#125;/* 设置div盒子的样式 */div&#123; width: 150px; height: 150px; background-color: red; position: absolute; font-size: 50px; color: white;&#125;/* 分别定位每个div盒子的位置（也是为了展示跳转效果） */div:nth-of-type(1)&#123; left: 0; top: 500px;&#125;div:nth-of-type(2)&#123; left: 0; top: 1500px;&#125;div:nth-of-type(3)&#123; left: 0; top: 1800px;&#125;di:nth-of-type(4)&#123; left: 0; top: 2000px;&#125;/* 当div元素的锚点被激活时，背景颜色变为蓝色 */div:target&#123; background-color: blue;&#125; 表单伪类（第13条）：设置一个不可点击的表单控件 a. HTML部分： 1&lt;input type="text" disabled&gt; ​ b. CSS部分： 123input:disabled&#123; border: 1px blue solid;&#125; CSS3伪元素 E::first-line ：表示E元素中的第一行 E::first-letter ：表示E元素中的第一个字符 E::selection ：表示E元素在用户选中文字时(moz) 举个例子~ ​ 题目：设计一个p标签，文字随意 ​ 要求：第一个字大小为30px，第一行文字颜色为蓝色，当用户选中文字时选中的背景颜色变为绿色且被选文字颜色为橘色 ​ a. HTML部分： 123&lt;p&gt; 语文老师说：“如果你越来越冷漠，你以为你成长了，但其实没有。长大应该是变得温柔，对全世界都温柔。”&lt;/p&gt; ​ b. CSS部分： 123456789101112131415161718/* 设置p标签的样式 */p&#123; width: 300px; border: 1px #000 solid;&#125;/* 设置第一个字的大小 */p::first-letter&#123; font-size: 30px;&#125;/* 设置第一行文字的颜色 */p::first-line&#123; color: blue;&#125;/* 当用户选中文字时的样式变化 */p::selection&#123; background-color: green; color: orange;&#125; 练习1： 做一个商品列表（12个），要求4行一列，每两个商品(100*100)之间需要有间距(10px)，但是商品与边界之间无间距 a. HTML部分： 123456789101112131415&lt;!-- 设置12个li --&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ​ b. CSS部分： 123456789101112131415161718ul&#123; /* 引入common.css后，宽度要加上2px的边框 */ width: 432px; border: 1px #000 solid; /* 清浮动 */ overflow: hidden;&#125;li&#123; background-color: red; width: 100%; height: 100px; float: left; margin: 0 10px 10px 0;&#125;/* 商品与边界之间无间距 */li:nth-of-type(4n)&#123; margin-right: 0;&#125; 模拟单选和多选框 a. HTML部分： 123&lt;!-- 加span标签 --&gt;&lt;label&gt;&lt;input type="radio" name="sex"&gt;&lt;span&gt;&lt;/span&gt; 男&lt;/label&gt;&lt;label&gt;&lt;input type="radio"&gt;&lt;span&gt;&lt;/span&gt; 女&lt;/label&gt; ​ b. CSS部分： 123456789101112131415161718192021/* 这样设置没作用 *//* input[type="radio"]&#123; width: 50px; height: 50px; border: 1px red solid; &#125; */span&#123; display: inline-block; width: 10px; height: 10px; border: 1px red solid; vertical-align: middle;&#125;input[type="radio"]&#123; position: absolute; left: -9999px;&#125;/* 下一个同级元素span：+span */input[type="radio"]:checked+span&#123; background-color: red;&#125; CSS3新文本样式 文本阴影：text-shadow:x y blur color, … （x/y 横向偏移/纵向偏移 blur 模糊距离 color 阴影颜色）文本阴影如果加很多层，会很卡，如：text-shadow:2px 2px 4px black 注意：有多个阴影的先渲染后面的，再渲染前面的 叠加： 1text-shadow: 2px 2px 0px red, 2px 2px 4px green; 层叠： 1234color:red; font-size:100px; font-weight:bold; text-shadow:2px 2px 0px white, 4px 4px 0px red; 光晕： 123color:white; font-size:100px;text-shadow:0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de, 0 0 100px #ff00de, 0 0 150px #ff00de; 火焰： 12345text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-family:Verdana, Geneva, sans-serif; font-size:100px; font-weight:bold; color:white; 盒模型阴影：box-shadow:[inset] x y blur [spread] color ​ （ [inset]：投影方式(默认为外投影，inset为内投影)​ x、y：水平和垂直方向的阴影偏移​ blur：模糊半径​ [spread]：扩展阴影半径(先扩展原有形状，再开始画阴影)​ color：颜色 ） 举例~ ​ a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 1234567div&#123; width: 150px; height: 150px; background-color: red; margin: 150px auto; box-shadow: 10px 10px 2px 20px rgba(0,0,0,0.7);&#125; 定义文字排列方式(全兼容)：directionrtl ：从右向左排列；ltr ：从左向右排列注意：要配合unicode-bidi:bidi-override; 一块使用 1234/* 文字从左向右排列 */.ltr p&#123;direction:ltr;unicode-bidi:bidi-override;&#125;/* 文字从右向左排列 */.rtl p&#123;direction:rtl;unicode-bidi:bidi-override;&#125; 定义省略文本的处理方式：text-overflow clip ：无省略号 ellipsis ：省略号 注意：要配合overflow:hidden和white-space:nowrap一块使用 多列：将文本内容设计成像报纸一样的多列布局，集合样式：column column-width：指定列的宽度 column-count：要分的列数 column-gap：列之间的距离 column-rule：栏目间隔线由column-rule-style(hidden：定义隐藏规则/dotted：定义点状规则/dashed：定义虚线规则/solid：定义实线规则/double：定义双线规则)、column-rule-width和column-rule-color的集合成 calc()函数：用于动态计算长度值 ​ 注意：运算符前后都需要保留一个空格 ​ 例如：width: calc(100% - 10px) (父元素宽度-10px) 任何长度值都可以使用calc()函数进行计算 calc()函数支持 “+”, “-“, “*”, “/“ 运算calc()函数使用标准的数学运算优先级规则 练习2： 阴影：给一个P标签做一个火焰效果 a. HTML部分： 1&lt;p&gt;最美的时光&lt;/p&gt; ​ b. CSS部分： 1234567p&#123; font-weight: bold; text-align: center; text-shadow: 0 0 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-size:100px; font-weight:bold; color:white;&#125; 做《静夜思》的文字布局（从右向左，从上到下） a. HTML部分： 1&lt;p&gt;床前明月光疑是地上霜举头望明月低头思故乡&lt;/p&gt; ​ b. CSS部分： 123456789p&#123; font-size: 20px; width: 100px; /* 一共有4列 */ column-count: 4; /* 从右向左排列 */ direction: rtl; unicode-bidi: bidi-override;&#125; CSS3新样式 变形：包含旋转函数、倾斜函数、缩放函数、位移函数 旋转函数： 12transform:rotate() /* 旋转度数(deg) */transform-origin:x y /* 旋转基点 */ 倾斜函数： 123transform:skew() /* 斜切度数(deg) */transform:skewX() /* 水平方向倾斜 */transform:skewY() /* 垂直方向倾斜 */ 缩放函数： 123transform:scale() /* 缩放取值(正数、负数和小数) */transform:scaleX() /* 水平方向缩放 */transform:scaleY() /* 垂直方向缩放 */ 位移函数： 123transform:translate() /* 位移取值(像素值) */transform:translateX() /* 水平方向位移 */transform:translateY() /* 垂直方向位移 */ ​ 2. 过渡：transition集合样式(css3的动画的一种) 12345678transition-property：要运动的样式(all || [attr] || none)transition-duration：规定完成过渡效果需要多少秒或毫秒transition-delay：定义动画延迟多久开始transition-timing-function：运动速度曲线。 ease：(逐渐变慢)默认值；linear：(匀速)； ease-in：(加速)；ease-out：(减速)； ease-in-out：(先加速后减速)； cubic-bezier 贝塞尔曲线( x1, y1, x2, y2 )，可以百度一下贝赛尔曲线的图 圆角：border-radius 集合样式：border-top-left-radius/border-top-right-radius/border-bottom-right-radius/border-bottom-left-radius，也就是从左上角开始顺时针数 即，1-4个数字 / 1-4个数字：/前面是水平方向圆角，后面是垂直方向圆角，不加/指的两个方向圆角相同，如：border-radius: 10px/5px; 参数：各种长度单位都可以：px，%，…，%有时很方便，但宽高不一致时不太好参数个数1：四个方向都一样，border-radius: 一样参数个数2：对角，border-radius: 左上&amp;右下 右上&amp;左下参数个数3：斜对角，border-radius: 左上 右上&amp;左下 右下参数个数4：全部，顺时针，border-radius: 左上 右上 右下 左 边框图片：border-image(集合样式) 引入图片url ：border-image-source 切割图片(从外向内，可以是不带单位的数字或百分比)：border-image-slice 边框宽度(展示边框图片区域)：border-image-width 边框图像区域超出边框的量：border-image-outset 图片的排列：border-image-repeat 图片的排列方式：round 四舍五入，repeat 重复，stretch 拉伸 集合样式：border-image:url() s s s s/w w w w/o o o o repeat 练习3： 做一个可旋转的风车，用圆角做风车的叶片 a. HTML部分： 123456&lt;div class="wrap"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; ​ b. CSS部分： 12345678910111213141516171819202122.wrap&#123; width: 600px; height: 600px; overflow: hidden; margin: 0 auto; transition: 10s all linear;&#125;.wrap&gt;div&#123; width: 300px; height: 300px; background-color: red; float: left;&#125;.wrap&gt;div:nth-child(1),.wrap&gt;div:nth-child(4)&#123; border-radius: 0 90%;&#125;.wrap&gt;div:nth-child(2),.wrap&gt;div:nth-child(3)&#123; border-radius: 90% 0;&#125;.wrap:hover&#123; transform: rotate(1800deg);&#125; 用过渡做按钮1：做一个搜索按钮，在鼠标移入时慢慢出现一个=&gt;符号 a. HTML部分： 1&lt;div class="parent"&gt;搜索&lt;/div&gt; ​ b. CSS部分： 1234567891011121314151617181920.parent&#123; width: 120px; height: 40px; border: 1px #000 solid; text-align: center; line-height: 40px; font-size: 22px; border-radius: 20px;&#125;.parent::after&#123; display: inline-block; content: "=&gt;"; width: 0; opacity: 0; transition: all 0.3s linear;&#125;.parent:hover::after&#123; width: 25px; opacity: 1;&#125; 用过渡做按钮2：做一个立体按钮，在击中时显示下压效果 a. HTML部分： 1&lt;div&gt;&lt;/div&gt; ​ b. CSS部分： 123456789101112div&#123; width: 80px; height: 35px; background-color: greenyellow; box-shadow: 0 8px 0 rgba(0,0,0,0.4); border-radius: 17px; transition: all 0.3s linear;&#125; div:active&#123; box-shadow: 0 1px 0 rgba(0,0,0,0.4); transform: translateY(7px);&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端BFC和三栏式布局、SEO和服务器、HTTP]]></title>
    <url>%2F2019%2F07%2F18%2FWEB%E5%89%8D%E7%AB%AFBFC%E5%92%8C%E4%B8%89%E6%A0%8F%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81SEO%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81HTTP%2F</url>
    <content type="text"><![CDATA[BFC(Block fomatting context) “块级格式化上下文”。是一个独立的渲染区域，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Box是CSS布局的对象和基本单位，一个页面是由很多个Box组成的。元素的类型和display属性，决定了这个Box的类型。 不同类型的Box，会参与不同的Formatting Context(一个决定如何渲染文档的容器)，因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且会参与 block fomatting context；(简称BFC) inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且会参与 inline formatting context；(简称IFC) Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会变成BFC区域 根元素 float属性不为none position属性值为absolute或fixed display属性为inline-block, table-cell, table-caption, flex, inline-flex overflow属性不为visible BFC的用法： 自适应两栏布局：左栏定宽左浮动，右栏不定宽overflow:hidden;(设置成BFC) 清除内部浮动：父元素设置overflow:hidden;(设置成BFC)，既之前我们用来清除浮动的方法之一 防止垂直 margin 重叠：其中一个元素外套一个div并设置overflow:hidden;(设置成BFC) 三栏式布局 三栏式布局是一种，两边盒子固定宽度，中间盒子自适应的布局 圣杯布局和双飞翼布局 父元素包含左中右三个盒子，分别左浮动，中间元素宽度100%(必须为第一个渲染) 用margin-left的负值将两边盒子拉上去和中间盒子同行(左边-100%，右边-右盒子宽度) 给父元素上清除浮动 父元素用左右padding为左右盒子留位置并用相对定位将左右元素移动到正确的位置上(圣杯) 给中间元素设置子元素，并给其左右margin为左右盒子留位置(双飞翼) 转义和框架标签 HTML的转义字符，网上可以找到转义字符的表(http://tool.oschina.net/commons?type=2) 通过&amp;XXXX的格式生成一个转义字符 原因是有部分字符无法直接在html里直接生成，如：空格 、&amp;符号、大于号&gt;、小于号&lt;、©符号等 做个练习~ 在页面中生成下面的句子： ​ 在页面里输入一个&lt;br /&gt;就可以实现换行了 ​ 在页面里输入&amp;nbsp;就可以实现空格&nbsp;效果了 ​ 在页面里输入&amp;copy;就可以实现&copy;符号了 123&lt;p&gt;在页面里输入&amp;lt;br /&amp;gt;就可以实现换行了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;nbsp;就可以实现空格效果了&lt;/p&gt;&lt;p&gt;在页面里输入&amp;amp;copy;就可以实现©符号了&lt;/p&gt; iframe：框架标签(在当前页面显示多个网页) scrolling：是否有滚动条，值为yes(有)/no(无)，默认为auto(需要的时候出现) frameBorder：是否有边框，值为正整数，默认为1，值为0时无边框 align：对齐方式 src：嵌套页面地址 width/height：嵌套页面区域的宽高 name：配合a的target属性值等于iframe的name，可以让a在超链接的跳转打开页面时在iframe区域打开 优点：解决加载缓慢的第三方内容图标和广告等的加载问题；iframe无刷新文件上传；iframe跨域通信 缺点：iframe会阻塞主页面的onload事件；无法被一些搜索引擎索引到；页面会增加服务器的http请求；会产生很多页面，不容易管理。 雪碧图和引入样式表 sprites(雪碧图)原理 首先把网页中一些背景图片整合到一张图片文件中(png格式) 用”background-image”引入图片；”background- repeat”禁止平铺；”background-position”精确定位背景 优点：减少网页的http请求次数，并防止切换图片出现的闪白；减少图片的字节数，解决图片命名上的困扰(对一张集合的图片上命名就可以了，不用对每一个小图片进行命名)；更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变 缺点：在宽屏，高分辨率的屏幕下的自适应页面，雪碧图如果不够宽，容易出现背景断裂；在开发的时候，需要通过photoshop或其他工具测量计算每一个背景单元的精确位置在维护的时候比较麻烦，如果页面背景有少许改动，一般就要修改整张合并的图片 @import：引入css样式表 1@import url(CSS文件路径地址); //语法 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 SEO 搜索引擎工作原理： 搜索引擎网站的数据库存储着海量的关键词，每个关键词对应着很多网址，收集这些数据的程序称之为“搜索引擎蜘蛛”或“网络爬虫”。 “爬虫”每天在互联网上分析提炼，找到对用户有用关键词便存入数据库；垃圾或重复信息就舍弃。 用户输入关键词时，搜索引擎就能检索出与关键字相关的网址。关键词又对应多个网址，就出现了排序的问题，与关键词最吻合的网址就会排在前面。 并不是所有语言“爬虫”都能看懂。flash和js它便看不懂，即使关键字再贴切也没用。而网站内容是它的语言(SEO)，它便能看懂。 SEO简介 Search English Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 SEO就是为了提升我们的网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。 白帽SEO起到改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。 黑帽SEO利用和放大搜索引擎政策缺陷来获取更多用户的访问量，大多是欺骗搜索引擎，这是搜索引擎公司是不支持与鼓励的。 白帽SEO怎么做：对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；网站内容优化：内容与关键字的对应，增加关键字的密度；在网站上合理设置Robot.txt文件(保障网络安全与网站隐私，里面规定了哪些不予许“爬虫”搜索)；生成针对搜索引擎友好的网站地图；增加外部链接，到各个网站上宣传； 前端SEO：通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“爬虫”看懂。 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。建立的网站结构层次越少，越容易被“爬虫”抓取； 控制首页链接数量：链接太少会使“爬虫”缺乏往下爬的“桥”，影响收录数量；链接太多，影响用户体验，降低了网站首页权重，效果也不好。尽量让“爬虫”最多跳转3次，就能到达网站内的任何一个内页。 导航优化，尽量采用文字，如果用图片代码一定要添加“alt”和“title”属性(图片未能正常显示时用户也能看到提示)。另外每个网页上应该加上面包屑导航(如新闻&gt;某新闻) 网站的结构：头部——logo及主导航，以及用户的信息；页面主体——一边面包屑导航及正文；一边放热门文章及相关文章，这些相关链接增强了页面相关性，也增强页面的权重；页面底部——版权信息和友情链接；分页写法——“首页 1 2 3 4 5 下拉框”，这样“爬虫”能直接跳转，下拉框直接选择页面；而“首页 下一页 尾页”的写法，当分页数量特别多时，“爬虫”需要经过很多次往下爬，才能抓取，超时容易放弃。 控制页面的大小，减少http请求，提高网站的加载速度。页面最好不要超过100k，太大页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“爬虫”也会离开。 网页代码优化：除了精简代码外还要有以下设置 meta keywords标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌；meta description标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 title标签，强调重点，把重要的关键词放在前面且不要重复出现，每个页面的title标题中不要设置相同的内容；body的标签：代码语义化，适当的位置使用适当的标签。让阅读源码者和“爬虫”都一目了然。比如：h1-h6 是用于标题类的，nav标签是用来设置页面主导航的等。 a标签：页内链接要加 “title” 属性说明，让访客和 “爬虫” 知道。外部链接，则需要加上 el=”nofollow” 属性, 告诉 “爬虫” 不要爬，否则它就不会再回来了；br标签：只用于文本内容的换行；img应使用 “alt” 和”title”属性加以说明 正文标题要用h1标签：“爬虫”认为它最重要，副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签；表格标签用caption strong和em标签：需要强调时使用。strong在搜索引擎中会得到高度重视，它突出关键词表现重要的内容，em强调效果仅次于strong。b和i标签: 只是显示效果，在SEO中不会起任何效果。 文本缩进不要使用特殊符号，应使用CSS进行设置；版权符号不要使用特殊符号，可以直接使用输入法中的版权符号©；对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。搜索引擎会过滤掉display:none中的内容。 巧妙布局，将重要内容的代码放在前面，前面的内容被认为是最重要的，优先让“爬虫”读取，进行内容关键词抓取。 少使用iframe框架,因为“爬虫”一般不会读取其中的内容；重要内容不要用JS输出，因为“爬虫”不认识；js代码如果是操作DOM操作，应尽量放在body结束标签之前，html所有标签之后。 Server-Browser技术 WEB的三要素：直接打开的html文件并没有经过WEB的三要素，正式项目时需要安装环境 Server(服务器) Client(客户端)/Browser(浏览器) HTTP(传输通信)/HTTPS(加密传输) 客户端技术：HTML/CSS/JS和图片等，储存于服务器，供客户端申请下载，在服务器看来他们只是二进制的字符，服务器不会对这些内容做任何处理 服务器端技术：JSP/PHP/ASP.NET，储存于服务器，供客户端进行请求，但返回客户端之前，其中的代码会在服务器端获得执行，得到的结果是纯的静态数据，发送给客户端。 服务器(Server)：是网络环境中的高性能计算机，它侦听网络上的其他客户机提交的服务请求，并提供相应的服务，如”域名解析”、”文件下载”、”网页浏览”、”邮件收发”等等。 要求：高可用性、高速运算、高带宽、高可靠性、强大的数据吞吐能力。 Client-Server模型(C/S模型)：如QQ客户端 Brouser-Server模型(B/S模型)：如谷歌浏览器 随着H5和前端的发展，B/S会部分取代C/S，因为只需要在服务器端更新就可以立即使用最新版 硬件服务器：按大小可以分为工作站、小型机、中型机、大型机、超级计算机。 软件服务器：不论是超级计算机、小型服务器、还是PC机，为了向客户端提供服务，必须安装能够监听特定端口，并接受客户端请求的应用程序–服务器应用程序。根据能投提供的服务的不同，服务器应用程序包括： DNS服务器：把域名解析为计算机的IP地址 Web服务器：提供Web页面服务 数据库服务器：提供数据的永久储存和高效查询 FTP服务器：文件上传和下载服务 SMTP/POP3服务器：邮件收发服务 SSH服务器：远程登录服务 Samba服务器：文件和打印机共享服务 如何访问服务器：客户端访问网络上的一台服务器，必须提供如下信息——访问协议：类似两个人通话必须先确定所说的语言；主机地址：服务器的域名或IP地址；端口号：一台计算机上可能提供多种服务，不同服务使用不同端口；除此之外，有的服务还可能需要客户端提供用户名/密码、资源路径，请求参数等。 配置服务器环境 AMP–集成了Apache, PHP5, 和MySQL 浏览器服务器文件localhost/文件.txt，这种方式和用路径在浏览器上打开的方式是不同的，前者是在服务器上 很多东西必须在服务器上运行，如cookie和ajax等 超文本传输协议(HTTP，HyperText Transfer Protocol) HTTP协议是互联网应用最为广泛的一种网络协议。设计它的最初目的是为了提供一种发布和接收HTML页面的方法。 只要上网就要用到它，比如我们登录百度页面就要使用HTTP请求百度页面的数据，同时要遵守HTTP协议的语法和规则。 HTTP是两台电脑(服务器和客户端)之间的通讯，客户端发起请求(通常是用域名)，服务器响应请求(发送页面数据)。 下面是客户端和服务器在发起HTTP协议时的详细过程： 第一步，先建立服务器和客户端的TCP的握手。 第二步，客户端向服务器发出文本数据，如：POST //发送请求的方法；index.html //请求的页面；HTTP/1.1 //HTTP的版本 还有请求的报头和它的值如：HOST: www.baidu.com //域名；Connection: //服务器发送数据后的链接状态；User_agent: Mozilla/4.0 //浏览器；Accept-language: zh-CN //语言 以及报体(get请求不需要报体)，如：Name=unknow&amp;age=22 //内容 第三步，服务器响应结果：HTTP/1.1 //HTTP的版本；200 ok //状态码和文本描述 以及响应的报头和它的值如：Server: Apache-Coyote/1.1 //域名；Last-Modified: Thu， 24 Nov 2011 12::22:00 GMT //最后修改时间；Content_Type: text/html;charset=GB18030 //使用的字符集；Content-Language: zh-CN//语言；Content-Length: 23980 //内容大小；Date: Fri, 25 Nov 2011 07:22:02 GMT //时间 最后空一行之后是它的报体(html页面)：…… HTTP详解：https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html 上传一个网站 我们需要一个网上的服务器(需要花钱租用，比如西部数码、阿里云、腾讯云等等) 准备一个网站项目，并用FTP软件将它上传到该服务器上 在FTP软件的快速连接里输入服务器的地址，并通过用户名和密码连接到服务器上，然后上传你的项目 准备一个自己的域名，并将其绑在我们的服务器上，这样在互联网上打开该域名就会自动打开项目中的index.html了 个人网站也是需要备案的，这里是个人网站详细的备案过程]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级-八、VIM程序编辑器]]></title>
    <url>%2F2019%2F07%2F18%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AB%E3%80%81VIM%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[八、VIM程序编辑器 作用：是一种打开文本文件的程序，可以编辑改文件已达到配置服务的功能 分类： (1) vi ：任意版本的Linux自带的程序编辑器 (2) vim ：是vi程序编辑器的加强版，通过附加一系列功能（如：字体、字体颜色、扩展接口等）帮助运维人员更好的配置服务 注意：vim若在最小化镜像安装系统时不会安装，可以使用：yum install -y vim 命令进行安装 打开文件方法： (1) 格式：vim 格式名 (2) 若文件已存在直接打开，若不存在会新建文件后打开 vim 的三种模式： (1) 命令模式：又称为只读模式，在该模式可以进行光标移动，查看等动作 (2) 插入模式：编辑模式，插入、删除等内容 (3) 末行模式：保存、退出、设置编辑环境 (4) 模式切换： ​ A. 命令模式点击“i”键进入插入模式，插入模式点击“ESC”键返回到命令模式，命令模式下单击shirt : 进入末行模式，末行模式点击ESC键返回命令模式 ​ B. 图： 命令模式： (1) 常用功能键： ​ A. yy ：复制本行 ​ B. 5yy ：复制5行 ​ C. p ：粘贴 ​ D. dd ：删除当前行 ​ E. 3dd ：删除3行 ​ F. /字符串：由上到下搜索字符串 ​ G. ?字符串：由下向上搜索字符串 ​ H. n ：显示搜索定位到下一个字符串 ​ I. N：显示搜索定位到下一个字符串 ​ J. u ：撤销上一步动作 (2) 配置主机名： ​ A. 主机名：Linux主机在网络上显示的名称，应“见名知意” ​ B. 配置文件：/etc/hostname ​ C. 显示主机名命令：hostname ​ D. 编辑主机名： ​ (a) vim /etc/hostname ​ (b) 删除旧主机名后插入新主机名 ​ (c) 保存退出 ​ (d) reboot重启 (3) 配置网卡的静态IP地址： ​ A. vim /etc/sysconfig/network-scriipts/ifcfg-ens33 ​ B. 点击 i 键 ​ C.BOOTPROTO=static ：网卡类型为静态IP，动态IP为dhcp ​ D. 在最后一行插入以下内容： ​ IPADDR=192.168.10.200 （IP地址） ​ NETMASK=255.255.255.0 （子网掩码） ​ GATEWAY=192.168.10.1 （网关地址） ​ DNS1=8.8.8.8 （域名解析服务器地址） ​ E. 保存退出 ​ F. 重启网卡：service network restart ​ G. 查看网卡：ip addr 末行模式： (1) 功能命令 ​ A. 进入方法：shirt : ​ B. w ：保存 ​ C. q ：退出 ​ D. q! ：强制退出，不保存 ​ E. wq! ：强制保存退出 ​ F. set nu ：增加行号 ​ G. set nonu ：取消行号 ​ H. 数字：跳转到指定数字行 (2) 注意：大部分配置文件都需要root权限，否则无法保存 vim异常处理： (1) 制作异常环境： ​ A. cp /etc/fstab /root ​ B. vim /root/fstab ​ C. 点击dd删除某行 ​ D. 点击ctrl z ，强制终止进程 ​ E. vim /root/fstab 会有警告信息 (2) 处理流程： ​ A. 点击 R 进行恢复 ​ B. 点击shirt: 正常保存退出 ​ C. ls -a root 查看同名的隐藏缓存文件 ​ D. rm -f /root/.fstab.swp 删除同名缓存文件 ​ E. vim /root/fstab 正常打开 (3) 原理： ​ A. 原因1：可能有其他人或程序同时在编辑该文件 ​ B. 原因2：上一个vim环境中，可能因为某些不知名原因导致vim中断(crashed) shell脚本简介： (1) 本质：是一种纯文本的批处理文件 (2) 意义： ​ A. 自动化管理：批处理方式执行，降低维护工作量及难度 ​ B. 记录和管理系统工作：服务启动等功能 ​ C. 简单的入侵检测：通过编写脚本自动检测系统日志 ​ D. 简单数据处理：数据计算及分析 (3) 创建简单的脚本 ​ A. 方法：vim 脚本文件 ​ B. 脚本扩展名：.sh ​ C. 脚本执行过程： ​ (a) 由上到下、由左到右分析执行 ​ (b) 以行为单位进行执行，空行跳过 ​ (c) 命令过长时使用\enter进行换行编写 ​ (d) 以#开头的为注释命令，其只起到增加理解的功能，不执行 ​ D. 内容分析： ​ (a) 注释：# !/bin/bash ：表示该脚本使用的shell名称，不能省略 ​ # 脚本类别 ​ # 脚本功能简述 ​ # History ​ # 脚本编辑日期 作者 版本号等 ​ (b) 命令语句 (4) 执行脚本： ​ A. 方法1：bash 脚本名.sh ​ B. 方法2：chmod a+x 脚本名.sh ​ （增加权限如：chmod a+x /root/hello.sh） ​ ./脚本名.sh, (5) 注意：shell scripts在系统管理及自动化执行上作用很大，但是在数据处理应用上能力有限（如：bash的运算式只识别整数的运算），且运算的速度较慢CPU占用率较大，会造成主机资源负载较高 (6) 黑客帝国屏保代码： 123456789101112#!/bin/bash#program# install cmatrix#history# 2019-7-22 14:29 andy Version 1.0wget http://archive.ubuntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orig.tar.gztar xvf cmatrix_1.2a.orig.tar.gzcd cmatrix-1.2ayum install -y gccyum install -y ncurses-devel./configure &amp;&amp; make &amp;&amp; make installecho &quot;Program installation complete !&quot;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 七、RAID 与 LVM]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%83%E3%80%81RAID-%E4%B8%8E-LVM%2F</url>
    <content type="text"><![CDATA[七、RAID 与 LVM RAID (1) RAID : Redundant Array of Independent Disks，磁盘冗余阵列 (2) RAID意义：通过增肌多个硬盘，形成独立的硬盘组，将数据划分成多份，分散存储，以提高硬盘读写效率 (3) RAID本质：防止硬盘物理损坏及增加存储设备吞吐量 (4) 分类： ​ A. RAID0 ​ (a) 意义：原理：把至少2块硬盘通过硬件或软件方式串联，组成一个大的卷组，并将数据依次写入到各个硬盘中 ​ (b) 优点：数据同步传输，读取/写入分开，性能大大提升 ​ (c) 缺点：若任意一块硬盘故障会导致整个系统的数据损坏，无备份冗余能力、错误修复能力 ​ (d) 总结：使用率100%，至少2块硬盘才能使用，优点是快，提升磁盘的读写速度，缺点是不安全 ​ (e) 结构图： ​ ​ B. RAID1： ​ (a) 产生原因：若生产环境对硬盘的读写速度没有较大要求，但希望增加数据安全性时可使用RAID1 ​ (b) 原理：将至少2块硬盘并联起来，写入数据时，同时写入，多个硬盘内容相同 ​ (c) 本质：多个硬盘的镜像备份 ​ (d) 优点：备份冗余数据，安全性大大提升 ​ (e) 缺点： 硬盘利用率下降 ​ (f) 总结：本质是镜像，使用两块磁盘，一式两份的方式，支持容错，冗余，数据安全不丢失，缺点是速度不快，使用率50%，成本较大 ​ (g) 结构图： ​ ​ C. RAID5: ​ (a) 产生原因：兼顾“读写速度”、“数据安全”、“成本”的一种折中方式 ​ (b) 原理：需至少3块硬盘，将数据分块存储到不同硬盘中，硬盘中必须存储其他一个硬盘的parity（奇偶校验信息） ​ (c) 优点：兼顾性能，通过“奇偶校验”替代“镜像备份” ​ (d) 缺点：硬盘数据安全性较低 ​ (e) 总结：使用率(n-1)/n*容量，磁盘坏了会立即补上，数据会恢复 ​ (f) 结构图： ​ ​ D.RAID10：（主流） ​ (a) 原理：至少需要4块硬盘，先制作两两的RAID1阵列，以保证安全性，在两两制作RAID0，以提高读写速度 ​ (b) 本质：RAID1+RAID0的组合 ​ (c) 优点：兼具速度和安全性 ​ (d) 缺点：成本较高 ​ (e) 结构图： ​ (5) mdadm命令： ​ A. 过程： ​ (a) 关机添加4个新硬盘 ​ (b) mdadm命令建立RAID10 ​ (c) 格式化 ​ (d) 建立挂载目录 ​ (e) 挂载 ​ (f) 开机挂载 ​ (g) 查看信息 ​ B. mdadm命令格式： ​ mdadm -参数 &lt;RAID 设备名&gt; [模式] [成员设备名称] ​ C. 作用：建立或管理RAID ​ D. 参数： ​ (a) -a ：检测设备名称 ​ (b) -C ：创建RAID ​ (c) -v ：显示过程 ​ (d) -l ：指定RAID级别 ​ (e) -n ：指定硬盘数量 ​ (f) -f ：模拟设备损坏 ​ (g) -D ：查看详细信息 ​ (h) -r ：移除设备 ​ (i) -Q ：查看摘要 ​ (j) -S ：停止RAID磁盘阵列 ​ E. 例：添加4块硬盘，创建RAID10 ​ (a) 创建RAID10： mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde ​ -Cv ：创建RAID并显示过程 ​ -a yes ：检测创建设备名 ​ -n 4 ：4块硬盘参与建立 ​ -l 10 ：RAID级别为10 ​ (b) 格式化：mkfs.xfs /dev/md0 ​ (c) 建立挂载目录：mkdir /mnt/raiddev ​ (d) 挂载：mount /dev/md0 /mnt/raiddev ​ (e) 开机挂载设置：vim /etc/fstab ​ 增加行： /dev/md0 /mnt/raiddev xfs defaults 0 0 ​ (f) 开机挂载检测：mount -a ​ (g) 查看RAID10信息：mdadm -D /dev/md0 ​ F. 模拟硬盘损坏的处理流程 ​ (a) 模拟损坏：mdadm /dev/md0 -f /dev/sdb ​ (b) 查看信息：mdadm -D /dev/md0 ​ (c) 关机，添加新硬盘 ​ (d) 卸载RAID：umount /dev/md0 ​ (e) RAID补上新硬盘：mdadm /dev/md0 -a /dev/sdf ​ (f) 重启：reboot ​ (g) 查看信息：mdadm -D /dev/md0 ​ (h) 注意：添加新硬盘时必须先卸载 ​ G. 停止RAID ​ (a) 注意：在实际工作中，停止RAID前必须备份其中数据，否则数据会全部丢失 ​ (b) 过程： ​ ◆ 卸载设备：umount /dev/md0 ​ ◆ 删除开机挂载配置文件中RAID的记录 ​ ◆ 停止RAID：mdadm -S /dev/md ​ H. RAID 10备份盘功能 ​ (a) 产生原因：在RAID1中，某块硬盘损坏，在手工修复成功前另一块硬盘也同时损坏，则整个数据会全部丢失 ​ (b) 原理：在RAID10中再添加一块硬盘，作为备份盘，一旦某硬盘损坏，会自动修复 ​ (c) RAID共需5块硬盘（4个数据盘，1个备份盘） ​ (d) 方法： ​ ◆ 新建RAID10+备份盘：mdadm -Cv /dev/md1 -a yes -n 4 -l 10 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf ​ （-x 1 ：表示备份盘，1块硬盘） ​ （一般最后一块硬盘/dev/sdf 为备份盘，习惯放置在最后） ​ ◆ 查看信息摘要：mdadm -D /dev/md1 ​ ◆ 模拟某硬盘损坏：mdadm /dev/md1 -f /dev/sdb ​ ◆ 重启系统：reboot ​ ◆ 再次查看信息摘要：mdadm -D /dev/md1 ，备份盘/dev/sdf已替换故障硬盘 LVM（逻辑卷管理器） (1) 产生原因：由于硬盘分区并设置为RAID后，对其空间调整并不容易，此时用户随着实际的需求变化而动态调整硬盘分区大小时受到限制，无灵活性 (2) LVM作用：允许用户动态调整磁盘空间大小 (3) 原理：LVM是在磁盘分区与文件系统之间添加逻辑层，以提供一个抽象的卷组，使管理者可以忽略底层磁盘布局，从而实现对分区的灵活动态调整 (4) 分析： ​ A. 图： ​ ​ B. 物理卷（PV, Physical Volume）：整个硬盘或分区 ​ C. 卷组（VG, Volume Group）：由一个或多个物理卷（PV）组成的整体 ​ D. 逻辑卷（LV, Logical Volume）：从卷组（VG）切割出的空间，用于创建文件系统，大小由PE的个数决定 ​ E. 基本单元（PE, Physical Extent）：默认为4MB的基本块 (5) 基本命令： ​ (6) 硬盘支持LVM的流程： ​ A. 将新硬盘支持物理卷技术 ​ B. 创建卷组，将新硬盘加入卷组 ​ C. 根据需求切割出指定容量的逻辑卷 ​ D. 格式化逻辑卷 ​ E. 创建挂载目录 ​ F. 添加开机挂载信息 ​ G. 挂载测试 ​ H. 重启系统 (7) 例：在虚拟机中添加2块新硬盘，创建物理卷及卷组，划分出150MB空间的逻辑卷并格式化挂载使用 ​ A. 新建物理卷：pvcreate /dev/sdb /dev/sdc ​ B. 新建卷组：vgcreate /dev/vg1 /dev/sdb /dev/sdc ​ C. 查看卷组信息：vgdisplay /dev/vg1 ​ D. 切割150MB逻辑卷：lvcreate -n lv1 -L 150MB /dev/vg1 ​ (a) -n ：新建逻辑卷 ​ (b) -L：逻辑卷的容量，单位为数据量（K M G） ​ E. 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ F. 格式化逻辑卷：mkfs.xfs /dev/vg1/lv1 ​ G. 建立挂载点：mkdir /mnt/lvdev ​ H. 编辑开机挂载文件：vim /etc/fstab 增加下列记录： ​ /dev/vg1/lv1 /mnt/lvdev xfs defaults 0 0 ​ I. 挂载测试：mount -a (8) 例：添加2块新硬盘，建立卷组，划分出200MB空间的逻辑卷并格式化挂载使用 ​ A. pvcreate /dev/sdd /dev/sde ​ B. vgcreate /dev/vg2 /dev/sdd /dev/sde ​ C. vgdisplay /dev/vg2 ​ D. lvcreate -n lv2 -l 50 /dev/vg2 ​ (a) lv2的路径：/dev/vg2/lv2 ​ (b) -l ：表示以PE物理卷基本存储单位4MB为单位划分，给出4MB的倍数，50表示PE个数（50*4MB） ​ E. lvdisplay /dev/vg2/lv2 ​ F. mkfs.xfs /dev/vg2/lv2 ​ G. mkdir /mnt/lvdev2 ​ H. vim /etc/fstab 增加下列记录： ​ /dev/vg2/lv2 /mnt/lvdev2 xfs defaults 0 0 ​ I. mount -a (9) 逻辑卷扩容 ​ A. 作用：根据实际需要扩大逻辑卷的存储容量 ​ B. 过程： ​ (a) 卸载逻辑卷 ​ (b) 扩容逻辑卷 ​ (c) 再次格式化 ​ (d) 挂载 ​ (e) 查看信息 ​ C. 例1：对上例lv1逻辑卷扩容到495MB ​ (a) 卸载：umount /dev/vg1/lv1 ​ (b) 查看卷组容量是否足够：vgdisplay /dev/vg1 ​ (c) 扩容：lvextend -L 495MB /dev/vg1/lv1 ​ (d) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (e) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (f) 查看逻辑卷信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：对上例lv2逻辑卷扩容到800MB ​ (a) umount /dev/vg2/lv2 ​ (b) vgdisplay /dev/vg2 ​ (c) lvextend -l 200 /dev/vg2/lv2 ​ (d) mkfs.xfs -f /dev/vg2/lv2 ​ (e) mount -a ​ (f) lvdisplay /dev/vg2/lv2 ​ E. 注意 ​ (a) 扩容或缩容之前必须先卸载设备 ​ (b) 扩容后的逻辑卷必须格式化，否则挂载后显示逻辑卷容量不变 (10) 逻辑卷缩容 ​ A. 注意 ​ (a) 逻辑卷缩容相对扩容来说会有数据丢失的风险，则缩容之前应备份数据 ​ (b) 对逻辑卷缩容之前应对逻辑卷进行数据完整性检查，以保证数据正确性、完整性 ​ (c) 逻辑卷缩容之前必须卸载设备 ​ B. 过程 ​ (a) 查看逻辑卷使用量及剩余量 ​ (b) 卸载设备 ​ (c) 逻辑卷数据完整性检查 ​ (d) 缩容逻辑卷 ​ (e) 格式化逻辑卷 ​ (f) 挂载逻辑卷 ​ (g) 查看逻辑卷信息 ​ C. 例：将上列lv1逻辑卷缩容到320MB ​ (a) 查看lv使用量：df -h /dev/vg1/lv1 ​ (b) 卸载设备：umount /dev/vg1/lv1 ​ (c) 对lv进行完整性检查：xfs_repair -n /dev/vg1/lv1 ​ (d) 缩容：lvreduce -L 320MB /dev/vg1/lv1 ，输入y确认 ​ (e) 再次格式化：mkfs.xfs -f /dev/vg1/lv1 ​ (f) 挂载：mount /dev/vg1/lv1 /mnt/lvdev ​ (g) 查看lv信息：lvdisplay /dev/vg1/lv1 ​ D. 例2：将上例lv2逻辑卷缩容到440MB ​ (a) df -h /dev/vg2/lv2 ​ (b) umount /dev/vg2/lv2 ​ (c) xfs_repair -n /dev/vg2/lv2 ​ (d) lvreduce -l 110 /dev/vg2/lv2 ，输入y确认 ​ (e) mkfs.xfs -f /dev/vg2/lv2 ​ (f) mount -a ​ (g) lvdisplay /dev/vg2/lv2 (11) 删除LVM ​ A. 删除顺序：逻辑卷-&gt;卷组-&gt;物理卷 ​ B. 注意： ​ (a) 删除时，上述顺序不能反向 ​ (b) 删除时，需要输入“y”来确认操作 ​ (c) 删除时，备份卷一同被删除 ​ (d) 删除之前必须先备份数据 ​ C. 过程 ​ (a) 卸载设备 ​ (b) 删除开机挂载记录信息 ​ (c) 删除逻辑卷 ​ (d) 删除卷组 ​ (e) 删除物理卷（去掉硬盘的物理卷技术支持） ​ (f) 查看卷信息是否还存在 ​ D. 例1：删除上例 lv1、 vg1 及物理卷技术 ​ (a) 卸载设备：umount /dev/vg1/lv1 ​ (b) 删除lv1开机挂载记录：vim /etc/fstab 删除其记录项 ​ (c) 删除逻辑卷：lvremove /dev/vg1/lv1 ，输入y确认 ​ (d) 删除卷组：vgremove /dev/vg1 ​ (e) 删除物理卷：pvremove /dev/sdb /dev/sdc ​ (f) 查看信息：lvdisplay vgdisplay pvdisplay （分别执行） ​ E. 例2：删除上例 lv2、vg2及物理卷技术 ​ (a) umount /dev/vg2/lv2 ​ (b) vim /etc/fstab ​ (c) lvremove /dev/vg2/lv2 ，输入y确定 ​ (d) vgremove /dev/vg2 ​ (e) premove /dev/sdd /dev/sde (12) 逻辑卷快照功能 ​ A. 作用：类似于虚拟机软件的“快照”，可以通过快照还原点进行还原，起到备份功能 ​ B. 注意： ​ (a) 快照卷的容量必须等于逻辑卷的容量 ​ (b) 快照卷只能恢复一次，恢复后会自动删除 ​ C. 过程： ​ (a) 查看卷组剩余容量是否足够 ​ (b) 查看被制作快照的逻辑卷容量 ​ (c) 制作快照卷 ​ (d) 查看快照卷 ​ (e) 测试恢复快照卷 ​ D. 例：创建 lv 逻辑卷，制作快照卷 ​ (a) 创建物理卷：pvcreate /dev/sdb ​ (b) 创建卷组：vgcreate /dev/vg ​ (c) 创建逻辑卷：lvcreate -n /dev/vg/lv -L 200MB /dev/vg ​ (d) 格式化：mkfs.xfs /dev/vg/lv ​ (e) 建立挂载点：mkdir /mnt/lvdev ​ (f) 挂载：mount /dev/vg/lv /mnt/lvdev ​ (g) 添加点文件：touch t1.txt ​ (h) 制作 lv 的快照卷：lvcreate -L 200MB -s -n SNAP /dev/vg/lv ​ (i) 进入逻辑卷：cd /mnt/lvdev ​ (j) 新建大文件：dd if=/dev/zero of=loop count=1 bs=10M ​ (k) 浏览文件：ls ​ (l) 退出挂载点：cd / ​ (m) 卸载设备：umount /mnt/lvdev ​ (n) 快照卷恢复：lvconvert –merge /dev/vg/SNAP ​ (o) 挂载设备：mount /dev/vg/lv /mnt/lvdev ​ (p) 进入逻辑卷查看文件是否存在：cd /mnt/lvdev ​ ls]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 六、磁盘管理]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%85%AD%E3%80%81%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[六、磁盘管理 磁盘基础知识 (1) 概念：使用一片或多片带有磁性的铝合金制的盘片构成的外部存储介质 (2) 物理结构 ​ A. 盘体 ​ B. 磁头 ​ C. 马达驱动 ​ D. 缓存 ​ E. SATA3接口 ​ F. 电路板 (3) 逻辑结构 ​ A. 磁道：同心圆 ​ B. 扇区 ​ C. 柱面 (4) 硬盘参数 ​ A. 容量：1-4TB ​ B. 转速：7200转/分 5400RPM ​ C. 缓存：64MB-256MB ​ D. 接口：SATA3 / SCSI (5) 分区 ​ A. 主分区：系统启动区 ​ B. 扩展分区 ​ C. 逻辑分区：基于扩展分区继续划分 分区模式 (1) MBR（主引导记录区模式） ​ A. 组成 ​ (a) MBR位于磁盘第0磁道第0柱面第1扇区 ​ (b) MBR总容量：446B ​ (c) 磁盘分区表（DPT）：64B ​ (d) 最后有2B（55 AA）为分区结束标志 ​ (e) MBR所占扇区为512B ​ B. 作用：MBR包含硬盘一系列参数和一段引导程序，引导程序是检查分区表是否正确并且在系统硬件完成自检后引导具有激活标志的分区上的操作系统（C盘），并将控制权交给启动程序 ​ C. MBR分区原则 ​ (a) 主分区+扩展分区最多4个 ​ (b) 扩展分区最多1个 ​ (c) 扩展分区基础上再次划分逻辑分区 ​ (d) 扩展分区不能格式化 ​ (e) 一般会划分3个主分区+1个扩展分区 ​ (f) 主分区（P） 扩展分区（E） 逻辑分区（L） ​ (g) 推荐剩余一些自由空间以方便分区空间扩容 (2) GPT ​ A. 产生原因 ​ (a) MBR分区格式最大支持2.2TB硬盘 ​ (b) 没有备份机制，若分区表损坏则会丢失整个硬盘内容 ​ (c) MBR存储空间较小，只有446B，无法存储叫多功能数据 ​ B. 方法 ​ (a) 使用LBA（逻辑地址区块）的结构存储分区信息 ​ (b) 共可分为68个LBA块，前34个LBA存储分区信息，后43个LBA块存储备份信息 ​ C. GPT分区格式不再区分主分区及扩展分区，共可分128个主分区 ​ D. GPT分区格式与MDR分区格式不兼容，不能混合使用 文件系统 (1) 意义：若空白硬盘相当于一张白纸，分区就是对其进行“裁切”，对分区进行方格划分就是对其进行建立文件系统，即格式化 (2) 常见文件系统格式：ext2 ext3 ext4 xfs msdos (3) ext2文件系统 ​ A. 组成： ​ (a) super block （超级块） ​ (b) inode （索引块） ​ (c) block （数据块） ​ B. 超级块：又称为硬盘地图，记录文件系统的整体信息，如：inode/block块的总量、使用量、空间块量、文件系统格式等相关信息 ​ C. inode块：记录文件属性，一个文件占用一个inode块，并且记录文件数据所在的block块的地址，默认为128B ​ D. block ：存储文件数据，大小为1KB 2KB 4KB，大文件会占用多个数据块 ​ E. 装入方式：将文件的数据块链式的不连续的装入硬盘中 ​ F. ext2文件系统支持 Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB ​ (4) Centos7系统默认文件系统为xfs ​ (5) df命令： ​ A. 格式：df 参数 目录/文件名 ​ B. 作用：列出文件系统的磁盘使用量 ​ C. 参数： ​ (a) -a ：列出所有文件系统 ​ (b) -h ：以容量理解的方式列出信息（GB MB KB） ​ D. 常见：df -ah ​ (6) du命令： ​ A. 格式：du -参数 文件或目录名 ​ B. 作用：查看文件或目录占用硬盘容量 ​ C. 参数： ​ (a) -a ：列出所有文件与目录信息 ​ (b) -h ：以容易理解的方式列出信息（GB MB KB） ​ (c) -s ：列出总量 ​ D. 注意：df命令检测速度较快 硬件设备命名原则 (1) 硬盘 ​ A. 以sd开头后跟a-p表示16块硬盘编号，即sd[a-p] ​ B. 在MBR分区格式中由于主分区+扩展分区最多4个，则编号为1-4，第一个逻辑分区从5开始编号，即使主分区编号未使用，逻辑分区也不能使用 ​ C. 硬盘名称格式：sd[a-p]数字 ​ D. 例：sda1 第一块硬盘的第1个主分区 ​ sdb5 第二块硬盘的第1个逻辑分区 ​ E. 例：PPELL ​ (a) P:sda1 ​ (b) P:sda2 ​ (c) E:sda3 ​ (d) L:sda5 ​ (e) L:sda6 ​ F. 模式： ​ (a) PE ​ (b) PPE ​ (c) PPPE ​ (d) PPPP (2) 光驱：/dev/sr0 (3) 鼠标：/dev/mouse (4) 打印机：/dev/lp[1-15] 添加新硬盘 (1) 方法：关闭系统-&gt;编辑虚拟机设置-&gt;添加-&gt;硬盘-&gt;磁盘类型：SCSI（推荐）-&gt;创建新的虚拟磁盘-&gt;磁盘大小：20GB，存储为单个文件-&gt;默认名称-&gt;完成 (2) 注意：添加的新硬盘必须在关机情况下进行，必须保证新硬盘文件名不能重名 硬盘分区 (1) 检测硬盘分区的类型 ​ A. 格式：parted 设备名 print ​ B. 例：parted /dev/sda print ​ C. 查看Prtition Table:msdos，分区表类型，若为msdos说明使用的为MBR分区格式，就不能使用GPT分区格式命令进行继续分区，否则已有数据会丢失 (2) fdisk分区 ​ A. 规划：规划分区个数、容量、类型 ​ B. 注意：fdisk为MBR分区格式命令 ​ C. 分区功能 ​ (a) n：新建分区 ​ (b) p：查看分区列表 ​ (c) d：删除分区 ​ (d) w：保存分区并退出 ​ (e) m：查看帮助 ​ (f) l ：查看可分区的类型 ​ D. 过程： ​ (a) 分析： ​ ◆ 目标：dev/sdc ​ ◆ 个数：3个分区 ​ ◆ 类型：2P 1E 1L ​ ◆ 容量：5G 5G 剩余 ​ (b)fdisk /dev/sdc ​ ◆ command ：输入分区命令为n（新建） ​ ◆ partition type ：分区类型，p（主分区），e（扩展分区），l（逻辑分区） ​ ◆ partition number ：分区编号，回车默认 ​ ◆ First Sector ：起始扇区编号，回车默认 ​ ◆ last sector ：终止扇区编号，输入：+5G，回车 ​ ◆ 剩余同上 ​ ◆ 输入p查看分区列表，输入w保存同步磁盘并退出 ​ E. 删除分区 ​ (a) 分区向导中输入d ​ (b) 正向新建分区，反向删除分区 ​ F. 注意：若无法查看分区结果列表，则表示分区信息还未写入内核（常见情况），输入“partprobe”命令进行手动将分区信息同步到内核，再不行就重启 ​ (2) lsblk命令 ​ A. 格式：lsblk -参数 /dev/sd? ​ B. 作用：查看磁盘分区信息 ​ (3) blkid命令 ​ A. 格式：blkid -参数 /dev/sd? ​ B. 作用：查看磁盘ID信息 ​ C. 常用：blkid ​ (4) gdisk分区 ​ A. 注意：对于同一硬盘，fdisk和gdisk不能混用 ​ B. 格式：gdisk /dev/sd? ​ C. 过程： ​ (a) gdisk /dev/sdd ​ (b) partition table scan ：扫描分区类型是否已存在 ​ (c) Command(? for help) ：新建（n） 删除（d） 查看列表（p） 保存（w） ​ (d) partirion number(1-128, default 1)：设置分区编号，回车即可 ​ (e) First sector：设置起始扇区值，默认，回车即可 ​ (f) Last sector：设置终止扇区值，输入分区容量，如：+5G ​ (g) Hex code or GUID(L to show code,Enter = 8300) ：设置分区文件系统的ID，回车即可 格式化 (1) 意义：对分区或其他设备建立文件系统 (2) 查看分区命令及类型：输入mkfs后2次tab键 (3) mkfs.xfs命令： ​ A. 格式：mkfs.xfs -参数 设备名 ​ B. 作用：对磁盘分区或文件进行xfs类型格式化 ​ C. 参数： ​ (a) -f ：强制格式化，已有文件系统需要使用此参数 ​ (b) -b ：后跟上block容量，范围512B-64KB，注意，Linux限制为4KB ​ D. 例：对/dev/sdc 进行xfs格式化 ​ mkfs.xfs /dev/sdc1 ​ mkfs.xfs /dev/sdc2 (4) mkfs.ext4命令： ​ A. 格式：mkfs.ext4 -参数 设备名 ​ B. 参数：-b ：设定block大小，如：1KB 2KB 3KB 4KB 挂载 (1) 意义：建立文件目录，通过设置该目录与分区的关系，以进入分区 (2) 挂载点：进入分区的目录称为挂载点 (3) 挂载前的注意事项 ​ A. 单一文件系统不应该被重复挂载在不同的挂载点（目录）中 ​ B. 单一目录不应该重复挂载多个文件系统 ​ C. 作为挂载点的目录，应为空目录，否则原有数据会隐藏 (4) mount目录 ​ A. 格式：mount -参数 设备名 挂载点目录 ​ B. 作用：将分区挂载挂载到指定文件目录上 ​ C. 参数： ​ (a) -a ：按照挂载配置文件/etc/fstab对未挂载的设备全部进行挂载 ​ (b) -t ：指定文件系统，不常用，一般系统会自动判断文件系统类型 ​ D. 例：建立挂载目录，挂载/dev/sdc的分区 ​ mkdir /mnt/m1 /mnt/m2 /mnt/m5 /mnt/m6 ​ mount /dev/sdc1 /mnt/m1 ​ mount /dev/sdc2 /mnt/m2 ​ mount /dev/sdc5 /mnt/m5 ​ mount /dev/sdc6 /mnt/m6 ​ E. 挂载光盘 ​ (a) 光盘名称：/dev/sr0 或 /dev/cdrom ​ (b) 方法：mount /dev//sr0 /media ​ (c) 注意：光盘为只读属性，只能以只读方式挂载 卸载 (1) mount命令： ​ A. 格式：umount -参数 设备名称或挂载点目录名 ​ B. 作用：卸载设备 ​ C. 参数： ​ (a) -f ：强制卸载 ​ (b) -l ：立刻卸载文件系统，比-f还强 ​ (c) -n ：不更新/etc/mtab情况下卸载 ​ D. 例：卸载/dev/sdc ​ umount /dev/sdc1 ​ umount /dev/sdc1 ​ umount /mnt/m5 ​ umount /mnt/m6 ​ E. 注意：卸载时应cd离开挂载点目录，否则文件系统忙，无法卸载 开机挂载 (1) 产生原因：手动挂载后系统重启会自动卸载，应设置开机挂载使其永久生效 (2) 配置文件：/etc/fstab (3) 配置文件分析 ​ A. 共6列 ​ B. 内容： ​ 设备名 挂载点目录 文件系统 defaults 0 0 ​ /dev/sdc1 /mnt/m1 xfs defaults 0 0 ​ C. defaults ：文件系统参数为默认 ​ D. 0 ：是否备份 ​ E. 0 ：开机是否用fsck进行扇区检查，但xfs文件系统不支持则为0 (4) fstab配置完毕后使用：mount -a 完成检测 再重启 (5) 使用lsblk命令查看是否开机挂载成功 (6) 注意： ​ A. 根目录/ 是必须挂载的，而且一定要先于其他mount point被挂载 ​ B. 其他mount point必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则（FHS） ​ C. 配置完毕后必须使用mount -a检测，否则系统启动失败 挂载大文件 (1) 产生原因：由于无自由分区空间，需要添加新分区时，可以对某个已存在的分区的剩余空间制作一个大文件，对其进行格式化挂载当做一个新的分区使用，从而实现不添加新的硬件而增加新分区 (2) 步骤：制作大文件-&gt;格式化-&gt;开机挂载 (3) 方法：例：对/dev/sdc6的剩余空间制作3G大文件进行挂载 ​ A. cd /mnt/m6 ​ B. df /mnt/m6 ​ C. dd if=dev/zero of=/mnt/m6/loopdisk bs=1G count=3 ​ （制作3G的大文件） ​ D. start /mnt/m6/loopdisk （查看文件属性） ​ E. mkfs.xfs -f loopdisk （格式化） ​ F. mkdir /mnt/loopdev （建立大文件挂载点目录） ​ G. mount -o loop /mnt/m6/loopdisk /mnt/loopdev ​ （挂载大文件，需要加 -o loop 参数） ​ H. 开机挂载设置 ​ (a) vim /etc/fstab ​ (b) 插入如下内容： ​ /mnt/m6/loopdisk /mnt/loopdev xfs defaults 0 0 ​ (c) 保存退出 ​ (d) mount -a （进行检测） ​ (e) reboot （重启） 增加swap交换分区 (1) 过程 ​ A. 成新划分一个分区 ​ B. 格式化分区 ​ C. 启用新的swap ​ D. 查看系统信息 ​ E. 开机挂载 (2) 例：对/dev/sdb 新建2G分区空间，对其格式化并生效为swap 空间 ​ A. fdisk /dev/sdb ​ B. mkswap /dev/sdb6 ​ C. swapon /dev/sdb6 ​ D. free -h ​ E. vim /etc/fstab ，输入以下内容： ​ /dev/sdb6 swap swap defaults 0 0 ​ F. mount -a ​ G. reboot （重启） ​ H. free -h （检测） 13.制作大文件生成swap ​ (1) 过程 ​ A. 查看分区 ​ B. 制作大文件 ​ C. 格式化 ​ D. 开机挂载 ​ E. 查看swap信息 ​ (2) 方法 ​ A. cd /mnt/m5 ​ B. dd if=/dev/zero of=swaploop bs=512MB count=1 ​ C. mkswap /mnt/m5/swaploop （格式化为虚拟内存） ​ D. swapon /mnt/m5/swaploop （生效） ​ E. vim /etc/fstab ，插入如下内容： ​ /mnt/m5/swaploop swap swap defaults 0 0 ​ F. mount -a ​ G. reboot]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 五、用户账户及权限]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%94%E3%80%81%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[三、用户账户及权限 用户账户及身份 (1) UUID值 ​ A. 作用：User Identification，系统为每一个账户都分配了一个 唯一的编号（身份证号），具有唯一性，账户的权限来源 于 UUID值 ​ B. 分类： ​ (a) 超级管理员root：0 ​ (b) 系统用户UUID：1-999，系统为每一个服务都分配一个账户，防止某个服务程序出现漏洞，从而被黑客提权至整个服务器，每个服务程序都由一个账户负责，控制破坏范围 ​ (c) 普通账户：从1000开始，由root创建，用于日常维护 ​ C. 特点： ​ (a) UUID值不能相同 ​ (b) 系统账户即使某些UUID值未使用，也不能分配给普通账户 ​ D. id命令： ​ (a) 作用：查看账户的UUID值 ​ (b) 格式：UUID 账户名 (2) 账户及工作组的创建 ​ A. 意义：为了方便管理数据，引入了系统-&gt;工作组-&gt;账户-&gt;权限的概念，相当于企业-&gt;部门-&gt;员工-&gt;权限 ​ B. useradd命令： ​ (a) 作用：创建账户 ​ (b) 格式：useradd -参数 账户名 ​ (c) 参数： ​ ◆ -d ：指定用户的家目录（默认为：/home/用户名称） ​ ◆ -e ：账户到期时间，格式为：YYYY-MM-DD ​ ◆ -u ：指定该用户账户的UID值 ​ ◆ -g ：指定一个初始的用户基本组（必须已存在） ​ ◆ -G ：指定一个或多个扩展用户组 ​ (d) 例： ​ useradd test3 -e 2019-7-15 -u 3000 -g test ​ （设置test3账户，到期时间为2019-7-15，指定该账户UID值为3000，指定用户基本组为test） ​ C. userdel命令： ​ (a) 作用：删除账户 ​ (b) 格式：userdel -参数 账户名 ​ (c) 参数 ​ ◆ -f ：强制删除 ​ ◆ -r ：同时删除账户及用户家目录 ​ D. groupadd命令： ​ (a) 作用：创建工作组 ​ (b) 格式：group -参数 工作组名称 ​ (c) 参数：-g ，指定工作组的gid编号 ​ E. groupdel命令： ​ (a) 作用：删除工作组 ​ (b) 格式：groupdel 工作组名 ​ (c) 注意：工作组中包含有账户时，不能删除，可以通过删除账户一并删除工作组 (3) 账户及工作组的修改 ​ A. usermod命令： ​ (a) 作用：修改账户信息参数 ​ (b) 格式：usermod -参数 账户名 ​ (c) 参数： ​ ◆ -u ：修改用户uid ​ ◆ –g ：变更用户组 ​ B. passwd命令： ​ (a) 作用：给账户设置密码 ​ (b) 格式：passwd -参数 账户名 ​ (c) 参数： ​ ◆ -l ：锁定用户，禁止登录 ​ ◆ -u ：解除锁定，允许用户登录 ​ ◆ -d ：允许用户可以用空格密码登录系统 ​ ◆ -e ：强制用户在下次登录时修改密码 文件权限及归属 （1）文件权限 ​ A. 可读：r ​ B. 可写：w ​ C. 可执行：x （2）目录权限 ​ A. 可读：r ，可以查看目录中的文件列表 ​ B. 可写：w ，可对目录中的文件进行操作 ​ C. 可执行：x ，可打开目录 （3）文件归属 ​ A. 所有者 ​ B. 所属组 ​ C. 其他用户 （4）文件权限数字化 ​ A. 数字组成：r（4） w（2） x（1） ​ B. 表示类别 ​ (a) rwx：完整权，7 ​ (b) rw- : 6 ​ (c) r-x : 5 ​ (d) r– : 4 ​ (e) -wx : 3 ​ (f) -w- : 2 ​ (g) –x ：1 ​ (h) — ： 0 ​ C. 例： ​ 764：rwxrw-r– 642: rw-r—w- 153 : –xr-x-wx ​ rwxrw-r– : 764 rw–w–wx : 623 rw-r–r– : 644 （5）执行ls -l （ll）显示信息意义 ​ 如：-rw-r–r–. 1 root root 1950 6 jun 13 01:00 initial-setup-ks.cfg ​ A. -rw-r–r–. ：普通文件（-） 权限（rw-r–r–） 开启SELinux(.) ​ B. 1 : 文件字节数 ​ C. root root： 所属账户 所属工作组 ​ D. 1950 ：文件占用容量 ​ E. 6 jun 13 01:00 ：文件修改时间 ​ F. initial-setup-ks.cfg：文件名 （6）chmod命令： ​ A. 作用：修改文件权限信息 ​ B. 格式：chmod 参数 权限 文件或目录名 ​ C. 例： chmod 777 h1.cfg （7）chown命令： ​ A. 作用：修改文件所属账户及工作组 ​ B. 格式：chown 参数 所有者：所属组 文件或目录名 ​ C. 例： chown mk1:mk1 h2.cfg 文件隐藏属性 （1）文件隐藏权限：文件拥有一般权限还拥有隐藏权限，当文件权限足够但无法删除时，考虑是否有隐藏权限 （2）chattr命令： ​ A. 作用：查看设置文件的隐藏权限 ​ B. 格式：chattr -参数 文件名 ​ C. 参数： ​ ◆ i: 无法修改文件（目录中不能新建和删除） ​ ◆ a: 仅允许追加内容，不可以覆盖、删除 ​ ◆ s: 文件变更后同步到硬盘 ​ ◆ S: 从硬盘中彻底删除，不可恢复（0填充文件所在存储区） （3）lsattr命令： ​ A. 作用：查看文件的隐藏权限属性 ​ B. 格式：lsattr -参数 文件名 ​ C. 例： ​ touch h3.cfg ​ chattr +a h3.cfg （+a 增加a隐藏权限） ​ rm -f h3.cfg （无法删除） ​ lsattr h3.cfg ​ chattr -a h3.cfg （-a 去掉a隐藏权限） ​ rm -f h3.cfg 账户切换 (1) 切换原则 ​ A. Root账户可任意切换到其他普通账户，不需要密码 ​ B. 普通账户切换到root账户必须输入密码 ​ C. 账户切换并不是注销，只是同时登录 (2) su命令： ​ A. 格式：su -参数 账户名 ​ B. 作用： 切换账户 ​ C. 常用： su - 账户名，减号表示创建新的环境变量信息 ​ D. 注意：尽量减少使用su命令，因为可能暴露root密码 (3) sudo命令： ​ A. 作用：临时赋予普通账户权限，完成原本root完成的任务 ​ B. 格式：sudo -参数 命令名称 ​ C 参数： ​ ◆ -h: 列出帮助信息 ​ ◆ -l : 列出当前用户可执行命令 ​ ◆ -u (用户名UID值)：使用指定的用户身份执行命令 ​ ◆ -k: 清空密码的有效时间，下次执行sudo时需要再次密码验证 ​ D. sudo功能总结 ​ ◆ 限制用户执行指定的命令 ​ ◆ 记录用户执行的每一条命令 ​ ◆ 验证密码后5分钟内不需再次输入密码 ​ ◆ Sudo必须通过编译配置文件才能使用：visudo ​ E. 赋予普通账户临时权限 ​ ◆ useradd fox 新建账户 ​ ◆ passwd fox 设置密码 ​ ◆ su - fox 切换账户 ​ ◆ cd /root ​ ◆ su - root ​ ◆ visudo ​ ◆ 点击shfit + : 后输入set nu 查看行号 ​ ◆ 定位第98行 ​ ◆ 点击i键添加 fox ALL=(ALL) ALL ​ （谁可以使用 允许使用的主机=（以谁的身份） 可以执行的命令列表） ​ ◆ 点击shfit +: 输入wq保存退出 ​ ◆ su - fox ​ ◆ sudo cd /root ​ ◆ 输入fox账户密码 ​ ◆ sudo cat /etc/passwd 完美执行]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 四、文件系统命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[四、文件系统命令 FHS (1) FHS：Linux文件系统层次化标准 (2) 拓扑：倒置树型，一切数据从/根目录开始 (3) 常见一级目录作用 ​ A. root：管理员的家目录 ​ B. etc：配置文件目录 ​ C. dev：设备文件目录 ​ D. mnt：挂载设备的默认目录 ​ E. media：挂载光盘镜像的默认目录 ​ F. bin：常用命令的程序存储目录 ​ G. tmp：临时目录或共享目录 ​ H. var：日志文件存储默认目录 ​ I. boot：系统启动文件目录 (4) 注意： ​ A. FHS不具有强制性约束，但应遵循次行业规则，否则存储混乱 ​ B. 所有目录注意区分大小写（默认小写） 增、删、改命令 (1) touch命令： ​ A. 作用：新建文件 ​ B. 格式：touch -参数 文件名 ​ C. 例： 新建文本文档：touch -t1.txt ​ touch k1.txt k2.sh k3.cfg ​ D. 注意：vim 文件名 ，此文件若不存在则会新建 (2) mkdir命令： ​ A. 作用：新建目录 ​ B. 格式：mkdir -参数 目录名称 ​ C. 参数 ​ (a) -p ：创建递归目录（多级目录），用ls命令查看 ​ (b) -m ：为新建目录增加权限 ​ (c) 练习：用上面的命令建一个目录，安装tree小工具：yum install tree -y ，然后cd /test检查树型目录的正确性 ​ (d) rpm -q gcc查看gcc是不是安装成功 (3) 利用touch命令创建c源文件编译并执行 ​ touch test.c ​ vim test.c ​ 点击i键输入代码, ​ Include &lt;stdio.h&gt; ​ Int main(void) ​ { ​ Int i,j; ​ For(i=1;i&lt;10;i++) ​ Printf(“%d\t”,i); ​ Printf(“\n”); ​ For(int i=1;i&lt;66;i++) ​ Printf(“-”); ​ } ​ 点击ESC键 ​ 点击shift+:后输入wq保存并退出 ​ 编译: gcc test.c（即源文件名） ​ 看结果：../a.out (4) rm命令： ​ A. 格式：rm -参数 文件名 ​ B. 作用：删除文件或目录 ​ C. 参数： ​ (a) -r ：删除目录 ​ (b) -f ：删除不确认，即强制删除 ​ (c) 例：cd ~ （回到家目录） ​ 输入ls查看 ​ 输入y确认删除 ​ 输入ls查看 ​ rm -f t1.txt t2.cfg（删除） (5) cp命令： ​ A. 作用：拷贝文件或目录 ​ B. 格式：cp -参数 源文件 目标文件 ​ C. 参数： ​ (a) -p ：保留源文件的原始属性 ​ (b) -r ：递归拷贝 ​ (c) -i ：目标文件已存在，提示是否覆盖 ​ (d) 例：cp /root/m1.txt /home （/root等价于~） (6) mv命令： ​ A. 作用：移动文件或改名 ​ B. 格式：mv -参数 源文件或目录 目标文件或目录 ​ C. 例：mv m2.txt t1/m1.txt 表示将m2移到t1中并改名为m1 ​ D. 结论： ​ (a) 若源类型和目标类型都是文件或目录，则为重命名 ​ (b) 若源类型为文件，目标类型为目录，则为剪切移动 ​ E. 例：创建一个myDocument目录和一个Document文件，将Document文件移动到myDocument目录下，最后修改myDucument目录为test ​ mkdir myDocument （创建目录） touch Document （创建文件） mv Document myDocument （移动）​ cd myDocument （进入到myDocument目录下） ​ ls （查看） ​ mv Document test （改名） ​ ls (7) dd命令： ​ A. 格式：dd if=/dev/zero of=新文件名 bs=块大小 count=块个数 ​ B. 作用：制作生成指定容量，内容为全数字0的大文件 ​ C. 例： cd / ​ dd if=/dev/zero of=kong.txt bs=50MB count=2 ​ stat kong.txt （相当于属性，有容量了） ​ 再来一个：dd if=/dev/zero of=loop.cfg bs=1G count=5 ​ D. /dev/zero ：是一个特殊的设备文件，可以输出无穷个数字0，其本身又不占空间，用于制作大文件来覆盖旧文件，防止恶意恢复，也可以制作大文件来作为分区使用 ​ E. 例：dd if=/dev/zero of=kong.txt bs=10MB count=5 ​ （制作50MB的大文件） ​ 做完后删除：rm -f kong.txt 文件属性查看命令 (1) file命令： ​ A. 格式：file -参数 文件名 ​ B. 作用：查看文件类别 ​ C. 类型： ​ (a) empty ：空文件 ​ (b) ASCLL text ：ASCLL码文件（文本） ​ (c) directory ：目录文件 ​ (d) block special ：块设备文件（高速设备） ​ (e) character special ：字符设备文件（低速设备） ​ (f) symbolic link ：链接文件（快捷方式） ​ (g) socket ：接口文件 (2) cat命令： ​ A. 格式：cat -参数 文件名 ​ B. 作用：输出文件内容到设备上（默认为显示器） ​ C. 参数： ​ (a) -b ：文件中所否非空行增加行号，从1开始编号 ​ (b) -n ：文件中所有行增加行号 ​ (c) 例： touch k1.txt ​ echo “hello” &gt; k1.txt ​ cat k1.txt ​ touch k2.txt ​ echo “world” &gt; k2.txt ​ cat k2.txt ​ touch k3.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ cat k3.txt ​ D. 特殊功能： ​ (a) 文件内容合并： ​ touch k1.txt k2.txt k3.txt ​ echo “hello” &gt; k1.txt ​ eEcho “world” &gt; k2.txt ​ cat k1.txt k2.txt &gt; k3.txt ​ （查看两个文件内容输出到新文件中） ​ cat k3.txt ​ (b) 倒序查看内容：tac 文件名 ​ E. 注意：由于无翻页功能，适用于内容较少的文本文件查看 (3) more命令： ​ A. 格式： more 文件名 ​ B. 作用：可翻页查看文件内容 ​ C. 方法： ​ (a) 空格：翻页查看 ​ (b) 回车：每行查看 ​ (c) q ：退出 (4) less命令： ​ A. 同more命令 ​ B. 点击j键下一行，k键上一行 (5) head命令： ​ A. 格式：head -参数 文件名 ​ B. 作用：查看文件的前几行内容 ​ C. 参数：-n 行数 ​ D. 例：head -n 5 /etc/passwd （前5行） (6) tail命令： ​ A. 格式：tail -参数 文件名 ​ B. 作用：查看文件后几行或持续刷新内容 ​ C. 例：head -n 5 /etc/passwd （后5行） ​ head -f /etc/passwd （动态刷新内容） (7) wc命令： ​ A. 格式：wc -参数 文件名 ​ B. 作用：统计文件的单词书、行数、容量 (8) stat命令： ​ A. 格式：stat -参数 文件名 ​ B. 作用：查看文件属性 ​ C. 属性： ​ (a) access ：最近访问时间 ​ (b) modify ：最近更改时间 ​ (c) change ：最近改动时间 文件查询命令： (1) find命令： ​ A. 作用：按照文件名、类型、属性等参数检索文件 ​ B. 格式：find 查找路径 查找条件 操作 ​ C. 查找路径：一般为绝对路径 ​ D. 查找条件： ​ (a) -name 文件名 ：按照文件名检索 ​ (b) -user 账户名 ：按照拥有者检索 ​ (c) -group 工作组 ：按照工作组归属检索 ​ (d) –type b/d/c/l ：按照文件类型检索 ​ (e) –size +50k （-50k）:按照大于（小于）50k容量检索 ​ (f) -newer f1 ! f2 ：匹配比文件f1新却比f2旧的文件 ​ (g) 通配符： ​ ◆ * ：任意内容、任意个数 ​ ◆ ? ：任意内容、1个字符 ​ (h) 并且： -a 或： -o 不是（取反）： -not ​ E. 例：find / -name host ​ find /etc -name a. （a开头文件） ​ find / -name ?b. （第二个字母为b的文件） ​ find / -name *.cfg （检索所有的日志文件） ​ find / -user YLX（普通账户YLX的所有文件，如 果不知道就cat /etc/passwd） ​ find /dev -type b （检索块设备文件） ​ find ~ -size -10k （检索小于10k的文件） ​ find / -type b | wc （统计块设备文件个数） ​ find / -name *.c &gt; f.txt （检索c类型文件并 备份到f文件中） ​ 自己查：ip地址 IP ​ 子网掩码 NETMASK ​ 网关地址 GATEWAY ​ 域名解析 DNS （正向/反向） ​ 超文本传输控制协议 （HTTP/HTTPS） (2) grep命令： ​ A. 格式：grep -参数 查找条件 文件名 ​ B. 作用：在文件中按照条件检索内容 ​ C. 参数 ​ (a) -n ：显示符合要求的行的行号 ​ (b) -v ：显示不符合要求的行 ​ (c) -i ：忽略字母的大小写 ​ (d) -c ：显示符合要求的行数 ​ (e) -A数字 ：如-A2表示显示符合要求的行及下面2行 ​ (f) -B数字 ：如-B5表示显示符合要求的行及上面5行 ​ (g) -C数字 ：如-C3表示显示符合要求的行及上下各3行 D. 例： ​ (a) grep -n “root” /etc/passwd 检索包含root ​ (b) Grep -n “/sbin/nologin” /etc/passwd ​ （不允许登陆的账户信息） ​ (c) grep -nv “/sbin/nologin” /etc/passwd ​ （允许登录的账户信息） ​ (d) grep -nA3 “ftp” /etc/passed ​ （检索包含ftp的行及下面3行） ​ (e) Grep -n “halt” /etc/passwd &gt; grep1.txt ​ （使用文件保存检索结果） E.正则表达式 ​ (a) 作用：用于按照指定条件过滤大量文本，是一种表示条 件的规则和方法 ​ (b) 正则与通配符的区别 ​ ◆ 通配符：按照文件名进行检索，一般多数命令都支持 ​ ◆ 正则：在文本中过滤字符串，一般多数语言、脚本等 程序都支持 ​ (c)按照 [ ] 字符集进行过滤 ​ ◆ [ab] ：表示检索包含a或者包含b的信息，括号中 多个内容只表示一个信息 ​ grep -n [dD] /etc/passwd 过滤包含d或D ​ grep -n [oo] /etc/passwd 过滤包含o ​ ◆ [^] ：表示反色显示不包含条件的内容 ​ grep -n [^r] /etc/passwd 反色显示不包含r的字 符串 ​ grep -n [^r]oo /etc/passwd 过滤不以r开头且包 含oo的行 ​ ◆ [0-9] ：表示过滤包含数字的内容 ​ grep -n [0-9] /etc/passwd 过滤包含数字的内容 ​ -grep -n [^7-9] /etc/passwd 反色显示不包含7-9 的内容 ​ ◆ [a-z] [A-Z] [a-zA-Z] ：表示过滤小写字母、大写字 母、字母 ​ grep -n [A-Z] /etc/passwd 过滤包含大写字母的内 容 ​ ◆ 注意：字符集：[] [^] [-] 区别 ​ (d) 过滤行首或行尾 ​ ◆ ^ ：过滤行首以谁开头的内容 ​ grep -n ^n /etc/passwd 过滤行首以n开头的内容 ​ grep -n ^[A-Z] /etc/passwd 过滤行首以大写字母 开头的内容 ​ ◆ $ ：过滤行尾以谁结尾的内容 ​ grep -n $”]” /etc/sos.conf ​ （注意：[]表示字符集，若想表示中括号的作用，必须使用””进行转义） ​ grep -n $”[0-9] /etc/sos.conf” 以数字结尾的内容 ​ ◆ 检索空白行：grep -n ^$ /etc/sos.conf (e) 正则表达式的通配符 ​ ◆ 一个任意字符： . ​ ◆ 重复前面0个或多个任意字符： * ​ ◆ 例： ​ grep -n r..t /etc/passwd 检索以r开头t结尾中 间有两个任意字符的字符串 ​ grep -n o* /etc/passwd 检索不包含或包含o 的内容 ​ grep -n oo* /etc/passwd 检索至少包含o的内 容 ​ grep -n ooo* /etc/passwd 检索至少包含oo的 内容 ​ ◆ 注意： .*表示所有内容 (f) 转义字符及区间字符 ​ ◆ \ ：转义字符，即去掉其后字符附加功能，恢复到 本身功能 ​ grep -n ]$ /etc/sos.conf ​ ◆ 区间字符：{n1,n2}，表示重复n1到n2次前面字 符，n1&lt;n2 ，n2可以省略，{n1}表示大于等于n1次 ​ （注意：{}必须使用\进行转义） ​ grep -n o”{2}” /etc/passwd 检索至少包含两个o 的内容 (3) tr命令： ​ A. 作用：替换文本文件中的字符 ​ B. 格式：tr 原始字符 结果字符 ​ C. 例：cat /etc/passwd | tr [a-z] [A-Z] ​ （显示passwd内容并将其小写字母改为大写） ​ cat /etc/sos.conf | tr # % ​ （#和%需要转义） ​ D. 注意：tr命令一般不直接使用，即不推荐直接更改文件内 容，应显示文件内容并更改 打包压缩命令 (1) 作用：打包、压缩、解压缩文件 (2) 常用格式： ​ A. .tar ：由tar打包程序打包的文件（无压缩功能） ​ B. .tar.gz ：先由tar打包，再由gzip压缩 (3) 格式：tar -参数 压缩文件名 被打包压缩的文件 (4) 参数： ​ A. 打包压缩： ​ (a) -c ：压缩 ​ (b) -z ：使用gzip进行压缩 ​ (c) -v ：显示过程 ​ (d) -f ：目标文件名 ​ (e) 常用：-czvf ​ B. 解压缩 ​ (a) -x ：解压缩 ​ (b) 常用：-xzvf (5) 例：打包压缩/root目录后解压缩（备份） ​ A. cd ~ ​ B. tar -czvf t1.tar.gz /root ​ C. cd / ​ D. mkdir t2 ​ E. cd t2 ​ F. tar -xzvf /root/t1.tar.gz ​ G. ls (6) 注意： ​ A. 压缩文件使用“红色”表示 ​ B. -c与-x不能同时使用 管道符与重定向命令 (1) 输入输出重定向 ​ A. 作用：将默认的输入输出端进行改变 ​ B. 符号： ​ (a) &gt; ：输出重定向，将输出内容重定向到文件 ​ (b) &gt;&gt; ：输出重定向，追加输出 ​ C. 重定向保存错误提示： ​ (a) 格式：命令 2&gt;文件名 ​ (b) 例：ls -l temp 2&gt;err.txt (2) 管道符 ​ A. 格式：命令1 | 命令2 | 命令3…… ​ B. 作用：将前一个命令的结果作为后一个命令的数据源 ​ C. 例：统计包含root的行数 ​ grep “root” /etc/passwd | wc 常见的环境变量 (1) 环境变量 ​ A. 作用：表示bash命令解释器的命令程序存储路径 ​ B. 显示：echo $PATH ​ C. 命令程序：/usr/bin ​ (2) 常见变量 ​ A. HOME：用户的家目录 ​ B. SHELL：SHELL程序目录 ​ C. HISTSIZE：历史命令记录条数 ​ D. PATH：执行文件的默认路径 ​ E. MAIL：邮箱文件存储路径 ​ (3) 注意：使用$运算符显示变量的值 常见Linux文件类型 (1) 普通文件： ​ A. 文本文件：存储ASCLL ​ B. 二进制文件 ​ C. 注意：代号为-，白色 (2) 目录： ​ A. 作用：相当于Windows中的“文件夹” ​ B. 注意：代号为d，蓝色 (3) 链接文件： ​ A. 作用：相当于Windows的“快捷方式”，是一种指向式文件 ​ B. 注意：代号l，绿色 (4) 设备文件： ​ A. 作用：Linux中一切数据皆文件，设备也是一种文件，可编辑 ​ B. 注意：代号（b c 等），黄色]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 三、常用Linux命令]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令提示符的意义 （1）[root@localhost ~] ​ A. root:表示当前登录账户名称 ​ B. @：表示分隔符 ​ C. localhost：表示主机名 ​ D. ：表示此位置是当前工作路径，相当于/root （2）#：表示以root账户登录，$：表示以普通用户登录 常见命令 （1）命令书写格式：命令名称 + 空格 + 参数 + 空格 + 目标 （2）参数： ​ A.长格式（全称）：–参数 ​ B.短格式：-参数 ​ C.例：man –help ​ man -h （3）目录查看命令 A.格式：pwd B.作用：查看当前工作目录的绝对路径（4）目录切换命令： A.格式：cd 路径 B.作用：切换工作目录 C.路径：​ (a) 绝对路径：从/开始向下遍历 ​ (b) 相对路径：从当前工作目录开始向下遍历（不包含当前工作目录） ​ D.特殊路径 (a) cd / ：切换根目录 (b) cd .. ：返回上级目录 (c) cd ~ ：切换root家目录 (d) cd /root：同上 (e) cd /home/普通账户名 ：切换普通账户的家目录（5）目录浏览命令： A.格式：ls -参数 B.作用：查看目录中的内容 C.参数：​ (a) -a ：查看隐藏文件（以点开头的为隐藏文件） ​ (b) -l ：查看目录中的详细信息 ​ (c) -d ：查看当前目录 D.注意：​ (a) 翻页查看：ls | more ​ (b) 查看目录内的详细信息（等同于ll命令）：ls -l ​ (c) 查看当前目录的详细信息：ls -dl E. ls命令查看的颜色意义：​ (a) 白色：表示普通文件 ​ (b) 蓝色：表示目录 ​ (c) 红色：压缩文件 ​ (d) 黄色：设备文件 ​ (e) 绿色：链接文件 ​ 演示： cd /dev ​ cd / ​ Ls （6）date命令： ​ A. 格式：date [选项] [“+显示时间格式”] ​ B. 注意：按照指定格式显示日期时间 ​ C. 参数： ​ (a) -s ：设定系统的日期时间 ​ (b) -d ：显示指定描述的日期时间（几天前/后） ​ D. 日期格式： ​ (a) %Y ：显示完整的年份 ​ (b) %m ：显示月份 ​ (c) %d ：显示日（1-31） ​ (d) %a ：星期几 ​ (e) %j ：一年中的第几天（1-366） ​ (f) 例：显示年月日：date “+%Y-%m-%d” ​ date “+%j” （数字越大，文件越新） ​ date “+%Y-%m-%d %a” ​ E. 时间格式： ​ (a) %H ：小时（00-23） ​ (b) %M ：分钟（00-59） ​ (c) %S ：秒（00-60） ​ (d) %t ：相当于tab键（4个空格） ​ (e) 例：date “+%H:%M:%S” ​ date “+%Y-%m-%d%t%H:%M:%S” ​ F. 其它： ​ (a) %p ：显示本地AM或PM（上午或下午） ​ (b) %Z ：显示时区 ​ (c) %j ：一般用于备份文件或日志文件，增加此参数，数字越大，文件越新 ​ G. date -s “2020-9-5 18:35:40” 设置系统新的日期时间 ​ H. date -d “+2 day” “+Y-%m-%d” 设置系统的日期为2天后 （减号为几天以前） （7）cal命令： ​ A. 格式： cal -参数 ​ B. 作用：显示日历 ​ C. 例： ​ (a) cal 显示本月 ​ (b) cal -2019 显示全年的日历 （8）echo命令： ​ A. 格式：echo -参数 ​ B. 作用：将字符串输出到屏幕或文件中，显示变量的值 ​ C. 例：echo “HELLO” ​ echo “hello” &gt; 文件名 （9）history命令： ​ A. 格式：history -参数 ​ B. 作用：显示命令历史记录 ​ C. 配置文件：/etc/profile ​ D. 默认记录1000条历史命令 ​ E. 修改历史命令记录条数： ​ (a) vim /etc/profile ​ (b) HISTSIZE=1000 将1000改为指定数字 ​ (c) reboot 重启 ​ F. 清空历史命令记录：history -c 系统检测命令 （1）ps命令： ​ A.格式：ps -参数 ​ B.作用：显示进程的参数 ​ C.参数： ​ (a) -a：显示所有进程 ​ (b) -u：用户及其他详细信息 ​ (c) -x：显示没有控制终端的进程 ​ D.常用：ps -au ​ E.注意：只要关注%CPU（cpu占用率）及%MEM（内存使用率） （2）top命令： ​ A.作用：动态检测系统的活动与负载，相当于强化版的“任务管理器” ​ B.top命令显示的表头解释： ​ (a) 第一行： ​ ◆ 系统时间 ​ ◆ 运行时间 ​ ◆ 登录的终端数 ​ ◆ 系统负载：1分、5分、15分钟平均值（三个值越小，系统负载越低） ​ (c) 第二行：进程总数、运行进程数、睡眠数、停止数、僵死数 ​ (d) 第三行： ​ ◆ 用户资源占用百分比 ​ ◆ 系统内核占用资源百分比 ​ ◆ 改变过优先级的进程资源百分比 ​ ◆ 空闲的资源百分比等 ​ (e) 第四行： ​ ◆ 物理内存总量 ​ ◆ 内存使用量 ​ ◆ 内存空闲量 ​ ◆ 作为内核缓存的内存量 ​ (f) 第五行： ​ ◆ 虚拟内存量 ​ ◆ 虚拟内存使用量 ​ ◆ 虚拟内存空闲量 ​ ◆ 已被提前加载的内存量 ​ D. 点击q键退出 （3）ifconfig命令： ​ A.作用：查看本机网卡信息 ​ B.信息： ​ (a) ens32为本机物理网卡 ​ (b) inet：本机IP ​ (c) netmask：本机子网掩码 ​ (d) RX：发送数据包个数 ​ (e) TX：接收数据包个数 （4）uname命令： ​ A.格式：uname -a ​ B.作用：显示系统的版本信息 （5）free命令： ​ A.格式：free -h ​ B.作用：显示内存及虚拟内存的容量、剩余量等信息 （6）who命令： ​ A.作用：显示系统登录信息 ​ B.信息： ​ (a) 账户 ​ (b) 方式 ​ ◆ :0 表示图形化界面 ​ ◆ tty2 命令行界面 ​ ◆ pts/0 远程登录界面 ​ (c） 日期时间 （7）last命令：显示系统登录或退出的详细信息，是强化版的who]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 二、Linux的安装与部署]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%BA%8C%E3%80%81Linux%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[二、Linux的安装与部署 VMware虚拟机的安装 (1) .增强型键盘驱动需要打勾 (2) .虚拟机的新建及设置 ​ A. 稍后安装操作系统 ​ B. 选择客户机系统：centos7 64 位，其目的是匹配系统，选择更适合的VMware tools 工具包 ​ C. 命名虚拟机 ​ (a).虚拟机名称：默认 ​ (b).放在非C盘路径，与其他虚拟机名称要有区别 ​ D. 磁盘容量 ​ (a).大小：20GB，动态分配，使用多少分配多少，最大为20GB ​ (b).将虚拟磁盘文件存储为单个文件：存储速度快，不易于迁移 ​ (c).将虚拟磁盘存储为多个文件：存储速度相对较慢，利于虚拟机迁移 ​ E. 自定义硬件 ​ (a).内存：1：4关系，1G虚拟机内存对应4G物理内存 ​ (b).CPU：1颗，4核 ​ (c).新CD/DVD：点击“选择ISO镜像文件”选项，点击“浏览”，设置下载的镜像文件路径 ​ (d).网络适配器： ​ ◆ 桥接模式：将物理机网卡当作桥梁，建立虚拟机与互联网的连接关系，适用于不频繁变动的网络 ​ ◆ NAT模式：（NAT：网络地址转换器）将物理当作路由器，通过“路由器”建立网络连接，适用于经常变换网络环境的情况下使用（VMnet 8） ​ ◆ 仅主机模式：仅当前虚拟机与物理机连接，无法连接互联网（VMnet 1） ​ (e).移除不必要的设备：USB、声卡、打印机设备 (3).虚拟机的功能配置 ​ A.虚拟机移除 ​ (a).虚拟机左侧“库”侧边栏中选中虚拟机文件，单右，移除 ​ (b).定位虚拟机在Windows中的存储位置，选中文件夹删除 ​ B.快照制作 ​ (a).作用：将系统状态参数等信息冻结保存为镜像，以便于系统崩溃后进行恢复 ​ (b).方法：虚拟机菜单-&gt;快照-&gt;拍摄快照（注意左下角进度比率） ​ C.虚拟网络编辑器 ​ (a).作用：显示及配置网卡的地址参数 ​ (b).方法：编辑菜单-&gt;虚拟网络编辑器 ​ (c).注意：右下侧是否有黄色感叹号三角，若有说明虚拟机没有以管理员权限打开 Linux系统部署 无法获取 vmci 驱动程序版本句柄无效解决办法：打开本地路径，找到以VMX结尾的文件，进入查找界面，在文本框输入 vmci0.present 点击查找下一个，查找到 vmci0.present=&quot;TRUE&quot; 代码，将true更改为false点击保存即可 （1）软件选择：带有GUI的服务器 （2）安装位置（分区）： ​ A. 我要配置分区-&gt;完成-&gt;点击“+”添加分区-&gt;设置挂载点及期望容量-&gt;完成-&gt;接受更改 ​ B. 分区原则（最少三个分区）： ​ (a) . /boot：系统启动分区，400MB ​ (b) swap：交换分区（虚拟内存），4GB ​ (c) /：根分区，剩余容量（不填） （3）关闭KDUMP（内存崩溃保护机制）以节省内存 ​ A. 设置root高级管理员密码，设置普通账户名（大写）及密码 ​ B. 初次进入系统的设置 ​ a.登录：点击“未列出”-&gt;root-&gt;密码:123456 ​ b.系统自带的六个终端 ​ ◆ 方法：ctrl+alt+F1~F6 ​ ◆ F1对应图形化界面 ​ ◆ F2~F6对应5个命令行界面 ​ c.清屏 ​ ◆ ctrl+l ​ ◆ 命令：clear ​ d.查看本机IP地址：ip addr（查看ens33） ​ e.配置网卡： ​ (a)cd /etc/sysconfig/network-scripts ​ (b)vim ifcfg-ens32 ​ (c)点击键盘i键，进入编辑状态，定位ONBOOT=no，将no删除编为yes ​ (d)点击esc键 ​ (e)点击shift+: ​ (f)输入wq后保存退出 ​ (g)重启网卡：service network restart ​ (h)检测：ping [www.baidu.com](http://www.baidu.com) ​ (i) ctrl+c 终止ping操作 ​ f.快照制作：虚拟机-&gt;快照-&gt;拍摄快照-&gt;命名（见名知意） （4）远程登录putty的使用： ​ A. Hosts name（or IP address）：输入Linux的IP地址 ​ B. Saved sessions：输入新名称后点击save ​ C. 点击open ​ D. Login as：输入root ​ E. 输入密码 ​ F. 字体、字号调整：定位标题栏-&gt;单击右键-&gt;change settings-&gt;Appearance-&gt;点击右键“change”按钮-&gt;设置 “粗体”，18号-&gt;确定-&gt;Apply 系统YUM源的配置 （1）yum配置文件目录：cd /etc/yum.repos.d （配置文件扩展名为.repo） （2）替换yum源： ​ A. 删除自带yum配置文件： cd /etc ​ rm -rf yum.repos.d （删除目录） ​ mkdir yum.repos.d （新建同名目录） ​ cd yum.repos.d （进入目录） ​ B. 下载网易yum配置文件：http://mirrors.163.com/.help/CentOS7-Base-163.repo cd /etc/yum.repos.d wget &lt;http://mirrors.163.com/.help/CentOS7-Base-163.repo&gt;（3） 建立新的yum缓存 ​ yum clean all （清理旧yum缓存） ​ yum makecache （新建缓存） （4）更新系统yum update kernel （5）更新所有软件：yum update 第二种方法（不用yum）,cmatrix实例的安装： （1) wget &lt;http://archive.ubunntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orug.tar.gz&gt; (下载软件) （2）Tar xvf cmatrix_1.2a.orig.tar.gz (解压缩) （3）cd cmatrix-1.2a (进入解压缩后的目录) （4） yum install ncurses-devel(安装依赖软件) （5）yum install gcc -y ( 安装依赖软件) （6）./configure &amp;&amp; make &amp;&amp; make install (编译安装) （7）任意目录下输入：cmatrix （按Q退出） 修改root账户密码 （1）重启：reboot （2）内核选择界面点击上下键，使其停留在该界面 （3）点击键盘 e 键 （4）定位Linux16所在行，找到ro后删除，同位置添加 ​ rw init=/sysroot/bin/bash （5）点击ctrl+x （6）输入： hroot /sysroot （7）输入：passwd （8）输入2次新密码 （9）输入 touch /.authorelabel （10）点击键盘ctrl+d （11）输入reboot重启 关机重启 （1）重启：reboot 或shutdown -i now （2）关机 : shutdown now 或 halt 14.常用的快捷键 ​ （1）清屏 ctrl+l ​ （2）终止命令 ctrl+c ​ （3）单词补全 tab ​ （4）调出历史命令 : 键盘上下键 ​ （5）终止进程：ctrl+z]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维初级--- 一、Linux环境简介]]></title>
    <url>%2F2019%2F07%2F17%2FLinux%E8%BF%90%E7%BB%B4%E5%88%9D%E7%BA%A7-%E4%B8%80%E3%80%81Linux%E7%8E%AF%E5%A2%83%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、Linux环境简介 说明： VMware 14密钥 ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 ZC5XK-A6EOM-080XQ-04ZZG-YF08D 网易开源镜像（http://mirrors.163.com） 阿里开源镜像（https://opsx.alibaba.com/mirror） 熟练掌握常见命令（80个左右） 熟练掌握软件包安装 （初级阶段） 熟练掌握系统结构和运行原理 熟练搭建各种常见服务器 熟悉网络安全并能配置服务器安全策略 （中级阶段） 熟悉掌握Linux下磁盘存储管理、用户权限管理、内存管理、文件系统管理、进程管理等 熟悉掌握系统故障排查方法并进行调优 Linux系统的构成 (1) .Linux本质是一个内核（kernel） (2) .Linux发行套件：将kernel与辅助软件、工具软件、文件系统等组成一个大型软件包，从而形成Linux发行套件 Linux发行版本介绍 (1) .RHEL：红帽企业版，具有完整的Linux功能，企业首选 (2) .Centos：社区企业操作系统，是RHEL免费版，学习首选 (3) .Ubuntu：乌班图，是Linux桌面版操作系统 Linux发行套件的版本构成 (1) .DVD版本：以标准DVD容量（4.8G）进行发行的商业版本，具有基本组件（常用） (2) .Everything版本：完整版，具有全部功能组件，10G容量 (3) .Minimal版本：最小化安装版（920MB），具有操作系统最小功能 (4) .Netinstall版本：网络安装版，批量化LAN安装 (5) .X86_64：使用平台为64系统]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端form表单]]></title>
    <url>%2F2019%2F07%2F14%2FWEB%E5%89%8D%E7%AB%AFform%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[input属性 name：名字，类似id，可以用js取值和分类，后台用的较多 value：表单提交项的值(不同类型的input，value的作用也不尽相同) placeholder(文本类)：文本输入提示(css3新增属性，用来提示文本输入) checked(选择类)：页面加载时默认选定的 input 元素 readonly(文本类)：只读的文本输入元素 disabled：规定禁用的 input 元素 type：input的种类 文本类：text——文本框；password——密码 选择类：radio——单选；checkbox——复选 按钮类：submit/image——提交/图片提交；reset——重置；button——按钮 特殊类：file——上传 有点懵…不要着急，让我一个个举例~ 文本类 1234567&lt;!-- 后台数据库通过name值找到value（值） --&gt;&lt;!-- 可输入的文本框 --&gt;&lt;input type="text" value="我是值" name="user" /&gt;&lt;!-- 密码文本框 --&gt;&lt;input type="password" placeholder="密码" name="password" /&gt;&lt;!-- 只读不可输入的文本框 --&gt;&lt;input type="text" value="我是只读的" readonly /&gt; 选择类 单选框 123&lt;!-- 设置name="sex"使单选框生效，不能多选 checked表示默认选项 --&gt;&lt;input type="radio" name="sex" checked /&gt;男&lt;input type="radio" name="sex" /&gt;女 多选框 123&lt;input type="checkbox" name="hobby" /&gt;足球&lt;input type="checkbox" name="hobby" /&gt;篮球&lt;input type="checkbox" name="hobby" /&gt;羽毛球 按钮类 123456&lt;!-- 提交按钮 --&gt;&lt;input type="submit" /&gt;&lt;!-- 按钮 --&gt;&lt;input type="button" value="→" disabled /&gt;&lt;!-- 重置 --&gt;&lt;input type="reset" /&gt; 特殊类 12 &lt;!-- 上传文件 --&gt;&lt;input type="file" /&gt; 表单元素的专用伪类选择器：focus—-获得焦点举个简单的例子，比如这里有一个按钮：&lt;input type=&quot;button&quot; value=&quot;按钮&quot; class=&quot;button&quot; /&gt;，那么如何获取焦点呢？很简单，就是在css样式里设置： 12345input:focus&#123; /* 这里的样式自定义 */ border: none; border-bottom: 1px red dashed;&#125; 获取焦点后，表单的按钮类元素在鼠标移入时不会显示为可以点击的手型，可以用cursor的样式改变其效果(可以用在其他元素上)，鼠标在移入某元素上时的鼠标样式，这里有5种 可以点击的手型 123.button&#123; cursor: pointer;&#125; 禁用手型（不可以被点击） 123.button&#123; cursor: not-allowed;&#125; 可以任意拖动 123.button&#123; cursor: move;&#125; 提供帮助（在浏览器中显示为？，表示帮助） 123.button&#123; cursor: help;&#125; 等待（加载中的状态） 123.button&#123; cursor: wait;&#125; 绑定焦点：label(内联元素)作用：绑定input元素定义标注，并帮助input元素获取焦点，也就是说当点击选择按钮后面的文字时，也能被选中 写法1：label嵌套成input的父元素两个标签分开写，需要给文字加上span标签 以上面的单选代码为例： 123456789&lt;label&gt; &lt;input type="radio" name="sex" checked /&gt; &lt;span&gt;男&lt;/span&gt;&lt;/label&gt;&lt;label&gt; &lt;input type="radio" name="sex" /&gt; &lt;span&gt;女&lt;/span&gt;&lt;/label&gt; 写法2：label的for属性的值=input的id值，需要给input加上id值 以上面的多选代码为例： 12345678&lt;input type="checkbox" name="hobby" id="football" /&gt;&lt;label for="football"&gt;足球&lt;/label&gt;&lt;input type="checkbox" name="hobby" id="basketball" /&gt;&lt;label for="basketball"&gt;篮球&lt;/label&gt;&lt;input type="checkbox" name="hobby" class="ball" /&gt;&lt;label for="ball"&gt;羽毛球&lt;/label&gt; form属性1.method：表单的提交方式（POST和GET） 一般浏览器通过哪种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method (方法)属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，之后浏览器会按分段传输的方法将数据发送给服务器；在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，读到参数后，会在应用程序能够使用这些表单值以前，对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数 GET 方法，浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔 GET、POST的区别：get在url里传送数据：安全性低、容量小，便于分享(商品地址和url有关)，适合获取，且会缓存；post安全性一般、容量几乎无限，更适合上传(图片等) action：表单处理服务器 注意：凡是用户与服务器交互的表单标签应全部放在form标签内；form内的提交按钮提交的是整个form表单 举个表单提交的例子~做一个天猫商城网站搜索商品的搜索框 HTML： 1234&lt;form action="https://list.tmall.com/search_product.htm" method="GET"&gt; &lt;input type="text" placeholder="搜索天猫商品" name="q" /&gt; &lt;input type="submit" value="搜索" /&gt;&lt;/form&gt; 然后在浏览器中打开，在文本框随便搜索什么东西，都能跳转到天猫商城的对应商品页 其他表单元素 select/option：下拉选框/下拉选框的选项 对高度的支持不兼容 size(select属性)：用来设置同时显示选项的数量 selected(option属性)：用来设置下拉框的默认选项 举个例子~做一个下拉选框，要求有北京、上海、广州，设置广州为下拉框的默认选项，同时显示2个选项 12345&lt;select name="" id="" size=2&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="guangzhou" selected&gt;广州&lt;/option&gt;&lt;/select&gt; textarea：文本域，即自定义文本框的宽高 各个浏览器下的默认滚动条显示不兼容 cols/rows属性：列数/行数 css3新增 resize 自由缩放样式 resize: none;(禁用缩放)；both水平垂直都可以缩放；horizontal：只有水平方向可以缩放；vertical 只有垂直方向可以缩放。注意：一定要配合overflow:auto 一块使用 举个例子~ 设置一个列数为30行数为10的文本框 1234&lt;!-- 文本框：不能改变宽高 --&gt;&lt;input type="text" /&gt;&lt;!-- 文本域：可以通过设置列数和行数来更改宽高 --&gt;&lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; 设置一个150*150背景为红色的div盒子，用自由缩放样式可以拖动div盒子的右下角以改变大小 HTML部分： 1&lt;div&gt;&lt;/div&gt; CSS部分： 12345678div&#123; width: 150px; height: 150px; background-color: red; /* 水平垂直都可以缩放 ，一定要配合overflow: auto;使用*/ resize: both; overflow: auto;&#125;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端定位和居中]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[定位详解 position: static;无定位（默认值） 元素出现在正常的流中(忽略 top, bottom, left, right 或者 z-index声明)。 当你没有为一个元素指定定位方式时，默认为static，也就是按照文档的流式(flow)定位，将元素放到一个合适的地方。 在不同的分辨率下，采用流式定位能很好的自适合，取得相对较好的布局效果。 position: inherit;继承父元素的定位方式 position: relative;相对定位 不影响元素本身特性，没有定位偏移量时对元素无影响 相对定位的元素仍然在文档流中，仍然占据 着它本来占据的未知空间（虽然它已经不在本来的位置了） 相对于其正常位置进行定位，元素的位置通过偏移值：“left”、”top”、”right”、”bottom”进行规定 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: absolute;绝对定位 使元素从文档流中被删除，结果就是钙元素原本占据的空间被其他元素所填充 使内联元素在设置宽高时支持宽高，区块元素在未设置宽度时由内容撑开宽度（改变元素的特性） 相对于 static 定位以外的第一个祖先元素进行定位(其父元素没有定位则逐层上找，直到document)。元素的位置通过偏移值进行规定。（所以一般对其父元素也要设置定位） 提升层级：用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 position: fixed;固定定位 元素的表现类似于将 position 设置为 absolute，不过其包含块是视窗(window)本身，也就是说下拉滚动条时包含块始终在窗口中。 定位效果类似之前学过的固定背景，元素与视窗始终相对静止。元素的位置通过偏移值进行规定。 提升层级，用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值大者在上面 z-index: 99;z轴的顺序 当网页上出现多个定位所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面 x轴和y轴决定网页平面，z轴则是垂直于屏幕的虚拟坐标轴，浮动层在这个坐标轴上的顺序号就决定了谁上谁下。 定位才可以触发z-index属性，它没有单位，并可拥有负的属性值。默认值为0 position:relative和-margin都可以使元素位置发生偏移，有什么区别？ 相对定位可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他元素的位置不会发生变化 通过负margin偏移的元素会放弃偏移前占据的空间，后面的其它元素就会“流”过来填充，所以它们位置发生了变化。 元素的居中 行内块级元素 基本思想：使用display: inline-block; vertical-align: middle; 以及一个伪元素让内容块垂直居中于容器中央 123456789.parent::after, .son&#123; display:inline-block; vertical-align:middle; &#125; .parent::after&#123;display:inline-block; content:''; height:100%; &#125; 如果“margin-left”和“margin-right”都是“auto”，那么它们的使用值是相等的。它将元素相对于包含块的边缘水平居中(要求子元素比父元素小，且只能做水平方向的居中)。 1.son&#123;margin:0 auto;&#125; 使用CSS3中新增的transform属性, 支持水平和垂直居中，子元素设置如下: 12345.son&#123; position:absolute; left:50%; //top:50%; transform:translate(-50%,0); //transform:translate(0,-50%);&#125; transform是css3的变形，在后面会详细说明 使用绝对定位方式, 以及负值的margin, 支持水平和垂直居中，（适用于子元素宽度大于父元素宽度的特殊情况，是最优的水平垂直居中方法）子元素设置如下: 123456.son&#123; position:absolute; width:固定宽; //height:固定高; left:50%; //top:50%; margin-left:-0.5固定宽; //margin-top:-0.5固定高 &#125; 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; —支持水平和垂直居中，（缺点：子元素宽度必须小于父元素宽度）子元素设置如下: 1234567.son&#123; position:absolute; width:固定宽; //height:固定高 left:0; //top:0; right:0; //bottom:0; margin:0 auto; //margin:auto 0; &#125; 6. 同时支持水平和垂直居中最好的方案是：transform(变形)（后面会说到）、绝对定位 （相对定位只能做水平居中）和移动端阶段学习的弹性盒模型的几个方案 说那么多…做个练习吧！！！！ ​ 1. 定位练习 ​ 题目：做一个宽高300背景为红色的div块，将4个75*75像素背景为黑色的小div块定位在它的四个角 ​ （注：给子元素设置绝对定位时要记得给父元素设置相对定位） HTML部分： 123456&lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021222324.parent&#123; width: 300px; height: 300px; background-color: red; position: relative;&#125;.parent&gt;div&#123; width: 75px; height: 75px; background-color: black; position: absolute;&#125;.parent&gt;div:nth-of-type(2)&#123; right: 0; top: 0;&#125;.parent&gt;div:nth-of-type(3)&#123; left: 0; bottom: 0;&#125;.parent&gt;div:nth-of-type(4)&#123; right: 0; bottom: 0;&#125; 2. 居中练习 题目：做一个宽高为300背景为灰色的div块，固定定位在页面右下角，并为其设置一个子元素son，绝对定位在其正中心 HTML部分： 123&lt;div class="parent"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt; CSS部分： 123456789101112131415161718192021body&#123; height: 2000px;&#125;.parent&#123; width: 300px; height: 300px; background-color: gray; position: fixed; right: 0; bottom: 0;&#125;.parent .son&#123; width: 150px; height: 150px; background-color: blue; position: absolute; left: 50%; margin-left: -75px; top: 50%; margin-top: -75px;&#125; 注：CSS部分给body设置高度是为了验证固定定位的特点，即下拉滚动条时没有改变位置]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端布局和HTML5新标签]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%92%8CHTML5%E6%96%B0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[做一个页面布局 大多数网站会把内容安排到多个列中(就像杂志或报纸那样) 开始使用布局的时候尽量通过ps等画图工具进行设计 早期的网站使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具 如今大多数网站使用等元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局 学习布局时需要完成下面的步骤 第一步：创建一个新项目，用index.html作为主页 第二步：按照ui设计画布局图 第三部：按照布局图布局HTML结构(必须与布局图相同) 第四部：在PS中精确测量出ui设计中每个区域的样式并在css中赋值(注意用内部或外链样式表) HTML5 在W3C经历了严格的标签XHTML、css和XHTML的过渡版之后HTML5的标准出现了。它的出现是为了解决Web各种浏览器之间的兼容性低；文档结构不够明确，不够语义化；应用程序功能受限，需要很多额外的插件(如flash) 目前知名浏览器厂商(微软、Google、苹果等)都对HTML5支持(但是目前还有没正式版本，部分内容不完全支持或兼容有问题) HTML5的声明：；元数据标签设置： 当元素去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于SEO(搜索引擎优化)，语义化标签可以和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息——爬虫依赖于标签来确定上下文和各个关键字的权重 方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化 在html5之前只能使用div作为结构元素，而html5新增了很多带有语义的标签 常用HTML5的结构标签 header(双标签)：页眉，用于页面的头部的信息介绍或者板块头部 footer(双标签)：页脚，用于页面的底部或者版块底部 section(双标签)：版块，用于划分页面上的不同区域，或者划分文章里不同的节，属于article的一个部分 hgroup(双标签)：页面上的一个标题组合，一个标题和一个子标题，或者标语的组合 nav(双标签)：导航，包含链接的的一个列表 article(双标签)：用来在页面中表示一套结构完整且独立的内容部分，可以用来呈现论坛的一个帖子，杂志或报纸中的一篇文章，一篇博客，用户提交的评论内容，可互动的页面模块挂件等可以用header/footer/section等来做头部/脚部/部分 aside(双标签)：元素标签可以包含与当前页面或主要内容相关的引用、侧边栏、广告、nav元素组，以及其他类似的有别与主要内容的部分，aside 的内容应该与 article 的内容相关 被包含在article中作为主要内容的附属信息部分，其中的内容 以是与当前文章有关的引用、词汇列表等 在article之外使用，作为页面或站点全局的附属信息部分；最典型的形式是侧边栏(sidebar)，其中的内容可以是友情链接、附属导航或广告单元等]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端样式的初始化和css样式的补充]]></title>
    <url>%2F2019%2F07%2F13%2FWEB%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8Acss%E6%A0%B7%E5%BC%8F%E7%9A%84%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[浏览器的默认样式 同一个标签在不同的浏览器中有不同的默认样式，为了让样式在所有浏览器中统一，并设置一些预定义样式，我们应该做浏览器默认样式的初始化 默认样式的检查方式：可以用border+浏览器开发者工具来查看是否有默认样式 常见的浏览器默认样式 文字斜体和加粗等字体样式：font-weight:normal;font-style:normal; body、ul等区块元素的填充和边距：margin:0; padding:0; li的列表样式：list-style:none; a标签和其状态性伪类的字体颜色和下划线样式： 12345a&#123;text-decoration:none; color:#000; border:0;&#125;a:link&#123;text-decoration:none; color:#000;&#125;a:visited&#123;text-decoration:none; color:#000;&#125; a:hover&#123;text-decoration:none; color:#000;&#125;a:active&#123;text-decoration:none; color:#000;&#125; 设置盒模型的样式：box-sizing:border-box; 也就是说，每写一个网页就要清一次样式，是不是很麻烦呢？别着急，这里准备了一个common.css，每次写网页直接引用就可以啦~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@charset "utf-8";/* CSS Document */*&#123; box-sizing:border-box; color:#000;&#125;body&#123; font-size:14px; font-family:Arial,Verdana,Tahoma,"微软雅黑","黑体"; line-height:1.2em; background:#fff; margin:0; overflow-x:hidden;&#125;p,h1,h2,h3,h4,h5,h6,ul,ol,dl,li,form,table&#123; margin:0; padding:0;&#125;img&#123; vertical-align:middle;&#125;li&#123; list-style:none;&#125;i,em&#123; font-style:normal;&#125;a&#123; text-decoration:none; color:#000000;&#125;a:link&#123; text-decoration:none; color:#000000;&#125;a:visited&#123; text-decoration:none; color:#000000;&#125;a:hover&#123; text-decoration:none; color:#000000;&#125;a:active&#123; text-decoration:none; color:#000000;&#125;.clearfix:after&#123; display:block; content:""; clear:both;&#125;.clearfix&#123; *zoom:1;&#125; CSS样式的补充 改变元素的透明度 12opacity: 0.9; /* 赋值0-1，从透明到完全不透明 */filter: alpha(opacity=90); /* 为了兼容低版本IE浏览器的滤镜 */ 如果是背景颜色需要加透明度就是background-color: rgba(255,255,255,0.5); 隐藏元素 12visibility: hidden/visible; /* 隐藏元素但是依然占位 */display: none/block; /* 隐藏元素但是不占位 */ 注意：虽然visibility: hidden的隐藏元素依然占位，但是它与透明度为0有区别，透明度为0的元素我们依然可以摸到，但是visibiity: hidden的元素却无法摸得到 举个例子： html部分： 123456 &lt;div class="box1"&gt;div1&lt;/div&gt; &lt;div class="box2"&gt;div2&lt;/div&gt; &lt;div class="box3"&gt;div3&lt;/div&gt; &lt;div class="box4"&gt;div4&lt;/div&gt;&lt;!-- 元素透明和visibility隐藏，元素的位置依然保留；而display的none方法，元素的位置消失 --&gt;&lt;!-- 元素透明opacity看得见摸得着，而visibility和display看得见摸不着 --&gt; css部分： 1234567891011121314151617181920212223 div&#123; width: 150px; height: 150px; background-color: red; font-size: 50px; color: white; &#125; /* 设置box1的透明度为0 */ .box1&#123; opacity: 0; &#125; /* 当鼠标点击时box1变为不透明，即可以显示 */.box1:hover&#123; opacity: 1; &#125; /* 设置box2元素为隐藏元素 */ .box2&#123; visibility: hidden; &#125; /* 当鼠标点击时box2不能显示 */ .box2:hover&#123; visibility: visible; &#125; overflow：溢出的部分应该如何显示 12345678overflow-x:hidden; /*水平方向溢出*/overflow-y:auto; /*垂直方向溢出*/overflow:inherit; /*两个方向溢出*/visible：默认值。溢出的内容不会被修剪，会呈现在元素框之外；hidden：溢出的内容会被修剪，并且其余内容是不可见的；(如上面的初始化默认样式中的overflow-x:hidden;，让body的内容在水平方向溢出时裁切，不显示滚动条)scroll：溢出的内容会被修剪，浏览器会显示滚动条以便查看其余的内容；auto：如果溢出的内容被修剪，则浏览器会显示滚动条以便查看其余的内容；inherit：规定应该从父元素继承 overflow 属性的值 百分比单位： 字体的行高使用了百分比，表示字体大小的百分之多少； 盒子模型子元素的宽高百分比=父元素宽高的百分比*子元素的宽高百分比； 子元素的padding和margin设置百分比时却不是对应父元素的内填充和外边距，而是子元素的padding和margin=父元素的宽*子元素的padding和margin的百分比(后面的left和top也是父元素的宽高，需要注意) 背景定位的X/Y=（父元素宽/高-图片宽/高）*背景定位的百分比 最大最小宽高：可以配合上面的百分比宽高一起使用，做一个变化带有范围的效果： 最大宽：max-width: ; 最小宽：min-width: ; 最大高：max-height: ; 最小高：min-heihgt: ; 注：设置最小高度时，当文字超过最小高度的大小时高度会随文字的增多而变高 轮廓线outline（了解）：它是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，它不会占据空间，也不一定是矩形。 1234outline-color:; /*轮廓线颜色*/outline-style:; /*轮廓线样式*/outline-width:; /*轮廓线宽度*/outline-offset:; /*轮廓线扩张*/ 注：写成集合样式outline，如果不设置其中的某个值，也不会出问题，比如 outline:solid #ff0000; 也是允许的 列表元素 列表元素有dl(定义列表)、dt(定义名)、dd(详情)、ul(无序列表)、ol(有序列表)、li(列表的项) 当我们需要把一系列类似的项在页面中展示的时候就要用到列表，比如名词解释(定义列表)、商品列表或导航(无序列表) 它们是一种绑定关系，其中dt和dd必须是dl的子元素，dl也只能用dt和dd作为子元素；li是ul和ol的子元素，ul和ol也只能用li做子元素 ol(有序列表)有一个type属性，可以把值设为1(默认值，数字序列)、A(大写字母序列)、a(小写字母序列)、I(大写罗马数字序列)、i(小写罗马数字序列)，若已经将li的list-style设置为none则样式都会丢失]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装及基本使用]]></title>
    <url>%2F2019%2F07%2F06%2Fgit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[准备工作 下载git 注册github 将git和github连接起来 获取ssh秘钥 id_rsa.pub github里，找到settings，填入秘钥 正式开始 1、确定git和github已经连接 12git initgit remote add origin 仓库地址 2、本地文件推到github上 将新建的文件添加到git的缓存区 1234添加具体名称文件git add index.html添加全部文件git add . 给提交的文件添加描述 1git commit -m &apos;demo&apos; 汇总到总分支上 1git pull origin master --allow-unrelated-histories 退出 1:wq 文件推到远程仓库 123 git push origin mastergit push -u origin master 输入用户名(如果设置了SSH密匙的话就不用输入密码了) 1输入OpenSSH：输入密码 ==如果出现错误== 1git config --global user.email &quot;you@example.com&quot; 一般在push的时候会出现错误1234hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法 先执行git pull origin master 在执行git push origin master==这个时候又可能出现错误== 1fatal: refusing to merge unrelated histories 不用慌，我在网上搜好多方法，都说使用如下指令 12git pull origin master --allow-unrelated-histories git pull --allow-unrelated-histories 但是输入这些指令之后会跳出来另外一个界面然后从新pull就行了 我的解决方法重新在原文件下Git Brush Here然后重新开始就可以解决 无论使用git pull 出不出现错误只要出现刷新github文件就推过来了学习相关git的操作git的学习 廖雪峰的官方网站]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内联块和浮动问题]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%86%85%E8%81%94%E5%9D%97%E5%92%8C%E6%B5%AE%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[内联块和浮动都是为了使区块元素在一行显示 内联块（inline-block） 设置：很简单，直接在css样式中加上display: inline-block;即可 特点： 可以和非区块元素在一行显示 支持所有的样式 不设置宽高时由内容（文字图片等）撑开 换行符会被解析（缺点） 那么，如何去掉内联块之间的空格（换行符）呢？这里有四种方法哦~ a.第一种方法：将后面的内联块设置左外边距为负值，值为父元素大小的0.25倍 举个例子，假设有两个内联块，直接给后面的内联块（第二个）的css样式设置为margin-left:-0.25m; b.第二种方法：用注释去掉换行符 这个方法可能有点不好理解，前面说了，使用内联块换行符会被解析，那么如果给换行符加上注释会不会解决这个问题呢？答案是肯定的~ 举个例子~ 12&lt;div&gt;&lt;/div&gt;&lt;!--加上注释--&gt;&lt;div&gt; &lt;/div&gt; c.第三种方法：设置字间距（letter-spacing）为-0.25倍 也就是css样式里加上letter-spacing:-0.25em; d.第四种方法：将父元素的字体大小设置为0，在子元素里重新设置字体大小 这个方法很容易理解，这里就不举例啦！！ 我们可以发现，使用内联块实现区块元素并排显示其实非常麻烦，那么有没有更加方便的方法呢？ 浮动元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住：float：left/right/none(默认值)，由于子元素脱离文档流，结果会使父元素高度崩塌，解决浮动元素脱离文档流不占位的方法 我们可以看到，浮动会使父元素高度崩塌。Therefore，解决父元素高度崩塌的方法来啦~ 方法1：给父元素设置高度 ​ 局限性：（1）不确定高度时无法使用；（2）在内容、数量不确定时也无法使用 方法2：将父元素设置为BFC盒子，也就是说不能用浮动方法，要在父元素的css样式里写为overflow:hidden; ​ 局限性：在父元素有溢出部分时无法使用 方法3：为所有浮动元素后面设置一个空元素，在里面设置清除浮动clear:both 举个例子：div元素需要左浮动，我们需要在div元素后面设置空元素span 12345678910&lt;style&gt; div&#123; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;span syyle="display:block; clear:both;"&gt;&lt;/span&gt;&lt;/body&gt; ​ 局限性：创建了一个没有任何意义的空标签 方法4：为父元素设置after伪元素，在该元素上设置清除浮动clear:both; ​ 局限性：低版本的IE浏览器不识别 解决办法：用.cearfix{*zoom:1}来兼容 也就是说这个方法几乎没有缺点，是最优方法 好啦让我们来举例叭 假设有4个div元素，其中一个类名为parent元素是父元素（边框为2px black solid），为这三个div元素设置浮动并清除 123456789101112131415161718192021222324&lt;style&gt; .parent&#123; border:2px black solid; &#125; /*设置伪元素，清除浮动*/ .parent::after&#123; display:block; content:""; clear:both; &#125; .parent&gt;div&#123; width:100px; height:100px; background-color:red; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的选择器扩展]]></title>
    <url>%2F2019%2F07%2F01%2Fcss%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分组选择器：注：以下两种书写方式一般没有区别，但也有特殊情况。假设p标签也有一个类名为class，地址名为id的元素，就必须要在最前面加上标签名 12.class,#id /*选择类名为class的所有选择和地址名为id的元素*/div.class,#id /*选择div的所有后代中类名为.class的元素和地址名为id的元素*/ 多条件选择器：同时满足类名为box1和box2的元素 1.box1.box2 /*既有类名为box1的元素同时也有类名为box2的元素*/ 子元素选择器：1div&gt;.class /*选择div元素的所有子元素中有类名为class的元素*/ next选择器：1div+p /*选择div元素的下个同级元素且标签为p的元素*/ 伪类选择器（状态性伪类）：注：以下的标签a的4个伪类必须按照lvha的顺序书写，否则可能会出错 1234 a:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接（正在击中）*/ 举个状态性伪类的例子：设计一个div盒子（宽200px高200px、红色），要求：当鼠标移动该盒子上时盒子变为蓝色，当鼠标点击该盒子时盒子的宽和高分别为500px和150px 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;状态性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:200px; height:200px; background-color:red; &#125; div:hover&#123; background-color:blue; &#125; div:active&#123; width:150px; height:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器（结构性伪类）：注：before 和after中必须设置content(内容)和display(种类)两个样式，否则无法正确显示 1234p::before /*在每个p元素的内容之前插入内容*/p::after /*在每个p元素的内容之后插入元素*/display /*用来修改元素种类，分别有block（区块元素）、inline(内联元素)、inline-block（内联块元素）、none（隐藏元素，不占用物理空间）*/content:"" /*引号里写要显示的内容，如果没有要显示的内容就空着*/ 举个伪元素选择器（结构性伪类）的例子：写一个div元素(300,300)，为它设置before伪元素（区块元素 150px,150px），当你的鼠标移入div时让伪元素背景颜色发生变化，在div上击中时，伪元素隐藏 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;结构性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:300px; height:300px; background-color:brown; &#125; /*先把div元素转换为伪元素*/ div::before&#123; content:""; display:block; width:150px; height:150px; background-color:chartreuse; &#125; /* 鼠标移伪元素时改变颜色 * 格式：div:hover::befere */ div:hover::before&#123; background-color:cornflowerblue; &#125; div:active::before&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于表格的一些基础知识~]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%85%B3%E4%BA%8E%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先让我们认识一些表格标签12345678&lt;table&gt; &lt;!-- 定义表格（必不可少） --&gt;&lt;caption&gt; &lt;!-- 表格标题（默认居中） --&gt;&lt;thead&gt; &lt;!-- 表格表头 --&gt;&lt;tbody&gt; &lt;!-- 表格正文（必不可少） --&gt;&lt;tfoot&gt; &lt;!-- 表格页脚 --&gt;&lt;th&gt; &lt;!-- 表头单元格（加粗黑体） --&gt;&lt;tr&gt; &lt;!-- 表格行 --&gt;&lt;td&gt; &lt;!-- 表格单元格 --&gt; 举个例子： 123456789101112131415&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;我是第一列表头单元格&lt;/th&gt; &lt;th&gt;我是第二列表头单元格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;我是第一列&lt;/td&gt; &lt;td&gt;我是第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 这是一张2行2列的表格，第一行是表头单元格，第二行是表格正文。在浏览器运行后会发现，不仅单元格间有间隙，表格内边距也有。为了解决这个问题，表格属性来啦1234567891011- ##### 表格属性 ```css cellspacing ------单元间间隙(用于table标签) cellpadding ------表格内边距(用于table标签) colspan=&quot;2&quot; ------横向合并单元格(用于td标签)，2代表两个单元格合并 rowspan=&quot;2&quot; ------纵向合并单元格(用于td标签) ```再试一下，在table标签里加入了cellspacing=&quot;0&quot;，cellpadding=&quot;0&quot;后就不存在这样的问题了 表格样式：为表格和单元格设置border等样式，否则无法看到表格边框，除此外table的border-collapse样式，可以用来合并相邻单元格的边框 1border-collapse:collapse; /* 用于table标签中，注：使用该样式时要把单元间间隙（cellsapcing）设为0 */ 以上就是最简单的表格的制作啦~~ 接下来再举一个小例子：（加上css样式和合并单元格）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;简单的表格制作&lt;/title&gt; &lt;style&gt; table,td,th&#123; border:1px black solid; &#125; table&#123; border-collapse:collapse;/*合并相邻的单元格边框*/ &#125; td,th&#123; width:100px; height:30px; text-align:center; /*所有文字居中*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspancing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--第一行的第一列和第二列合并--&gt; &lt;th colspan="2"&gt;第一行第一列表头单元格&lt;/th&gt; &lt;!--&lt;th&gt;第一行第二列表头单元格&lt;/th&gt;*/--&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;td rowspan="2"&gt;我是第二行第一列&lt;/td&gt; &lt;td&gt;我是第二行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;!--&lt;td&gt;我是第三行第一列&lt;/td&gt;--&gt; &lt;td&gt;我是第三行第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 最后来说一下table表格的缺点~ 太深的嵌套，如table&gt;tbody&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了代码量 灵活性差，比如要将tr设置border等属性，是不行的，得通过td 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱 table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间 不够语义，无论是计算机还是阅读代码的人在阅读时都觉得非常困难]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目： 使用冒泡排序编写程序，实现对数组{25,24,12,76,101,96,28}的排序 2.源代码： 123456789101112131415161718192021222324252627package interest;public class pubble &#123; public static void main(String[] args) &#123; int[] arr=&#123;25,24,12,76,101,96,28&#125;; for(int i=0;i&lt;arr.length-1;i++) &#123; for(int j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println(&quot;冒泡排序的结果是：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非负十进制整数转换为b进制数]]></title>
    <url>%2F2019%2F06%2F07%2F%E9%9D%9E%E8%B4%9F%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BAb%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目名称 将非负十进制整数n转换成b进制。（其中b=2~16） 2.算法构造 （1）递归： 十进制数对b进制取余，若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示。然后利用递归模型返回十进制数和b进制的值，最后利用StringBuilder实现逆序输出字符串 递归模型：duigui(n,b)= duigui(n/b,b) n&gt;=0 递归出口：n&lt;b (其中为是十进制数，b为进制数) （2）非递归： 当十进制数不为0时，十进制数对b进制取余，十进制数变为原来的十进制数/b进制。若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示，最后利用StringBuilder实现逆序输出字符串 5.经验归纳 5.1遇到的问题 &lt;1&gt;刚开始用的是数组，结果发现不用循环很难把字符赋给数组 &lt;2&gt;逆序输出那里考虑不周全 &lt;3&gt;用递归树或者递归栈描述调用过程 5.2心得体会 这次的基本要求没有什么难点，主要就是递归函数的建立，非递归比递归简单一些，就是在最后的逆序输出那里会遇到问题，上网查了一下，说是可以用StringBuffer来实现，所以基本上没什么大问题。对了~画出递归树或者递归栈的调用过程这里也是问题，第一次画，对这个概念不是很熟悉。 附：源代码 1.Test0类（主方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;import java.util.Scanner;public class Test0 &#123; static int n; static int b; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); TwoMethods t=new TwoMethods(); System.out.println(&quot;请输入一个非负整数：&quot;); n=sc.nextInt(); while(true) &#123; if(n&lt;0) &#123; System.out.println(&quot;Error！请输入一个非负整数：&quot;); n=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); while(true) &#123; if(b&lt;1||b&gt;16) &#123; System.out.println(&quot;Error！请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;你想使用哪种方法进行运算？1.递归 2.非递归（1/2）：&quot;); int x=sc.nextInt(); switch(x) &#123; case 1: //调用递归方法 t.digui(n,b); break; case 2: t.feidigui(n,b);//调用非递归方法 break; &#125; sc.close(); &#125;&#125; 2.两种方法实现转换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;public class TwoMethods &#123; static String a=&quot;&quot;; //定义一个字符串，用来存储b进制 static int num; //b进制数 public static void feidigui(int n,int b) //非递归 &#123; while(n&gt;0) //当十进制数不为0时 &#123; num=n%b; //十进制数对b进制取余 n=n/b; //十进制数变为原来的十进制数/b进制 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; &#125; System.out.println(&quot;用非递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; public void digui(int n,int b) //递归 &#123; if(n!=0) &#123; num=n%b; //十进制数对b进制取余 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; digui(n/b,b); //利用递归模型返回十进制数和b进制的值 &#125; else &#123; System.out.println(&quot;用递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的递归程序]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目名称 &lt;1&gt;赶鸭子问题：一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？ &lt;2&gt;角谷定理：输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。 如：输入22， 输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 STEP=16 2.题目分析 &lt;1&gt;赶鸭子问题：假设一共有sum只鸭子，而sum=one(n)，n表示村子数，每经过一个村子就卖出one(n)/2+1只鸭子，剩下的就是下一个村子的鸭子数，也就是one(n+1)，那么鸭子总数one(n)=(one(n)/2+1)+(one(n+1))，经过运算得出鸭子总数one(n)=(one(n+1)+1)_2；题目说这个人经过七个村子后还剩两只鸭子，也就是在第8个村子的时候还有两只鸭子，也就是one(8)=2 &lt;2&gt;角谷定理：这个题的递归出口是固定的，即当得到自然数值1的时候递归结束。假设经过了sum=one(x)次操作后得到自然数1，输入的自然数一共分为3种情况，第一种是x=1，这种情况很特殊，直接sum+1输出即可；第二种情况是x为偶数，按照题目要求，将这个数有限次除以2，也就是one(x/2)，并使sum递加；第三种情况是x为奇数，将这个数有限次乘以3再加1，也就是one(x_3+1)，并使sum递加 3.算法构造 4.心得体会 递归问题主要还是数学思维，我觉得第一个题用递归方法偏难一点，但是算法构造出来实现就简单了，这两个题学C语言的时候有接触过，所以还有印象。这两道题相对以前的作业简单很多~ 附：源代码： &lt;1&gt;赶鸭子问题： 123456789101112131415161718192021222324252627282930package DuckSale;public class 卖鸭子递归 &#123; static int sum; public static void main(String[] args) &#123; int n=1; int num;//每个村子卖出的鸭子数 int sum=one(n); //刚开始的鸭子数,n个村子 System.out.println(&quot;刚开始有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++)//循环输出经过每个村子卖出的鸭子数 &#123; num=sum/2+1; sum-=num; //剩余鸭子数 System.out.println(&quot;经过第&quot;+i+&quot;个村子卖出了&quot;+num+&quot;只鸭子,还剩下&quot;+sum+&quot;只鸭子&quot;); &#125; &#125; public static int one(int n) &#123; if(n&lt;8) &#123; return 2*(one(n+1)+1); &#125; else if(n==8) &#123; return 2; &#125; return n; &#125;&#125; ②非递归实现： 1234567891011121314151617181920package DuckSale;public class 卖鸭子非递归&#123; static int sum=2;//鸭子总数 public static void main(String[] args) &#123; int num; for(int i=1;i&lt;8;i++) &#123; sum=(sum+1)*2;//循环计算出鸭子总数 &#125; System.out.println(&quot;一共有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++) &#123; num=sum/2+1; sum-=num; System.out.println(&quot;经过第&quot;+i+&quot;个村子卖了&quot;+num+&quot;只鸭子，还剩&quot;+sum+&quot;只鸭子&quot;); &#125; &#125;&#125; &lt;2&gt;角谷定理： ①递归实现： 12345678910111213141516171819202122232425262728293031323334353637package JiaoGuTheory;import java.util.Scanner;public class 角谷定理递归 &#123; static int sum=0; //计算次数 public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); int sum=one(x); System.out.println(); System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125; public static int one(int x) &#123; if(x==1) //输入的自然数为1 &#123; System.out.print(x+&quot; &quot;); sum++; &#125; else if(x%2==0) //输入的自然数为偶数 &#123; System.out.print(x+&quot; &quot;); one(x/2);//将这个数有限次除以2 sum++; &#125; else if(x%2!=0) //输入的自然数为奇数 &#123; System.out.print(x+&quot; &quot;); one(x*3+1); //将这个数有限次乘以3再加1 sum++; &#125; return sum; &#125;&#125; ②非递归实现： 1234567891011121314151617181920212223242526272829303132333435package JiaoGuTheory;import java.util.Scanner;public class 角谷定理非递归 &#123; static int sum=0; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); while(x&gt;=1) &#123; if(x==1) &#123; sum++; System.out.println(x); break; &#125; else if(x%2==0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x/2; &#125; else if(x%2!=0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x*3+1; &#125; &#125; System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟肯德基快餐店的收银系统]]></title>
    <url>%2F2019%2F05%2F10%2FJava%E6%A8%A1%E6%8B%9F%E8%82%AF%E5%BE%B7%E5%9F%BA%E5%BF%AB%E9%A4%90%E5%BA%97%E7%9A%84%E6%94%B6%E9%93%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1.题目名称 模拟肯德基快餐店的收银系统 要求：结合设计模式（2种以上）至少实现系统的以下功能： 1.正常餐品结算和找零。 2.基本套餐结算和找零。 3.使用优惠劵购买餐品结算和找零。 4.可在一定时间段参与店内活动（自行设计或参考官网信息）。 5.模拟打印小票的功能（写到文件中）。 2.算法构造 这个系统需要用到两种设计模式，分别是工厂方法模式和抽象工厂模式。 &lt;1&gt;工厂方法模式：在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口。 抽象工厂(IKfcFactory)：给出具体工厂必须实现的接口； 具体工厂(ChinaKfcFactory)：在该工厂中指明生产各种抽象食物的方法：生产汉堡、薯条、鸡翅、饮料、套餐1、套餐2； 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：负责输出用户的订单信息 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：这个工厂需要生产具体的食品：麻辣奥尔良烤堡、奥尔良烤翅、普通霸王薯条、可乐饮料。 &lt;2&gt;抽象工厂模式：抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 抽象工厂(AbstractBaseFood) 具体工厂(ChinaKfcFactory) 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：相当于产品等级 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：相当于产品族，生产出具体的食物 客户类(Customer)：向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 3.类图 4.调试及运行结果 4.1调试结果 4.2运行结果 1.选择单点： 2.选择套餐 4.文件里的账单（在eclipse中打开.txt文件） 5.经验归纳 5.1遇到的问题 &lt;1&gt;将账单写入文件后.txt文件里什么都没有~ &lt;2&gt;不熟悉抽象工厂模式，将工厂方法模式和抽象方法模式混在一起了 &lt;3&gt;单品的种类太少，抽象工厂模式运用的不全面 &lt;4&gt;该系统还存在一些不足，打算后期进行优化 5.2心得体会 这个系统中，最核心的就是设计模式的选择与应用了！个人感觉我做的系统用的工厂方法模式比抽象工厂模式全面一些，因为每一种食品只有一种，没有分很多种，所以产品族的产品对象是不全面的。 还有一个很大的问题，就是账单没有办法写入文件中。我选择的是FileWriter方法将账单写入文件的，然而文件中却什么都没有。后来我发现在eclipse中打开.txt文件，账单是在文件里的，所以我没有用记事本打开.txt文件，而是选择了eclipse。 其实我觉得界面可以用Java的图形图像处理来实现，还涉及到数据库，打算考完试实现一下~~ 附：源代码 1.AbstractBaseFood接口 1234567891011121314151617package inter.KFC;//食物基类 public abstract class AbstractBaseFood &#123; //类别 protected String kind; //数量 protected int num; //价格 protected int price; //合计 public int totalPrice() &#123; return this.num * this.price; &#125;&#125; 2.抽象食物接口IFood 123456789package inter.KFC; //抽象食物接口 public interface IFood &#123; //打印输出食物信息 void printMessage();&#125; 3.肯德基抽象工厂接口IKfcFactory 12345678910111213141516171819202122232425package inter.KFC;//肯德基抽象工厂 public interface IKfcFactory &#123; //生产汉堡 public Hamburg createHamburg(int num); //生产薯条 public FrenchFries createFrenchFries(int num); //生产鸡翅 public ChickenWings createChickenWings(int num); //生产饮料 public Beverage createBeverage(int num); //生产套餐1 public TaoCan1 createTaoCan1(int num); //生产套餐2 public TaoCan2 createTaoCan2(int num);&#125; 4.肯德基具体工厂ChinaKfcFactory继承接口IKfcFactory 123456789101112131415161718192021222324252627282930313233343536package inter.KFC;//肯德基具体工厂public class ChinaKfcFactory implements IKfcFactory&#123; //生产汉堡 public Hamburg createHamburg(int num) &#123; return new ChinaHamburg(num); &#125; //生产薯条 public FrenchFries createFrenchFries(int num) &#123; return new ChinaFrenchFries(num); &#125; //生产鸡翅 public ChickenWings createChickenWings(int num) &#123; return new ChinaChickenWings(num); &#125; //生产饮料 public Beverage createBeverage(int num) &#123; return new ChinaBeverage(num); &#125; //生产套餐1 public TaoCan1 createTaoCan1(int num) &#123; return new RealTaoCan1(num); &#125; //生产套餐2 public TaoCan2 createTaoCan2(int num) &#123; return new RealTaoCan2(num); &#125; &#125; 5.客户类Customer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package inter.KFC;//客户类public class Customer &#123; //抽象工厂 private IKfcFactory kfcFactory; //构造方法将抽象工厂作为参数传入 public Customer(IKfcFactory kfcFactory)&#123; this.kfcFactory = kfcFactory; &#125; //订购食物 //订购麻辣鸡腿汉堡 public int orderHamburg(int num)&#123; //获得奥尔良烤堡 Hamburg hamburg = kfcFactory.createHamburg(num); //输出订购信息 hamburg.printMessage(); //返回总价 return hamburg.totalPrice(); &#125; //订购奥尔良烤翅 public int orderChickenWings(int num)&#123; //获得奥尔良烤鸡翅 ChickenWings chickenWings = kfcFactory.createChickenWings(num); //输出订购信息 chickenWings.printMessage(); //返回总价 return chickenWings.totalPrice(); &#125; //订购薯条 public int orderFrenchFries(int num)&#123; //获得霸王薯条 FrenchFries frenchFries = kfcFactory.createFrenchFries(num); //输出订购信息 frenchFries.printMessage(); //返回总价 return frenchFries.totalPrice(); &#125; //订购可乐 public int orderBeverage(int num)&#123; //获得可乐 Beverage beverage = kfcFactory.createBeverage(num); //输出订购信息 beverage.printMessage(); //返回总价 return beverage.totalPrice(); &#125; //订购套餐1 public int orderTaoCan1(int num)&#123; //获得套餐1 TaoCan1 taocan1=kfcFactory.createTaoCan1(num); //输出订购信息 taocan1.printMessage(); //返回总价 return taocan1.totalPrice(); &#125; //订购套餐2 public int orderTaoCan2(int num)&#123; //获得套餐2 TaoCan2 taocan2=kfcFactory.createTaoCan2(num); //输出订购信息 taocan2.printMessage(); //返回总价 return taocan2.totalPrice(); &#125;&#125; 6.汉堡基类Hamburg 1234567891011package inter.KFC;//汉堡基类 public abstract class Hamburg extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;奥尔良烤堡，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 7.汉堡子类(具体产品实现)ChinaHamburg 12345678910111213package inter.KFC;//奥尔良烤堡//具体产品public class ChinaHamburg extends Hamburg&#123; public ChinaHamburg(int num) &#123; this.kind = &quot;麻辣&quot;; this.price = 28; this.num = num; &#125;&#125; 8.薯条基类(抽象产品)FrenchFries 123456789101112package inter.KFC;//薯条基类//抽象产品public abstract class FrenchFries extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;霸王薯条，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 9.薯条子类(具体产品实现)ChinaFrenchFries 123456789101112package inter.KFC;//薯条实现类//具体产品public class ChinaFrenchFries extends FrenchFries&#123; public ChinaFrenchFries(int num) &#123; this.kind = &quot;普通&quot;; this.price = 8; this.num = num; &#125;&#125; 10.鸡翅基类(抽象产品)ChickenWings 1234567891011package inter.KFC;//鸡翅基类public abstract class ChickenWings extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;烤翅，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 11.鸡翅子类(具体产品实现)ChinaChickenWings 123456789101112package inter.KFC;//鸡翅实现类 //具体产品public class ChinaChickenWings extends ChickenWings&#123; public ChinaChickenWings(int num) &#123; this.kind = &quot;奥尔良&quot;; this.price = 5; this.num = num; &#125;&#125; 12.饮料基类(抽象产品)Beverage 1234567891011package inter.KFC;//饮料基类 public abstract class Beverage extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;饮料，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 13.饮料子类(具体产品实现)ChinaBeverage 1234567891011package inter.KFC;//可乐实现类public class ChinaBeverage extends Beverage&#123; public ChinaBeverage(int num) &#123; this.kind = &quot;可乐&quot;; this.price = 10; this.num = num; &#125;&#125; 14.套餐1基类(抽象产品)TaoCan1 12345678910package inter.KFC;//套餐1基类public abstract class TaoCan1 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐1，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 15.套餐1子类(具体产品实现)RealTaoCan1 1234567891011package inter.KFC;//套餐1实现类public class RealTaoCan1 extends TaoCan1&#123; public RealTaoCan1(int num) &#123; this.kind = &quot;超值&quot;; this.price = 50; this.num = num; &#125;&#125; 16.套餐2基类(抽象产品)TaoCan2 12345678910package inter.KFC;//套餐2基类public abstract class TaoCan2 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐2，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 17.套餐2子类(具体产品实现)RealTaoCan2 1234567891011package inter.KFC;//套餐2实现类public class RealTaoCan2 extends TaoCan2&#123; public RealTaoCan2(int num) &#123; this.kind = &quot;超值&quot;; this.price = 40; this.num = num; &#125;&#125; 18.菜单类MainMenu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package inter.KFC;import java.util.Scanner;import java.io.*;import java.io.FileWriter;//菜单public class MainMenu &#123; //定义一个肯德基（IKfcFactory类型） IKfcFactory kfcFactory = new ChinaKfcFactory(); //创建客户 Customer customer = new Customer(kfcFactory); Scanner sc=new Scanner(System.in); public int a; public int num1; public int num2; public int num3; public int num4; public int num5; public int num6; int hamburgMoney=customer.orderHamburg(num1); int chickenWingsMoney = customer.orderChickenWings(num2); int frenchFriesMoney = customer.orderFrenchFries(num3); int singleMoney = customer.orderBeverage(num4); int taocan1Money =customer.orderTaoCan1(num5); int taocan2Money =customer.orderTaoCan2(num6); public int price; public String b; public int c; public int d; //用户付款金额 public int e; //找零 public void menu() &#123; System.out.println(&quot;* * * * * 欢迎进入肯德基炸鸡店 * * * * *&quot;); System.out.println(&quot;* 您可以选择：1.单点 2.套餐 *&quot;); System.out.println(&quot;* 请您选择：&quot;); a=sc.nextInt(); switch(a) &#123; case 1: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;1.汉堡类：奥尔良烤堡_28元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;2.鸡翅类：奥尔良烤翅_5元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;3.小食类：霸王薯条_8元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;4.饮料类：可乐_10元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择奥尔良烤堡的数量：&quot;); num1=sc.nextInt(); hamburgMoney = customer.orderHamburg(num1); System.out.print(&quot;请您选择奥尔良烤翅的数量：&quot;); num2=sc.nextInt(); chickenWingsMoney = customer.orderChickenWings(num2); System.out.print(&quot;请您选择霸王薯条的数量：&quot;); num3=sc.nextInt(); frenchFriesMoney = customer.orderFrenchFries(num3); System.out.print(&quot;请您选择可乐的数量：&quot;); num4=sc.nextInt(); singleMoney = customer.orderBeverage(num4); price=hamburgMoney+chickenWingsMoney+frenchFriesMoney+singleMoney; System.out.println(&quot;总计：&quot;+price); break; case 2: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐1：奥尔良烤堡+霸王薯条+可乐_50元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐2：香辣鸡腿堡+麻辣烤翅+可乐_40元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择套餐1的数量：&quot;); num5=sc.nextInt(); taocan1Money =customer.orderTaoCan1(num5); System.out.print(&quot;请您选择套餐2的数量：&quot;); num6=sc.nextInt(); taocan2Money =customer.orderTaoCan2(num6); price=taocan1Money+taocan2Money; System.out.println(&quot;总计：&quot;+price); &#125; &#125; //领取优惠券并付款找零 public void other()&#123; System.out.println(&quot;为迎接新老顾客的到来，本店特地准备了两种优惠券&quot;); System.out.println(&quot;---1.满45减5 ---2.满65减8&quot;); System.out.print(&quot;您是否需要优惠券？(y/n)&quot;); String b=sc.next(); if(&quot;y&quot;.equals(b)) &#123; if(price&gt;=45&amp;&amp;price&lt;65) //价格在45-65之间领取5元 &#123; price-=5; c=5; //5元优惠券 &#125; else if(price&gt;=65) //价格&gt;=65领取8元 &#123; price-=8; c=8; &#125; else System.out.println(&quot;您不能使用优惠券！&quot;); System.out.println(&quot;领取&quot;+c+&quot;元优惠券成功！您一共消费：&quot;+price+&quot;元&quot;); &#125; System.out.print(&quot;付款：&quot;); d=sc.nextInt(); e=d-price; System.out.println(&quot;找零：&quot;+e); &#125; //打印账单 public void paint()&#123; System.out.print(&quot;您需要打印账单吗？(y/n)&quot;); String m=sc.next(); if(&quot;y&quot;.equals(m))&#123; //用户需要打印小票 System.out.println(&quot;您的账单为：&quot;); switch(a)&#123; case 1: hamburgMoney=customer.orderHamburg(num1); chickenWingsMoney = customer.orderChickenWings(num2); frenchFriesMoney = customer.orderFrenchFries(num3); singleMoney = customer.orderBeverage(num4); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; case 2: taocan1Money =customer.orderTaoCan1(num5); taocan2Money =customer.orderTaoCan2(num6); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; &#125; try&#123; fully(); &#125;catch(Exception e)&#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; else if(&quot;n&quot;.equals(m))&#123; System.out.println(&quot;欢迎下次光临~&quot;); &#125; &#125; //在文件中打印小票 public void fully() throws Exception&#123; FileWriter pw=new FileWriter(&quot;zhangdan.txt&quot;,true); BufferedWriter bw=new BufferedWriter(pw); try &#123; switch(a) &#123; case 1: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;麻辣奥尔良烤堡 &quot;+&quot;单价：28 数量：&quot;+num1+&quot;合计：&quot;+hamburgMoney+&quot;\r\n&quot;); bw.write(&quot;奥尔良烤翅 &quot;+&quot;单价：5 数量：&quot;+num2+&quot;合计：&quot;+chickenWingsMoney+&quot;\r\n&quot;); bw.write(&quot;普通霸王薯条 &quot;+&quot;单价：8 数量：&quot;+num3+&quot;合计：&quot;+frenchFriesMoney+&quot;\r\n&quot;); bw.write(&quot;可乐饮料 &quot;+&quot;单价：10 数量：&quot;+num4+&quot;合计：&quot;+singleMoney+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; case 2: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;超值套餐1 &quot;+&quot;单价：50 数量：&quot;+num5+&quot;合计：&quot;+taocan1Money+&quot;\r\n&quot;); bw.write(&quot;超值套餐2 &quot;+&quot;单价：40 数量：&quot;+num6+&quot;合计：&quot;+taocan2Money+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;打印成功！欢迎下次光临~&quot;); &#125; &#125; 19.主函数MainApp 12345678910111213141516package inter.KFC;import java.util.*;import java.text.*; //获取当前系统时间public class MainApp &#123; public static void main(String[] args) &#123; Date date=new Date(); DateFormat fullFormat=DateFormat.getDateInstance(DateFormat.FULL); System.out.println(&quot;当前日期：&quot;+fullFormat.format(date)); //引用菜单类 MainMenu mainmenu=new MainMenu(); mainmenu.menu(); mainmenu.other(); mainmenu.paint(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种简单的程序设计模式实例]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.题目名称 (1)简单工厂模式 使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果传入参数M，则返回一个Man对象，如果传入参数W，则返回一个Woman对象，请实现该场景。现需要增加一个新的Robot类，如果传入参数R，则返回一个Robot对象，对代码进行修改并注意女娲的变化。 (2)工厂方法模式 海尔工厂(Haier)生产海尔空调(HaierAirCondition)，美的工厂(Midea)生产美的空调(MideaAirCondition) 。使用工厂方法模式描述该场景，绘制类图并编程实现。(3)抽象工厂模式 电脑配件生产工厂生产内存、CPU等硬件设备，这些内存、CPU的品牌、型号并不一定相同，根据下面的“产品等级结构-产品族”示意图，使用抽象工厂模式实现电脑配件生产过程并绘制相应的类图，绘制类图并编程实现。 2.题目分析 (1)简单工厂模式 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 &lt;1&gt;工厂角色(Nvwa)：实现所有实例的内部逻辑； &lt;2&gt;抽象产品角色(Person)：所有对象的父类，负责描述所有实例共有的公共接口； &lt;3&gt;具体产品角色(Man,Woman,Robot)：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实现； &lt;4&gt;XML配置文件(XMLUtilNvwa,Simple.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (2)工厂方法模式 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 &lt;1&gt;抽象产品(KongTiao)：产品对象同一的基类，或者是同一的接口； &lt;2&gt;具体产品(Haier,Midea)：各个不同的实例对象类； &lt;3&gt;抽象工厂(KongTiaoFactory)：所有的子类工厂类的基类，或是同一的接口； &lt;4&gt;具体工厂(HaierFactory,MideaFactory)：负责每个不同的产品对象的实际创建； &lt;5&gt;XML配置文件(XMLUtil,FactoryMethod.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (3)抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 产品等级结构：即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 &lt;1&gt;抽象工厂(ComputerFactory)：模式的核心，通常是接口或抽象类，其他的具体工厂类必须实现这个接口或继承这个抽象类； &lt;2&gt;具体工厂(macFactory,pcFactory)：直接在客户端的调用下创建产品的实例； &lt;3&gt;抽象产品(CPU,RAM)：工厂模式所创建的对象的父类，或他们共同的接口； &lt;4&gt;具体产品(pcCPU,macCPU,pcRAM,macRAM)：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。 &lt;5&gt;XML配置文件(XMLUtil,AbstractFactory.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 3.类图设计 (1)简单工厂模式： (2)工厂方法模式： (3)抽象工厂模式： 4.经验归纳 4.1遇到的问题 &lt;1&gt;对三种模式都不太熟悉，花费的时间较多 &lt;2&gt;不懂如何解析xml文档 &lt;3&gt;eclipse版本问题导致XMLUtil代码有错误，但可以运行 4.2心得体会 第一次编写程序设计模式的代码，刚开始觉得无从下手。对三种模式不熟悉，导致花费了较多的时间，所以一直在查资料。特别实在xml文档那块，我一直没搞懂为什么要写文档而不直接用输入输出流，结果发现是将参数保存在XML的配置文件中，这样修改参数的时候就没有必要修改任何Java源代码。但是这块还是挺薄弱的，写代码的时候也不能独立完成，还需要参考老师给的代码。第一个简单工厂模式挺简单的，第三个比较难（我觉得），所以要多练习抽象工厂模式的习题~ 附：源代码 (1)简单工厂模式 &lt;1&gt;抽象产品角色(父类):Person 12345package Nvwa;public interface Person&#123; public void make();&#125; &lt;2&gt;工厂角色(实现内部逻辑):Nvwa 1234567891011121314151617181920212223242526package Nvwa;public class Nvwa &#123; public static Person producePerson(String sex) throws Exception &#123; if(sex.equalsIgnoreCase(&quot;M&quot;)) //选择&apos;M&apos; &#123; System.out.println(&quot;造了一个男人！&quot;); return new Man(); //返回参数 &#125; else if(sex.equalsIgnoreCase(&quot;W&quot;))//选择&apos;W&apos; &#123; System.out.println(&quot;造了一个女人！&quot;); return new Woman(); &#125; else if(sex.equalsIgnoreCase(&quot;R&quot;))//选择&apos;R&apos; &#123; System.out.println(&quot;造了一个机器人！&quot;); return new Robet(); &#125; else &#123; throw new Exception(&quot;对不起，女娲正在忙，没空造人！&quot;); &#125; &#125;&#125; &lt;3&gt;具体产品角色(实现类):Man,Woman,Robet: Man: 12345678package Nvwa;public class Man implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造男人...&quot;); &#125;&#125; Woman: 12345678package Nvwa;public class Woman implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造女人...&quot;); &#125;&#125; Robot: 12345678package Nvwa;public class Robet implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造机器人...&quot;); &#125;&#125; &lt;4&gt;XML配置文件(方便修改参数):XMLUtilNvwa,Simple.xml XMLUtilNvwa： 12345678910111213141516171819202122232425262728293031XMLUtilNvwa：package Nvwa;import javax.xml.parsers.*;import org.w3c.dom.*;//import org.xml.sax.SAXException;import java.io.*;public class XMLUtilNvwa &#123; //该方法用于从XML配置文件中提取名称，并返回该名称 public static String getSexName() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;Simple.xml&quot;)); //获取包含名称的文本节点 NodeList nl = doc.getElementsByTagName(&quot;sexName&quot;); Node classNode=nl.item(0).getFirstChild(); String sexName=classNode.getNodeValue().trim(); return sexName; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; Simple.xml: 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;sexName&gt;M&lt;/sexName&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 123456789101112131415161718package Nvwa;public class Client &#123; public static void main(String args[]) &#123; try &#123; Person pe; String sexName=XMLUtilNvwa.getSexName(); pe=Nvwa.producePerson(sexName); pe.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (2)工厂方法模式 &lt;1&gt;抽象产品：KongTiao 12345package FactoryMethod;public interface KongTiao &#123; public void make();&#125; &lt;2&gt;具体产品：Haier,Midea Haier： 12345678package FactoryMethod;public class Haier implements KongTiao&#123; public void make() &#123; System.out.println(&quot;海尔空调正在使用...&quot;); &#125;&#125; Midea： 12345678package FactoryMethod;public class Midea implements KongTiao&#123; public void make() &#123; System.out.println(&quot;美的空调正在使用...&quot;); &#125;&#125; &lt;3&gt;抽象工厂：KongTiaoFactory 12345package FactoryMethod;public interface KongTiaoFactory &#123; public KongTiao produceKT();&#125; &lt;4&gt;具体工厂：HaierFactory,MideaFactory HaierFactory： 123456789package FactoryMethod;public class HaierFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---海尔工厂正在生产海尔空调 &quot;); return new Haier(); &#125;&#125; MideaFactory： 12345678package FactoryMethod;public class MideaFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---美的工厂正在生产美的空调 &quot;); return new Midea(); &#125; &lt;5&gt;XML配置文件：XMLUtil,FactoryMethod.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123; //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;FactoryMethod.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; FactoryMethod.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;FactoryMethod.HaierFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 1234567891011121314151617package FactoryMethod;public class Client &#123; public static void main(String[] args) &#123; try&#123; KongTiao kt; KongTiaoFactory fa; fa=(KongTiaoFactory)XMLUtil.getBean(); kt=fa.produceKT(); kt.make(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (3)抽象工厂模式 &lt;1&gt;抽象工厂：ComputerFactory 123456package AbstractFactory;public interface ComputerFactory &#123; public CPU produceCPU(); public RAM produceRAM();&#125; &lt;2&gt;具体工厂：macFactory,pcFactory macFactory： 12345678910111213141516171819package AbstractFactory;public class macFactory implements ComputerFactory&#123; //生产macCPU public CPU produceCPU() &#123; System.out.println(&quot;生产了macCPU...&quot;); //CPU macCPU; return new macCPU(); &#125; //生产macRAM public RAM produceRAM() &#123; System.out.println(&quot;生产了macRAM...&quot;); return new macRAM(); &#125;&#125; pcFactory： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; &lt;3&gt;抽象产品：CPU,RAM CPU： 12345package AbstractFactory;public interface CPU &#123; public void make();&#125; RAM： 12345package AbstractFactory;public interface RAM &#123; public void make();&#125; &lt;4&gt;具体产品：pcCPU,macCPU,pcRAM,macRAM pcCPU： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; macCPU： 12345678package AbstractFactory;public class macCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;macCPU&quot;); &#125;&#125; pcRAM： 12345678package AbstractFactory;public class pcRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;pcRAM&quot;); &#125;&#125; macRAM： 12345678package AbstractFactory;public class macRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;macRAM&quot;); &#125;&#125; &lt;5&gt;XML配置文件：XMLUtil,AbstractFactory.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package AbstractFactory;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123;//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;AbstractFactory.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125;catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; AbstractFactory.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;AbstractFactory.macFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 12345678910111213141516171819202122package AbstractFactory;public class Client &#123; public static void main(String[] args) &#123; try &#123; ComputerFactory fac; CPU cpu; RAM ram; fac=(ComputerFactory)XMLUtil.getBean(); cpu=fac.produceCPU(); cpu.make(); ram=fac.produceRAM(); ram.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建RPG游戏角色]]></title>
    <url>%2F2019%2F04%2F17%2FJava%E5%88%9B%E5%BB%BARPG%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[◆题目名称 创建RPG游戏角色 ◆题目分析 该程序需要用到有关类与对象的知识点，所以不能使用C语言来编写代码，这里我选择Java语言。本题目要求的游戏角色应有以下属性：名字、性别、种族、职业、力量、敏捷、体力、智力、智慧、生命值和魔法值。本题目要求力量、敏捷、体力、智力和智慧要求是随机值（利用随机数函数来取得随机数），但是五项属性的总和应该是100，并且应该和职业相关。例如狂战士的体力和力量就要比较高，而巫师需要较高的智力，而祭司则需要较高的智慧。各职业初始属性的大致比例应遵从下表： 职业/属性 力量 敏捷 体力 智力 智慧 狂战士 40 20 30 5 5 圣骑士 25 15 30 20 10 刺客 20 35 20 15 10 猎手 15 40 15 10 20 祭司 15 20 15 35 15 巫师 10 20 10 20 40 例如，前面示意图中的祭司的初始属性，大致满足该比例，但是应该是随机的。然后利用属性值计算生命值和魔法值。 最后向用户显示该角色的所有信息，将用户创建角色的相关信息写入文件保存。 ◆算法构造 &lt;1&gt;玩家选择1，则进入游戏；选择2，可以查看游戏规则；选择3，则游戏结束。 &lt;2&gt;选择1：玩家先输入角色姓名、性别、种族以及职业，根据种族和职业的限制表判断玩家是否可以使用该职业，若不能则重新选择职业； &lt;3&gt;利用随机函数分别生成力量、敏捷、体力、智力和智慧五项属性，并将五项属性的总和控制在100，并且属性值和职业相关。可以由(int)(X+Math.random()_10-5)可以得到符合条件的属性值，其中X表示表1中的属性限定值，并计算生命值和魔法值：生命值=体力_20、魔法值=（智力+智慧）*10； &lt;4&gt;打印所有的信息并向用户显示出来； &lt;5&gt;将用户创建角色的相关信息写入txt文件保存。 ◆算法实现 写入文件代码： 123456789101112131415161718192021222324public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125; ◆调试及运行结果 ◆◆调试结果 ◆运行结果 ◆◆文件保存情况 ◆经验归纳 ◆◆遇到的问题 &lt;1&gt;对于Java中的类和对象用的还不是很熟练(还在努力学习中) &lt;2&gt;Java引用写入文件方法出问题(已解决) &lt;3&gt;Java写入文件方法内部出现异常(已解决) &lt;4&gt;IO流未声明(已解决) ◆◆心得体会 用Java写这个程序，让我查了不少有关Java的知识点。在类与对象那块还不太熟悉，其中，有一些知识点是值得记录的： ①访问另一个类中的某个方法：Start g=new Start();g.start(); ②对象引用：Random r=new Random();r.n=name; ③随机函数生成某个值：strength=(int)(40+Math.random()*10-5)(40是限制条件) ④调用写入文件方法： 12345try &#123; REFile(occ);&#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); 在百度文库查找资料的时候我发现可以将这个代码优化，即编为小游戏的形式，我打算找时间写一下。 附：源代码(部分代码参考百度文库) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package game;import java.io.*;import java.util.Scanner;import java.io.FileWriter;public class First &#123; public static void main(String[] args)&#123; //菜单 System.out.println(&quot;这是一个RPG游戏&quot;); System.out.println(&quot;1.开始游戏&quot;); System.out.println(&quot;2.游戏规则&quot;); System.out.println(&quot;3.结束游戏&quot;); System.out.print(&quot;请输入您想进行的操作：(1-3)&quot;); Scanner x=new Scanner(System.in); int num=x.nextInt(); switch(num)&#123; case 1: Start g=new Start(); g.start(); //访问Start类中的start方法开始创建角色 break; case 2: Rule r=new Rule(); r.rule(); //访问Rule类中的rule方法查看规则 break; default: System.out.println(&quot;游戏结束!&quot;); System.exit(0); //游戏结束标识 &#125; &#125;&#125;//开始游戏class Start&#123; int occ=0; String name; public void start()&#123; System.out.print(&quot;请输入您游戏角色的姓名：&quot;); Scanner a=new Scanner(System.in); String name=a.next(); System.out.print(&quot;请选择您游戏角色的性别：(男或女)&quot;); Scanner b=new Scanner(System.in); String sex=b.next(); System.out.print(&quot;请选择您游戏角色的种族：(1.人类,2.精灵,3.兽人,4.矮人,5.元素)&quot;); Scanner c=new Scanner(System.in); int race=c.nextInt(); switch(race)&#123; //职业选择 case 1: //种族为人类 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=1&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1-6之间的数字选择职业！！&quot;); &#125; break; case 2: //种族为精灵 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=3&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入3-6之间的数字选择职业！！&quot;); &#125; break; case 3: //种族为兽人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==4||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,4,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 4: //种族为矮人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==2||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,2,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 5: //种族为元素 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==5||occ==6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入5-6之间的数字选择职业！！&quot;); &#125; break; &#125; Random r=new Random(); r.n=name; //将姓名、性别、种族对象引用到Random类中 r.s=sex; r.ra=race; r.random(occ);//将职业传递到Random类的random方法中 &#125;&#125;//class Random&#123; String n; String s; int ra; int strength=0; //力量 int smart=0; //敏捷 int body=0; //体力 int talent=0; //智力 int wisdom=0; //智慧 int life=0; //生命值 int magic=0; //魔法值 public void random(int occ)&#123; //随机函数生成各个值 System.out.println(occ); if(occ==1) &#123; strength=(int)(40+Math.random()*10-5);//随机函数生成符合题目条件的各个值 smart=(int)(20+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(5+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==2)&#123; strength=(int)(25+Math.random()*10-5); smart=(int)(15+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==3)&#123; strength=(int)(20+Math.random()*10-5); smart=(int)(35+Math.random()*10-5); body=(int)(20+Math.random()*10-5); talent=(int)(15+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==4)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(40+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(10+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==5)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(35+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==6)&#123; strength=(int)(10+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(10+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; life=body*20; //计算生命值和魔法值 magic=(talent+wisdom)*10; print(occ); //调用打印方法 try &#123; //调用写入文件方法 REFile(occ); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //打印 public void print(int occ)&#123; System.out.println(&quot;* * * * * * * * * * * * *&quot;); System.out.println(&quot;* 姓名：&quot;+n+&quot; *&quot;); System.out.println(&quot;* 性别：&quot;+s+&quot; *&quot;); System.out.println(&quot;* 种族：&quot;+ra+&quot; *&quot;); System.out.println(&quot;* 职业：&quot;+occ+&quot; *&quot;); System.out.println(&quot;* 力量：&quot;+strength+&quot; *&quot;); System.out.println(&quot;* 敏捷：&quot;+smart+&quot; *&quot;); System.out.println(&quot;* 体力：&quot;+body+&quot; *&quot;); System.out.println(&quot;* 智力：&quot;+talent+&quot; *&quot;); System.out.println(&quot;* 智慧：&quot;+wisdom+&quot; *&quot;); System.out.println(&quot;* 生命值：&quot;+life+&quot; *&quot;); System.out.println(&quot;* 魔法值：&quot;+magic+&quot; *&quot;); System.out.println(&quot;* * * * * * * * * * * * *&quot;); &#125; //写入文件 public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125;//游戏规则class Rule&#123; public void rule()&#123; System.out.println(&quot;很多职业会限制某些种族选择,种族和职业的限制情况如下：(下表均为不允许)&quot;); System.out.println(&quot;┎---------------------------------------------┒&quot;); System.out.println(&quot;│ 种 类 职 业 │&quot;); System.out.println(&quot;│ 精灵 狂战士、圣骑士 │&quot;); System.out.println(&quot;│ 兽人 圣骑士、刺客、巫师 │&quot;); System.out.println(&quot;│ 矮人 刺客、猎手、巫师 │&quot;); System.out.println(&quot;│ 元素 狂战士、圣骑士、刺客、猎手 │&quot;); System.out.println(&quot;┖---------------------------------------------┚&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24点游戏简单版]]></title>
    <url>%2F2019%2F04%2F10%2F24%E7%82%B9%E6%B8%B8%E6%88%8F%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[●题目名称 24点游戏（经典的纸牌益智游戏） ●题目分析 随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，可以利用穷举法列出4个数字加减乘除的各种可能性，包括括号的算法，并且要利用循环控制计算范围，防止出现重复的表达式。 ●算法构造 &lt;1&gt;利用随机函数生成4个随机数 &lt;2&gt;将4个数所有可能的顺序列举，并调用计算函数 &lt;3&gt;循环调用使4个数字分别进行两两运算，并将表达式储存在一个数组中 &lt;4&gt;将3个运算符的顺序进行调整，调用加减乘除运算操作函数计算并输出 ●算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define N 10 //定义四个数的取值最大为10double operate(double a,double b,char ch) //加减乘除运算操作函数 &#123; if(ch==&apos;+&apos;) return a+b; else if(ch==&apos;-&apos;) return a-b; else if(ch==&apos;/&apos;) return a/b; else if(ch==&apos;*&apos;) return a*b; else return 0; &#125; int precede(char a,char b) //判断优先级函数 &#123; if(a==&apos;+&apos;||a==&apos;-&apos;) &#123; if(b==&apos;*&apos;||b==&apos;/&apos;) return 1; if(b==&apos;+&apos;||b==&apos;-&apos;) return 0; &#125; if(a==&apos;*&apos;||a==&apos;/&apos;) return 0; return 0; &#125; int check(double A,double B,double C,double D) &#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; //数组储存运算符 double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) //循环调用使A,B进行运算操作,d[]为运算符,运算结果存到a[]中 a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); //A,B运算的结果和C运算，结果存到b[][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //循环防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); //A,B,C运算的结果和D运算，结果存到c[][][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 return 1; &#125; return 0; &#125; void SHOW(double A,double B,double C,double D) //输出函数，运算过程与check()函数相同&#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 &#123; if(precede(d[i],d[j])) //调用判断优先级函数，判断第一、第二个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f)%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); //(AB)CD printf(&quot;\n&quot;); &#125; else if(precede(d[j],d[k])) //调用判断优先级函数，判断第二、第三个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f%c%.0f)%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; else //调用判断优先级函数，判断第一、第三个运算符可能出现的情况 &#123; printf(&quot;%.0f%c%.0f%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; &#125; &#125; &#125; void game_24() &#123; double A=0,B=0,C=0,D=0; char j; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; srand((unsigned)time(NULL)); while(1) &#123; while((A==0||B==0)||(C==0||D==0)) //当A,B,C,D不为0时，4个随机数赋值给A,B,C,D &#123; A=rand()%10*1.0; B=rand()%10*1.0; C=rand()%10*1.0; D=rand()%10*1.0; &#125; if((check(A,B,C,D)||check(B,C,A,D))||(check(C,B,D,A)||check(D,A,B,C))) break; else &#123; A=0; B=0; C=0; D=0; &#125; &#125; printf(&quot;随机生成四个数为：&quot;); printf(&quot;%.0f %.0f %.0f %.0f\n&quot;,A,B,C,D); printf(&quot;是否要看答案(y/n):&quot;); while(1) &#123; scanf(&quot;%s&quot;,&amp;j); if(j==&apos;y&apos;||j==&apos;Y&apos;) &#123; SHOW(A,B,C,D); //将24种可能列举，并调用函数计算并输出结果 SHOW(A,B,D,C); SHOW(A,D,B,C); SHOW(A,D,C,B); SHOW(A,C,B,D); SHOW(A,C,D,B); SHOW(B,A,C,D); SHOW(B,A,D,C); SHOW(B,C,A,D); SHOW(B,C,D,A); SHOW(B,D,A,C); SHOW(B,D,C,A); SHOW(C,A,B,D); SHOW(C,A,D,B); SHOW(C,B,A,D); SHOW(C,B,D,A); SHOW(C,D,A,B); SHOW(C,D,B,A); SHOW(D,A,B,C); SHOW(D,A,C,B); SHOW(D,B,A,C); SHOW(D,B,C,A); SHOW(D,C,A,B); SHOW(D,C,B,A); break; &#125; else printf(&quot;是否要看答案(y/n):&quot;); &#125; &#125; void menu() &#123; int i; while(1) &#123; system(&quot;cls&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 智力游戏24点 *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 1.开始游戏. *\n&quot;); printf(&quot;* 2.退出游戏. *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;你准备好了吗？\n&quot;); printf(&quot;输入你的选择:&quot;); scanf(&quot;%d&quot;,&amp;i); if(i==3) break; switch(i) &#123; case 1: game_24(); //开始游戏 system(&quot;PAUSE&quot;); break; default: printf(&quot;error input!\n&quot;); system(&quot;PAUSE&quot;); &#125; &#125; &#125; void main() &#123; menu(); &#125; ●经验归纳 ●●遇到的问题 &lt;1&gt;在防止重复问题上有点迷茫，已解决 &lt;2&gt;对数据结构栈不够清楚，未写提高要求 ●●心得体会 感觉自己对数据结构栈的知识点很薄弱，需要加强。而且在解决基本要求时考虑的不够全面，刚开始没有考虑到防止重复的问题，还有出现过进入无限循环的问题，好在均已解决，但是随机函数生成4个数字的时候，4个数字可能会出现重复的情况，我在网上找了一下，有不重复的随机函数代码，在这里不赘述了。 个人认为这个代码还可以优化~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于文件的C语言学生信息管理系统]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[●题目名称 C语言学生信息管理系统 ●题目分析 将文件引入学生信息管理系统，完善学生信息数据的处理，包括信息的读取、保存、刷新。编写与文件有关的程序，需要考虑将对文件以什么方式操作，文件能否被打开，文件在什么位置。为了程序的可读性，一般将文件的读取、存盘、操作自定义为函数。 ●算法构造 ●●刷新学生信息update()函数 &lt;1&gt;以只读方式打开指定文件，判断文件是否为空，若为空，则提示：文件为空！ &lt;2&gt;循环读入学生信息，并累加当前记录的学生人数n &lt;3&gt;输出提示：刷新成功！ &lt;4&gt;关闭文件 ●●查询学生信息seek()函数 &lt;1&gt;用户输入要进行的操作:1.按学号查询；2.按姓名查询；3.退出本菜单 &lt;2&gt;选择1：输入要查询的学生的学号；判断输入的学号和存好的学号一致；一致则输出学生的信息，不一致则输出：该学号不存在！ &lt;3&gt;选择2：输入要查询的学生的姓名；判断输入的姓名和存好的姓名一致；一致则输出学生的信息，不一致则输出：该姓名不存在！ ●●修改学生信息modify()函数 &lt;1&gt;输入要修改的学生的学号 &lt;2&gt;比较输入的学号和文件存好的学号是否一致，选择要进行的操作编号：1.修改姓名；2.修改年龄；3.修改性别；4.修改C语言成绩；5.修改高等数学成绩；6.修改大学英语成绩；7.退出本菜单 &lt;3&gt;选择1：输入新的姓名s2；新的姓名s2替换原来的姓名；保存新的姓名 &lt;4&gt;选择2：输入新的年龄age；新的姓名age替换原来的年龄；保存新的年龄 &lt;5&gt;选择3：输入新的性别sex1；新的性别sex1替换原来的性别；保存新的性别 &lt;6&gt;选择4：输入新的C语言成绩score1；新的C语言成绩score1替换原来的C语言成绩；保存新的C语言成绩 &lt;7&gt;选择5：输入新的高等数学成绩score1；新的高等数学成绩score1替换原来的高等数学成绩；保存新的高等数学成绩 &lt;8&gt;选择6：输入新的大学英语成绩score1；新的大学英语成绩score1替换原来的姓名；保存新的大学英语成绩 &lt;9&gt;选择7：返回主菜单 ●●插入学生信息函数insert()函数 &lt;1&gt;输入待增加的学生数n &lt;2&gt;循环依次输入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;将这些信息依次写入文件 &lt;4&gt;提示：添加成功！ &lt;5&gt;调用按学号排序函数，将信息排序好 &lt;5&gt;关闭文件 ●●按学号删除信息del()函数 &lt;1&gt;输入要删除学生的学号s1 &lt;2&gt;初始化flag=0，进入循环，比较输入的学号和文件记录的学号是否一致，若一致则令flag=1，循环将后面的学生记录向前移动 &lt;3&gt;判断flag=0，提示：该学号不存在！ &lt;4&gt;判断flag=1，学生人数-1并保存，提示：删除成功！ &lt;5&gt;关闭文件 ●●显示当前信息display()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次输出每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●●保存当前学生信息fileWrite()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次写入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432#include&lt;stdio.h&gt; /*I/O函数*/#include&lt;stdlib.h&gt; /*其它说明*/#include&lt;string.h&gt; /*字符串函数*/#define max 100#define LEN 15 /* 学号和姓名最大字符数,实际请更改*/#define N 100 /* 最大学生人数,实际请更改*/int k=1,n=0, m=0;/* n代表当前记录的学生人数*///学生信息结构体struct student &#123; char no[LEN];//学号 char name[LEN];//姓名 char sex[LEN];//性别 int age;//年龄 float C;//c语言成绩 float M;//数学成绩 float E;//英语成绩&#125;stu[N];void fileWrite();//系统帮助及说明void help() &#123; printf("\n0.欢迎使用系统帮助！\n"); printf("\n1.初次进入系统后,请先选择增加学生信息;\n"); printf("\n2.按照菜单提示键入数字代号;\n"); printf("\n3.增加学生信息后,切记保存;\n"); printf("\n4.谢谢您的使用！\n");&#125;//刷新学生信息void update()&#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s,%s,%s,%d,%f,%f,%f\n",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) //从文件中读取信息 &#123; j++; &#125; n=j; printf("\n 提示：刷新成功!!! \n"); fclose(fp);&#125;//查询学生信息void seek() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i=0,item,flag; char s1[LEN+1]; /* 以姓名和学号最长长度+1为准*/ printf("----------------------\n"); printf("-----1.按学号查询-----\n"); printf("-----2.按姓名查询-----\n"); printf("-----3.退出本菜单-----\n"); printf("----------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); //用户输入要进行的操作 flag=0; switch(item) &#123; case 1: printf("请输入要查询的学生的学号:\n"); scanf("%s",&amp;s1); for(i=0; i&lt;n; i++) //n代表当前记录的学生人数 if(strcmp(s1,stu[i].no)==0) //strcmp()是字符串比较函数，判断输入的学号和存好的学号一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的学号和存好的学号不一致 printf("该学号不存在！\n"); break; case 2: printf("请输入要查询的学生的姓名:\n"); scanf("%s",&amp;s1); //输入学生姓名 for(i=0; i&lt;n; i++) if(strcmp(stu[i].name,s1)==0) //输入的姓名和存好的姓名一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的姓名和存好的姓名不一致 printf("该姓名不存在！\n"); break; case 3: return; default: printf("请在1-3之间选择\n"); &#125; &#125;&#125;//修改学生信息void modify() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) &#123; printf("\n 警告：打开文件错误，请退出重新打开！\n"); system("pause"); exit(0); &#125; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,item=0,num; int age; char sex1[4],s1[LEN+1],s2[LEN+1]; /* 以姓名和学号最长长度+1为准*/ float score1; printf("请输入要修改的学生的学号:"); scanf("%s",s1); for(i=0;i&lt;n;i++) &#123; if(strcmp(stu[i].no,s1)==0) /*比较字符串是否相等*/ &#123; num=i; //给num赋i值 printf("------------------\n"); printf("1.修改姓名\n"); printf("2.修改年龄\n"); printf("3.修改性别\n"); printf("4.修改C语言成绩\n"); printf("5.修改高等数学成绩\n"); printf("6.修改大学英语成绩\n"); printf("7.退出本菜单\n"); printf("------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); switch(item) &#123; case 1: printf("请输入新的姓名:"); scanf("%s",s2); strcpy(stu[num].name,s2); //strcpy()是字符串复制函数，将新输入的值赋给原先的值 fileWrite(); break; case 2: printf("请输入新的年龄:"); scanf("%d",&amp;age); stu[num].age=age; fileWrite(); break; case 3: printf("请输入新的性别:"); scanf("%s",&amp;sex1); strcpy(stu[num].sex,sex1); fileWrite(); break; case 4: printf("请输入新的C语言成绩:"); scanf("%d",&amp;score1); stu[num].C=score1; fileWrite(); break; case 5: printf("请输入新的高等数学成绩:"); scanf("%d",&amp;score1); stu[num].M=score1; fileWrite(); break; case 6: printf("请输入新的大学英语成绩:"); scanf("%d",&amp;score1); stu[num].E=score1; fileWrite(); break; case 7: return; default: printf("请在1-7之间选择\n"); &#125; &#125; &#125; else &#123; printf("没有该学生学号!!!"); &#125; &#125;&#125;//按学号排序函数void sort()&#123; int i,j,*p,*q,s; char temp[LEN+1],ctemp[LEN]; float *x,*y,z; float *a,*b,c; float *k,*l,h; for(i=0;i&lt;n-1;i++) &#123; for(j=n-1;j&gt;i;j--) if(strcmp(stu[j-1].no,stu[j].no)&gt;0) &#123; strcpy(temp,stu[j-1].no); strcpy(stu[j-1].no,stu[j].no); strcpy(stu[j].no,temp); strcpy(temp,stu[j-1].name); strcpy(stu[j-1].name,stu[j].name); strcpy(stu[j].name,temp); p=&amp;stu[j-1].age; q=&amp;stu[j].age; s=*q; *q=*p; *p=s; strcpy(ctemp,stu[j-1].sex); strcpy(stu[j-1].sex,stu[j].sex); strcpy(stu[j].sex,ctemp); x=&amp;stu[j-1].C; y=&amp;stu[j].C; z=*x; *x=*y; *y=z; a=&amp;stu[j-1].M; b=&amp;stu[j].M; c=*a; *a=*b; *b=c; k=&amp;stu[j-1].E; l=&amp;stu[j].E; h=*k; *k=*l; *l=h; &#125; &#125;&#125;//插入学生信息函数void insert() &#123; int i; printf("请输入待增加的学生数:"); scanf("%d",&amp;n); FILE * fp; if((fp=fopen("student.txt","at"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; printf("\n请输入第%d个学生的学号：",i+1); scanf("\n%s",&amp;stu[i].no); printf("\n请输入第%d个学生的姓名：",i+1); scanf("%s",&amp;stu[i].name); printf("\n请输入第%d 个学生的性别：",i+1); scanf("%s",&amp;stu[i].sex); printf("\n请输入第%d 个学生的年龄:",i+1); scanf("%d",&amp;stu[i].age); printf("\n请输入第%d 个学生的C语言成绩:",i+1); scanf("%d",&amp;stu[i].C); printf("\n请输入第%d 个学生的高等数学成绩:",i+1); scanf("%d",&amp;stu[i].M); printf("\n请输入第%d 个学生的大学英语成绩:",i+1); scanf("%d",&amp;stu[i].E); sort(); //调用按学号排序函数 //写入文件 fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; printf("\n添加成功!!!\n"); fclose(fp);&#125;//按学号删除信息void del() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f ",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,flag=0; char s1[LEN+1]; printf("请输入要删除学生的学号:\n"); scanf("%s",s1); for(i=0; i&lt;n; i++) &#123; if(strcmp(stu[i].no,s1)==0) //比较输入的学号和记录的学号一致 &#123; flag=1; for(j=i; j&lt;n-1; j++) &#123; stu[j]=stu[j+1]; //后面的学生记录向前移动 &#125; &#125; &#125; if(flag==0) //比较输入的学号和记录的学号不一致 printf("该学号不存在！\n"); if(flag==1) //判断flag的值为1，则成功删除 &#123; n--; //删除成功后，学生人数-1 fileWrite(); fclose(fp); printf("删除成功,显示结果请选择菜单\n"); &#125;&#125;//显示当前信息void display() &#123; int i=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s %s %s %d %f %f %f",stu[i].no,stu[i].name,stu[i].sex,&amp;stu[i].age,&amp;stu[i].C,&amp;stu[i].M,&amp;stu[i].E)==7) &#123; i++; &#125; n=i; //记录文件中数据的行数 printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); for(i=0;i&lt;n;i++) //依次输出学生信息 &#123; printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp);&#125;//保存当前学生信息void fileWrite()&#123; FILE *fp; int i; if((fp=fopen("student.txt","w"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp); printf("保存成功!!!");&#125; //界面void menu() &#123; int num; printf(" \n\n \n\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf(" * 学生信息管理系统 *\n"); printf(" * *\n"); printf(" * * * * * * * *系统功能菜单* * * * * * * *\n"); printf(" * -------------------------------------------- *\n"); printf(" * *\n"); printf(" * 0.系统帮助及说明 | 1.刷新学生信息 *\n"); printf(" * *\n"); printf(" * 2.查询学生信息 | 3.修改学生信息 *\n"); printf(" * *\n"); printf(" * 4.增加学生信息 | 5.按学号删除信息 *\n"); printf(" * *\n"); printf(" * 6.显示当前信息 | 7.保存当前学生信息 *\n"); printf(" * *\n"); printf(" * 8.退出系统 *\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n"); printf("请选择菜单编号:"); scanf("%d",&amp;num); switch(num) &#123; case 0: help(); break; case 1: update(); break; case 2: seek(); break; case 3: modify(); break; case 4: insert(); break; case 5: del(); break; case 6: display(); break; case 7: fileWrite(); break; case 8: k=0; break; default: printf("请在0-8之间选择\n"); &#125;&#125;//主函数 int main() &#123; while(k) &#123; menu(); &#125; system("pause"); return 0;&#125; ●经验归纳 ●●遇到的问题 程序无法读取文件信息：对文件的概念不清楚，文件的读取中各个数据之间不能用逗号隔开 ●●算法优化 &lt;1&gt;将主函数写到子函数后面，删去函数声明 &lt;2&gt;利用结构体，使学生信息更加结构化 &lt;3&gt;新增按学号排序函数，用户在增加了学生信息后，调用该函数，将文件中学生信息按学号排序好 &lt;4&gt;优化删除学生信息函数，直接将后面的学生记录向前移动 &lt;5&gt;将每个涉及文件的子函数都加入了文件读取功能，目的是进行相应操作时不必每次都要先执行刷新函数 &lt;6&gt;优化修改学生信息函数，每次修改完都调用保存函数，实现自动保存 ●●心得体会 学生信息管理系统是我们在学习C语言时的典例，但是我感觉在文件读取方面基础还是比较薄弱，一些基础性的知识点还是不能记住，所以以后要多多练习与读取文件有关的习题。]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求N个数的最大公约数和最小公倍数&&Hankson问题]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%B1%82N%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%26%26Hankson%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[● 题目名称 &lt;1&gt;求N个数的最大公约数和最小公倍数 &lt;2&gt;计算出Hankson的“逆问题”的答案 ● 题目分析 &lt;1&gt;求N个数的最大公约数和最小公倍数：可以先求出第一个数和第二个数的最大公约数和最小公倍数，再将这个最大公约数和最小公倍数与下一个数计算出新的最大公约数和最小公倍数，以此类推 &lt;2&gt;计算出Hankson的“逆问题”的答案：先输入组数，再根据组数以每组4个数循环输入，然后判断输入的四个数是否满足条件，接着再调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件，若满足，则累加，最后输出累加的结果 ● 算法构造 ● ● 求N个数的最大公约数和最小公倍数 &lt;1&gt;输入要计算最大公约数和最小公倍数的整数个数 &lt;2&gt;循环输入整数 &lt;3&gt;调用函数，求出这些整数的最大公约数和最小公倍数 &lt;4&gt;先计算出两个数的最大公约数（最小公倍数），再用该最大公约数（最小公倍数）和下一个数求最大公约数（最小公倍数），以此类推 &lt;5&gt;输出这些整数的最大公约数和最小公倍数 ● ● 计算出Hankson的“逆问题”的答案 &lt;1&gt;输入组数 &lt;2&gt;每组输入四个数，判断是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;3&gt;循环依次输入各组，每组4个数 &lt;4&gt;判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;5&gt;循环计算有多少个满足条件的数，调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件 &lt;6&gt;输出累加的数 ● 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;//辗转相除法求两个数的最大公约数int max1(int a,int b) &#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;//求n个数的最大公约数int max2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; z=max1(x,y); //先计算出两个数的最大公约数，再用该最大公约数和下一个数求最大公约数，以此类推 for(int i=2;i&lt;n;i++) z=max1(z,a[i]); return z;&#125; //求两个数的最小公倍数int min1(int a,int b) &#123; int max1(int a,int b); //自定义函数返回值类型 int temp; temp=max1(a,b); //再次调用自定义函数，求出最大公约数 return (a*b/temp); //返回最小公倍数到主调函数处进行输出&#125;//求n个数的最小公倍数int min2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; //与n个数的最大公约数同理 z=min1(x,y); for(int i=2;i&lt;n;i++) z=min1(z,a[i]); return z;&#125;void main()&#123; int n=0,x=0,max=0,min=0,b,sum=0,i=0; int c[4]; int a[]=&#123;0&#125;; printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* 1.输入n个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.计算出Hankson的“逆问题”的答案. *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x&lt;1||x&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;x); &#125; switch(x) &#123; case 1: printf(&quot;请输入你想要计算的整数个数（大于1）：&quot;); scanf(&quot;%d&quot;,&amp;n); //输入要计算最大公约数和最小公倍数的整数个数 printf(&quot;请依次输入整数：\n&quot;); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //循环输入整数 max=max2(a,n); //调用函数，求出这些整数的最大公约数 min=min2(a,n); //调用函数，求出这些整数的最小公倍数 printf(&quot;这些数的最大公约数为：%d\n&quot;,max); printf(&quot;这些数的最小公倍数为：%d\n&quot;,min); break; case 2: printf(&quot;请输入数据的组数：&quot;); scanf(&quot;%d&quot;,&amp;b); //输入组数 printf(&quot;每组输入四个数，要求：保证第一个数能被第二个数整除，第三个数能被第四个数整除：\n&quot;); for(;b&gt;0;b--) //循环依次输入b个组 &#123; for(i=0;i&lt;4;i++) //每组4个数 &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; if(c[0]%c[1]!=0||c[3]%c[2]!=0) //判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &#123; printf(&quot;输入不符合条件，请重新输入：\n&quot;); for(i=0;i&lt;4;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; &#125; for(int y=0;y&lt;=c[3];y++) //循环计算有多少个满足条件的数 &#123; if(max1(y,c[0])==c[1]&amp;&amp;min1(y,c[2])==c[3]) //调用计算两个数的最大公约数和最小公倍数的函数，判断y是否满足条件 sum++; &#125; printf(&quot;一共有%d个数满足条件\n&quot;,sum); sum=0; //累加sum初始化 &#125; &#125;&#125; ● 经验归纳 ● ● 遇到的问题 &lt;1&gt;习惯了计算两个数的最大公约数和最小公倍数，对N个数迷茫了… &lt;2&gt;最大公约数和最小公倍数计算有误 &lt;3&gt;提高要求要输入的那四个数的限制条件运用不当，审题不清，导致频繁出错 &lt;4&gt;在一次循环之后未将累加的值初始化，导致下一次循环完毕后的结果有误 ● ● 心得体会 以前都是计算两个数的最大公约数和最小公倍数，这次要计算n个数的最大公约数和最小公倍数，我其实运用的还是计算两个数的那个思想，就是加入了函数调用。 感觉自己有时候还挺粗心的（也可能是代码敲久了有点晕hhh），还有就是提高要求把我卡住了。。完全不知道逆着怎么求…查了一些资料，然后和一起去图书馆敲代码的同学讨论了一下，大体有思路了，但只要写程序就有错误。。。。 失误挺多的，希望自己能在以后的程序生涯里越来越棒，小细节都可以注意到~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JAVA编写奇数累加和猜数字小游戏代码（包含JAVA产生随机数）]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8JAVA%E7%BC%96%E5%86%99%E5%A5%87%E6%95%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%8C%9C%E6%95%B0%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8C%85%E5%90%ABJAVA%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.题目名称： 奇数累加、猜数字小游戏 2.题目要求： 求自然数1-99的所有奇数累加的和； 计算机自动生成答案，玩家手动输入其猜想的数字，判断玩家是否猜对。 3.算法分析： 3.1奇数累加 （1）利用for循环，遍历自然数并限制累加范围在1-99之内 （2）遍历过程中，判断正在遍历的自然数是否奇数 （3）如果是奇数，则进行累加 3.2猜数字小游戏 （1）利用随机数产生一个1-100的整数，即为正确答案 （2）玩家输入一个整数 （3）如果玩家输入的数为0，则退出游戏；如果玩家输入的数小于0或大于100，则重新输入 （4）利用循环判断计算机生成的数和玩家输入的数是否一致 （5）如果不一致：玩家输入的过大，则提示“太大了”；玩家输入的过小，则提示“太小了” （6）如果玩家输入的数与计算机产生的数一致，则提示“恭喜你，答对啦！” 4.源代码： 4.1奇数累加 12345678910111213package com.itheima.first;public class Sum &#123; public static void main(String[] args)&#123; int i,sum=0; for(i=1;i&lt;100;i++) &#123; if(i%2!=0) sum+=i; &#125; System.out.println(&quot;在自然数1-99中奇数累加之和为：&quot;+sum); &#125;&#125; 4.2猜数字小游戏 12345678910111213141516171819202122232425262728293031323334package interesting;import java.util.Scanner;public class game &#123; public static void main(String[] args) &#123; int n=(int)(Math.random()*100)+1; //利用随机数生成一个正确答案 Scanner a=new Scanner(System.in); System.out.println(&quot;***********这是一个猜数字的游戏***********\n&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)，退出游戏请按0：&quot;); int b=a.nextInt(); while(b&lt;0||b&gt;100) &#123; System.out.println(&quot;输入错误~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; if(b==0) System.out.println(&quot;你已退出游戏~~~&quot;); else &#123; while(b!=n) //如果用户输入的数与正确答案不符 &#123; if(b&gt;n) System.out.println(&quot;太大了~&quot;); else if(b&lt;n) System.out.println(&quot;太小了~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; &#125; if(b==n) System.out.println(&quot;恭喜你，猜对啦!&quot;); &#125;&#125; 5.心得体会： 这些都是简单的程序，但是JAVA与C语言和C++的语法不一样，比如游戏里的产生随机数，我本来用的是C语言的随机数，但运行的时候发现了错误，于是我上网搜了一下，发现JAVA和C语言的随机数不一样；JAVA的输入代码，我在网上找了一下，接收字符和数字的输入代码是不一样的~ 还有程序最后保存是以文件夹的形式，我不知道最好是删除某个文件还是保留整个文件夹…于是我又做了新的尝试，我只留了src那个文件夹，然后…代码运行不了…我只好重新建了个项目，这次不敢删了… 不过这是我第一次用JAVA写代码呢感觉自己学到了很多*****]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方法计算两个数的最大公约数]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0~~~%2F</url>
    <content type="text"><![CDATA[1.题目名称 计算两个数的最大公约数 2.题目分析 计算两个数的最大公约数，可以采用最大公约数的四种常用算法，分别是辗转相除法、穷举法、更相减损法、Stein算法。每种方法写一个函数，分别计算出最大公约数，主函数的菜单里有选择功能，用户可以选择自行输入两个数，然后调用这四种方法的任一种；也可以选择程序的测试功能，通过自己选择的组数，计算机自动产生随机函数，然后调用四种方法的任一种，并计算出程序运行的时间。 3.算法构造 3.1辗转相除法 设两数为a,b设其中a 做被除数,b做除数，temp为余数 1、大数放a中、小数放b中； 2、求a/b的余数； 3、若temp=0则b为最大公约数； 4、如果temp!=0则把b的值给a、temp的值给a； 5、返回第二步； 3.2穷举法（利用数学定义） 穷举法（也叫枚举法）穷举法求两个正整数的最大公约数的解题步骤： 从两个数中较小数开始由大到小列举，直到找到公约数立即中断列举，得到的公约数便是最大公约数 。 对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp能同时被a和b所整除，则temp即为最大公约数。 3.3更相减损法 更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。《九章算术》是中国古代的数学专著，其中的“更相减损术”可以用来求两个数的最大公约数，即“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 翻译成现代语言如下： 第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。 3.4 Stein算法 Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。来研究一下最大公约数的性质，发现有 gcd( k_x,k_y ) = k_gcd( x,y ) 这么一个非常好的性质。试取 k=2，则有 gcd( 2x,2y ) = 2 * gcd( x,y )。很快联想到将两个偶数化小的方法。那么一奇一个偶以及两个奇数的情况如何化小呢？ 先来看看一奇一偶的情况： 设有2x和y两个数，其中y为奇数。因为y的所有约数都是奇数，所以 a = gcd( 2x,y ) 是奇数。根据2x是个偶数不难联想到，a应该是x的约数。我们来证明一下：(2x)%a=0，设2x=n_a，因为a是奇数，2x是偶数，则必有n是偶数。又因为 x=(n/2)*a，所以 x%a=0，即a是x的约数。因为a也是y的约数，所以a是x和y的公约数，有 gcd( 2x,y ) &lt;= gcd( x,y )。因为gcd( x,y )明显是2x和y的公约数，又有gcd( x,y ) &lt;= gcd( 2x,y )，所以 gcd( 2x,y ) = gcd( x,y )。至此，我们得出了一奇一偶时化小的方法。 再来看看两个奇数的情况：设有两个奇数x和y，不妨设x&gt;y，注意到x+y和x-y是两个偶数，则有 gcd( x+y,x-y ) = 2 * gcd( (x+y)/2,(x-y)/2 )，那么 gcd( x,y ) 与 gcd( x+y,x-y ) 以及 gcd( (x+y)/2,(x-y)/2 ) 之间是不是有某种联系呢？为了方便设 m=(x+y)/2 ，n=(x-y)/2 ，容易发现 m+n=x ，m-n=y 。设 a = gcd( m,n )，则 m%a=0,n%a=0 ，所以 (m+n)%a=0，(m-n)%a=0 ，即 x%a=0 ，y%a=0 ，所以a是x和y的公约数，有 gcd( m,n )&lt;= gcd(x,y)。再设 b = gcd( x,y )肯定为奇数，则 x%b=0,y%b=0 ，所以 (x+y)%b=0 ，(x-y)%b=0 ，又因为x+y和x-y都是偶数，跟前面一奇一偶时证明a是x的约数的方法相同，有 ((x+y)/2)%b=0,((x-y)/2)%b=0 ，即 m%b=0 ，n%b=0 ，所以b是m和n的公约数，有 gcd( x,y ) &lt;= gcd( m,n )。所以 gcd( x,y ) = gcd( m,n ) = gcd( (x+y)/2,(x-y)/2 )。 整理一下，对两个正整数 x&gt;y ： 1.均为偶数 gcd( x,y ) =2gcd( x/2,y/2 )； 2.均为奇数 gcd( x,y ) = gcd( (x+y)/2,(x-y)/2 )； 2.x奇y偶 gcd( x,y ) = gcd( x,y/2 )； 3.x偶y奇 gcd( x,y ) = gcd( x/2,y ) 或 gcd( x,y )=gcd( y,x/2 )； 现在已经有了递归式，还需要再找出一个退化情况。注意到 gcd( x,x ) = x ，就用这个。 4.算法实现 4.1辗转相除法 123456789101112131415161718192021222324int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125; 4.2穷举法（利用数学定义） 12345678910111213141516int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125; 4.3更相减损法 123456789101112131415161718192021222324252627int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125; 4.4 Stein算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;****4.5完整代码**** 在这里插入代码片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include&lt;stdio.h&gt;#include&lt;math.h&gt; //计算2的i次方的函数pow(2,i)的头文件#include&lt;time.h&gt; //计算程序运行时间和随机产生数的头文件#include&lt;stdlib.h&gt;int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125;int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125;int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125;int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;void main()&#123; int x,y,p,i,n,N,m[1000]; int a,b,c,d,e; printf(&quot;*********************你有两种选择********************\n&quot;); printf(&quot;* 1.输入两个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.利用随机数测试最大公约数并计算程序运行时间. *\n&quot;); printf(&quot;*****************************************************\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n&lt;1||n&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;n); &#125; if(n==1) &#123; printf(&quot;请输入两个正整数:\n&quot;); //用户自行输入两个数 scanf(&quot;%d%d&quot;,&amp;x,&amp;y); while(x&lt;0||y&lt;0||x==0||y==0) &#123; printf(&quot;请按要求输入正整数:\n&quot;); scanf(&quot;%d%d&quot;,&amp;x,&amp;y); &#125; printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); break; case 2: a=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); break; case 3: a=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); break; case 4: a=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); break; case 5: a=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); break; &#125; printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125;&#125;else if(n==2)&#123; clock_t start,finish; //计算随机函数 double duration; srand((unsigned)time(NULL)); printf(&quot;你想测试多少组数据？\n&quot;); scanf(&quot;%d&quot;,&amp;N); for(i=0;i&lt;N;i++) //随机取20个数（1-100） &#123; m[i]=rand()%100+1; printf(&quot;%d\t&quot;,m[i]); &#125; printf(&quot;\n&quot;); printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: start=clock(); //程序运行，开始计时 while(j&lt;20) &#123; x=m[j++]; y=m[j++]; a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125; finish=clock(); //程序运行结束，结束计时 break; case 2: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; b=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,b); &#125; finish=clock(); break; case 3: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; c=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,c); &#125; finish=clock(); break; case 4: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; d=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,d); &#125; finish=clock(); break; case 5: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; e=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,e); &#125; finish=clock(); break; &#125; duration=(double)(finish-start)/1000; ////计算时间差，由于计算机计算的是毫秒，转换成秒要除以1000 printf(&quot;这个方法的运行时间是%f秒\n&quot;,duration); &#125; &#125; &#125; 5.经验归纳 5.1遇到的问题 1.对随机函数不熟悉； 2.测试环节，对计算程序运行时间不熟悉； 3.在更相减损法的最后，用到了pow()函数，因没加头文件#include&lt;math.h&gt;而出错； 4.因知识储备不足，对最后一种方法（Stein算法）不理解。 PS：以上问题均已解决。 5.2心得体会 我觉得这四种方法里Stein算法我有点看不懂（可能是因为有&gt;&gt;运算符），还有随机数的生成和计算程序运行时间的函数都只是有一些印象，并不熟悉。（但是我可以查资料和问同学啊hhh） 主函数我改了很多次，就是想让界面更加美化一些，改完就发现程序出错了…其实就是赋值这么一个小细节，但就是发现不了（Emmmm），感觉自己还需要学很多东西，动手能力也要加强 总之就是~add oil!!!]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三天打鱼两天晒网]]></title>
    <url>%2F2019%2F03%2F01%2F%E2%80%9C%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[♦ 题目： 三天打鱼两天晒网 ♦问题： 某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。 ♦ 要求： 基本要求：1.程序风格良好(使用自定义注释模板)，提供友好的输入输出。 提高要求：1.输入数据的正确性验证。 2.使用文件进行数据测试。如将日期 20100101 20111214 等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。 ♦程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void hanshu(int year,int month,int day)&#123; int sum=0; int a=0; int b=0; int c=0; int x[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; //平年各月份的天数 int y[12]=&#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; //闰年各月份的天数 for(int i=2010;i&lt;year;i++) //利用循环结构计算出在输入年份之前的那几年一共有几天 &#123; if((i%4==0&amp;&amp;i%100!=0)||i%400==0) //判断是否有闰年，有的话，一年为366天；否则一年为365天 a+=366; else a+=365; &#125; for(int j=0;j&lt;month-1;j++) //利用循环计算在输出月份之前的几个月一共有几天 &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) //判断该年是否为闰年，如果是，则用闰年数组；否则，用平年数组 b+=y[j]; else b+=x[j]; &#125; c=day; //用户输入的天数 sum=a+b+c; //将年，月，日所计算的天数相加，即为总天数 printf(&quot;距离2010年1月1日一共有%d天\n&quot;,sum); if(sum%5==1||sum%5==2||sum%5==3) //判断总天数取余后余数是否为1,2,3，如果是，输出“你在打鱼”；否则，输出“你在晒网” printf(&quot;你在打鱼~~~\n&quot;); else printf(&quot;你在晒网~~~\n&quot;);&#125;void main()&#123; int year,month,day,m,p,a,b,c; printf(&quot;***************计算你到底在打鱼还是晒网***************\n&quot;); printf(&quot;1.使用文件测试\n&quot;); printf(&quot;2.从键盘输入计算\n&quot;); printf(&quot;请输入你想选择的操作的序号：\n&quot;); scanf(&quot;%d&quot;,&amp;m); if(m==1) //选择1，进入文件测试环节 &#123; FILE *fp1; FILE *fp2; fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;); fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;); if(fp1==NULL) //判断文件in.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else if(fp2==NULL) //判断文件out.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else fscanf(fp1,&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); //文件不为空，则用格式化读写函数fscanf()和fprintf()来读取文档in.txt和out.txt中的信息 hanshu(a,b,c); fprintf(fp2,&quot;%1d&quot;,&amp;p); fclose(fp1); //关闭文件 fclose(fp2); &#125; else if(m==2) &#123; printf(&quot;请输入年，月，日：(在2010年1月1日之后)\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); while(year&lt;2010||month&gt;12||day&gt;31) //判断输入年份是否小于2010年，如果是，则重新输入 &#123; printf(&quot;输入错误！请重新输入！\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); &#125; hanshu(year,month,day); &#125; else &#123; printf(&quot;你的输入有误！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;m); &#125;&#125; ♦ 心得： 第一次接触文件测试这样的问题，我刚开始还真无从下手还好问了班里比较厉害的同学，然后自己复习了C语言课本上的文件那一章，感觉遇到的问题挺多的，但是还好在我的不懈努力（不断问别人）下，最终是把文件测试这关通过了！！！ 刚开始敲得那个代码只有一个主函数，后来检查了一下觉得太简单了，然后运用了子函数，感觉自己对C语言还掌握的不是很清楚，还需要多多动手敲代码啊！！！（希望老师能看到我这个代码小白的认真） 我觉得这次作业让我学到了好多东西，也了解到了大企业的程序设计风格，我可以从现在开始学习他们的风格。 个人感觉还是对C语言感情更深一些，毕竟是接触计算机学到的第一门语言hhhh希望我能够在史晓楠老师（超级厉害）的教导下学到更多以前没接触过的东西！！！ 新的一年，新一学期，新的起点，FIGHTING]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
