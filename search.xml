<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git安装及基本使用]]></title>
    <url>%2F2019%2F07%2F06%2Fgit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[准备工作 下载git 注册github 将git和github连接起来 获取ssh秘钥 id_rsa.pub github里，找到settings，填入秘钥 正式开始 1、确定git和github已经连接 12git initgit remote add origin 仓库地址 2、本地文件推到github上 将新建的文件添加到git的缓存区 1234添加具体名称文件git add index.html添加全部文件git add . 给提交的文件添加描述 1git commit -m &apos;demo&apos; 汇总到总分支上 1git pull origin master --allow-unrelated-histories 退出 1:wq 文件推到远程仓库 123 git push origin mastergit push -u origin master 输入用户名(如果设置了SSH密匙的话就不用输入密码了) 1输入OpenSSH：输入密码 ==如果出现错误== 1git config --global user.email &quot;you@example.com&quot; 一般在push的时候会出现错误1234hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决方法 先执行git pull origin master 在执行git push origin master==这个时候又可能出现错误== 1fatal: refusing to merge unrelated histories 不用慌，我在网上搜好多方法，都说使用如下指令 12git pull origin master --allow-unrelated-histories git pull --allow-unrelated-histories 但是输入这些指令之后会跳出来另外一个界面然后从新pull就行了 我的解决方法重新在原文件下Git Brush Here然后重新开始就可以解决 无论使用git pull 出不出现错误只要出现刷新github文件就推过来了学习相关git的操作git的学习 廖雪峰的官方网站]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内联块和浮动问题]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%86%85%E8%81%94%E5%9D%97%E5%92%8C%E6%B5%AE%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[内联块和浮动都是为了使区块元素在一行显示 内联块（inline-block） 设置：很简单，直接在css样式中加上display: inline-block;即可 特点： 可以和非区块元素在一行显示 支持所有的样式 不设置宽高时由内容（文字图片等）撑开 换行符会被解析（缺点） 那么，如何去掉内联块之间的空格（换行符）呢？这里有四种方法哦~ a.第一种方法：将后面的内联块设置左外边距为负值，值为父元素大小的0.25倍 举个例子，假设有两个内联块，直接给后面的内联块（第二个）的css样式设置为margin-left:-0.25m; b.第二种方法：用注释去掉换行符 这个方法可能有点不好理解，前面说了，使用内联块换行符会被解析，那么如果给换行符加上注释会不会解决这个问题呢？答案是肯定的~ 举个例子~ 12&lt;div&gt;&lt;/div&gt;&lt;!--加上注释--&gt;&lt;div&gt; &lt;/div&gt; c.第三种方法：设置字间距（letter-spacing）为-0.25倍 也就是css样式里加上letter-spacing:-0.25em; d.第四种方法：将父元素的字体大小设置为0，在子元素里重新设置字体大小 这个方法很容易理解，这里就不举例啦！！ 我们可以发现，使用内联块实现区块元素并排显示其实非常麻烦，那么有没有更加方便的方法呢？ 浮动元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住：float：left/right/none(默认值)，由于子元素脱离文档流，结果会使父元素高度崩塌，解决浮动元素脱离文档流不占位的方法 我们可以看到，浮动会使父元素高度崩塌。Therefore，解决父元素高度崩塌的方法来啦~ 方法1：给父元素设置高度 ​ 局限性：（1）不确定高度时无法使用；（2）在内容、数量不确定时也无法使用 方法2：将父元素设置为BFC盒子，也就是说不能用浮动方法，要在父元素的css样式里写为overflow:hidden; ​ 局限性：在父元素有溢出部分时无法使用 方法3：为所有浮动元素后面设置一个空元素，在里面设置清除浮动clear:both 举个例子：div元素需要左浮动，我们需要在div元素后面设置空元素span 12345678910&lt;style&gt; div&#123; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;span syyle="display:block; clear:both;"&gt;&lt;/span&gt;&lt;/body&gt; ​ 局限性：创建了一个没有任何意义的空标签 方法4：为父元素设置after伪元素，在该元素上设置清除浮动clear:both; ​ 局限性：低版本的IE浏览器不识别 解决办法：用.cearfix{*zoom:1}来兼容 也就是说这个方法几乎没有缺点，是最优方法 好啦让我们来举例叭 假设有4个div元素，其中一个类名为parent元素是父元素（边框为2px black solid），为这三个div元素设置浮动并清除 123456789101112131415161718192021222324&lt;style&gt; .parent&#123; border:2px black solid; &#125; /*设置伪元素，清除浮动*/ .parent::after&#123; display:block; content:""; clear:both; &#125; .parent&gt;div&#123; width:100px; height:100px; background-color:red; float:left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css的选择器扩展]]></title>
    <url>%2F2019%2F07%2F01%2Fcss%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分组选择器：注：以下两种书写方式一般没有区别，但也有特殊情况。假设p标签也有一个类名为class，地址名为id的元素，就必须要在最前面加上标签名 12.class,#id /*选择类名为class的所有选择和地址名为id的元素*/div.class,#id /*选择div的所有后代中类名为.class的元素和地址名为id的元素*/ 多条件选择器：同时满足类名为box1和box2的元素 1.box1.box2 /*既有类名为box1的元素同时也有类名为box2的元素*/ 子元素选择器：1div&gt;.class /*选择div元素的所有子元素中有类名为class的元素*/ next选择器：1div+p /*选择div元素的下个同级元素且标签为p的元素*/ 伪类选择器（状态性伪类）：注：以下的标签a的4个伪类必须按照lvha的顺序书写，否则可能会出错 1234 a:link /*选择所有未被访问的链接*/ a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/ a:active /*选择活动链接（正在击中）*/ 举个状态性伪类的例子：设计一个div盒子（宽200px高200px、红色），要求：当鼠标移动该盒子上时盒子变为蓝色，当鼠标点击该盒子时盒子的宽和高分别为500px和150px 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;状态性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:200px; height:200px; background-color:red; &#125; div:hover&#123; background-color:blue; &#125; div:active&#123; width:150px; height:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器（结构性伪类）：注：before 和after中必须设置content(内容)和display(种类)两个样式，否则无法正确显示 1234p::before /*在每个p元素的内容之前插入内容*/p::after /*在每个p元素的内容之后插入元素*/display /*用来修改元素种类，分别有block（区块元素）、inline(内联元素)、inline-block（内联块元素）、none（隐藏元素，不占用物理空间）*/content:"" /*引号里写要显示的内容，如果没有要显示的内容就空着*/ 举个伪元素选择器（结构性伪类）的例子：写一个div元素(300,300)，为它设置before伪元素（区块元素 150px,150px），当你的鼠标移入div时让伪元素背景颜色发生变化，在div上击中时，伪元素隐藏 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;结构性伪类&lt;/title&gt; &lt;style&gt; div&#123; width:300px; height:300px; background-color:brown; &#125; /*先把div元素转换为伪元素*/ div::before&#123; content:""; display:block; width:150px; height:150px; background-color:chartreuse; &#125; /* 鼠标移伪元素时改变颜色 * 格式：div:hover::befere */ div:hover::before&#123; background-color:cornflowerblue; &#125; div:active::before&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于表格的一些基础知识~]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%85%B3%E4%BA%8E%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先让我们认识一些表格标签12345678&lt;table&gt; &lt;!-- 定义表格（必不可少） --&gt;&lt;caption&gt; &lt;!-- 表格标题（默认居中） --&gt;&lt;thead&gt; &lt;!-- 表格表头 --&gt;&lt;tbody&gt; &lt;!-- 表格正文（必不可少） --&gt;&lt;tfoot&gt; &lt;!-- 表格页脚 --&gt;&lt;th&gt; &lt;!-- 表头单元格（加粗黑体） --&gt;&lt;tr&gt; &lt;!-- 表格行 --&gt;&lt;td&gt; &lt;!-- 表格单元格 --&gt; 举个例子： 123456789101112131415&lt;table&gt; &lt;caption&gt;我是表格的标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;我是第一列表头单元格&lt;/th&gt; &lt;th&gt;我是第二列表头单元格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;我是第一列&lt;/td&gt; &lt;td&gt;我是第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 这是一张2行2列的表格，第一行是表头单元格，第二行是表格正文。在浏览器运行后会发现，不仅单元格间有间隙，表格内边距也有。为了解决这个问题，表格属性来啦1234567891011- ##### 表格属性 ```css cellspacing ------单元间间隙(用于table标签) cellpadding ------表格内边距(用于table标签) colspan=&quot;2&quot; ------横向合并单元格(用于td标签)，2代表两个单元格合并 rowspan=&quot;2&quot; ------纵向合并单元格(用于td标签) ```再试一下，在table标签里加入了cellspacing=&quot;0&quot;，cellpadding=&quot;0&quot;后就不存在这样的问题了 表格样式：为表格和单元格设置border等样式，否则无法看到表格边框，除此外table的border-collapse样式，可以用来合并相邻单元格的边框 1border-collapse:collapse; /* 用于table标签中，注：使用该样式时要把单元间间隙（cellsapcing）设为0 */ 以上就是最简单的表格的制作啦~~ 接下来再举一个小例子：（加上css样式和合并单元格）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;简单的表格制作&lt;/title&gt; &lt;style&gt; table,td,th&#123; border:1px black solid; &#125; table&#123; border-collapse:collapse;/*合并相邻的单元格边框*/ &#125; td,th&#123; width:100px; height:30px; text-align:center; /*所有文字居中*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspancing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--第一行的第一列和第二列合并--&gt; &lt;th colspan="2"&gt;第一行第一列表头单元格&lt;/th&gt; &lt;!--&lt;th&gt;第一行第二列表头单元格&lt;/th&gt;*/--&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;td rowspan="2"&gt;我是第二行第一列&lt;/td&gt; &lt;td&gt;我是第二行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--第二行的第一列和第三行的第一列合并--&gt; &lt;!--&lt;td&gt;我是第三行第一列&lt;/td&gt;--&gt; &lt;td&gt;我是第三行第二列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 最后来说一下table表格的缺点~ 太深的嵌套，如table&gt;tbody&gt;tr&gt;td&gt;h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了代码量 灵活性差，比如要将tr设置border等属性，是不行的，得通过td 代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱 混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱 table需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间 不够语义，无论是计算机还是阅读代码的人在阅读时都觉得非常困难]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Operation Of Hexo]]></title>
    <url>%2F2019%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment The Step Of Upload12345$ hexo s$ hexo clean$ hexo g$ hexo s$ hexo d]]></content>
      <tags>
        <tag>operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目： 使用冒泡排序编写程序，实现对数组{25,24,12,76,101,96,28}的排序 2.源代码： 123456789101112131415161718192021222324252627package interest;public class pubble &#123; public static void main(String[] args) &#123; int[] arr=&#123;25,24,12,76,101,96,28&#125;; for(int i=0;i&lt;arr.length-1;i++) &#123; for(int j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println(&quot;冒泡排序的结果是：&quot;); for(int i=0;i&lt;arr.length;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非负十进制整数转换为b进制数]]></title>
    <url>%2F2019%2F06%2F07%2F%E9%9D%9E%E8%B4%9F%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BAb%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目名称 将非负十进制整数n转换成b进制。（其中b=2~16） 2.算法构造 （1）递归： 十进制数对b进制取余，若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示。然后利用递归模型返回十进制数和b进制的值，最后利用StringBuilder实现逆序输出字符串 递归模型：duigui(n,b)= duigui(n/b,b) n&gt;=0 递归出口：n&lt;b (其中为是十进制数，b为进制数) （2）非递归： 当十进制数不为0时，十进制数对b进制取余，十进制数变为原来的十进制数/b进制。若b进制为1-9进制，将余数写入字符串；进制数为10-16时，将余数用相应的字符表示，最后利用StringBuilder实现逆序输出字符串 5.经验归纳 5.1遇到的问题 &lt;1&gt;刚开始用的是数组，结果发现不用循环很难把字符赋给数组 &lt;2&gt;逆序输出那里考虑不周全 &lt;3&gt;用递归树或者递归栈描述调用过程 5.2心得体会 这次的基本要求没有什么难点，主要就是递归函数的建立，非递归比递归简单一些，就是在最后的逆序输出那里会遇到问题，上网查了一下，说是可以用StringBuffer来实现，所以基本上没什么大问题。对了~画出递归树或者递归栈的调用过程这里也是问题，第一次画，对这个概念不是很熟悉。 附：源代码 1.Test0类（主方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;import java.util.Scanner;public class Test0 &#123; static int n; static int b; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); TwoMethods t=new TwoMethods(); System.out.println(&quot;请输入一个非负整数：&quot;); n=sc.nextInt(); while(true) &#123; if(n&lt;0) &#123; System.out.println(&quot;Error！请输入一个非负整数：&quot;); n=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); while(true) &#123; if(b&lt;1||b&gt;16) &#123; System.out.println(&quot;Error！请输入你想转换的进制（1-16）：&quot;); b=sc.nextInt(); &#125; else break; &#125; System.out.println(&quot;你想使用哪种方法进行运算？1.递归 2.非递归（1/2）：&quot;); int x=sc.nextInt(); switch(x) &#123; case 1: //调用递归方法 t.digui(n,b); break; case 2: t.feidigui(n,b);//调用非递归方法 break; &#125; sc.close(); &#125;&#125; 2.两种方法实现转换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package interest;public class TwoMethods &#123; static String a=&quot;&quot;; //定义一个字符串，用来存储b进制 static int num; //b进制数 public static void feidigui(int n,int b) //非递归 &#123; while(n&gt;0) //当十进制数不为0时 &#123; num=n%b; //十进制数对b进制取余 n=n/b; //十进制数变为原来的十进制数/b进制 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; &#125; System.out.println(&quot;用非递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; public void digui(int n,int b) //递归 &#123; if(n!=0) &#123; num=n%b; //十进制数对b进制取余 if(b&lt;10) //若b进制为1-9进制 &#123; a+=num; //将余数写入字符串 &#125; else //进制数为10-16时 &#123; a+=((char)(num-10)+&apos;A&apos;); //将余数用相应的字符表示 &#125; digui(n/b,b); //利用递归模型返回十进制数和b进制的值 &#125; else &#123; System.out.println(&quot;用递归方法计算的十进制转&quot;+b+&quot;进制的转换结果是：&quot;); System.out.println(new StringBuilder(a).reverse().toString()); //利用StringBuilder实现逆序输出字符串 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的递归程序]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.题目名称 &lt;1&gt;赶鸭子问题：一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子？ &lt;2&gt;角谷定理：输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。求经过多少次可得到自然数1。 如：输入22， 输出 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 STEP=16 2.题目分析 &lt;1&gt;赶鸭子问题：假设一共有sum只鸭子，而sum=one(n)，n表示村子数，每经过一个村子就卖出one(n)/2+1只鸭子，剩下的就是下一个村子的鸭子数，也就是one(n+1)，那么鸭子总数one(n)=(one(n)/2+1)+(one(n+1))，经过运算得出鸭子总数one(n)=(one(n+1)+1)_2；题目说这个人经过七个村子后还剩两只鸭子，也就是在第8个村子的时候还有两只鸭子，也就是one(8)=2 &lt;2&gt;角谷定理：这个题的递归出口是固定的，即当得到自然数值1的时候递归结束。假设经过了sum=one(x)次操作后得到自然数1，输入的自然数一共分为3种情况，第一种是x=1，这种情况很特殊，直接sum+1输出即可；第二种情况是x为偶数，按照题目要求，将这个数有限次除以2，也就是one(x/2)，并使sum递加；第三种情况是x为奇数，将这个数有限次乘以3再加1，也就是one(x_3+1)，并使sum递加 3.算法构造 4.心得体会 递归问题主要还是数学思维，我觉得第一个题用递归方法偏难一点，但是算法构造出来实现就简单了，这两个题学C语言的时候有接触过，所以还有印象。这两道题相对以前的作业简单很多~ 附：源代码： &lt;1&gt;赶鸭子问题： 123456789101112131415161718192021222324252627282930package DuckSale;public class 卖鸭子递归 &#123; static int sum; public static void main(String[] args) &#123; int n=1; int num;//每个村子卖出的鸭子数 int sum=one(n); //刚开始的鸭子数,n个村子 System.out.println(&quot;刚开始有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++)//循环输出经过每个村子卖出的鸭子数 &#123; num=sum/2+1; sum-=num; //剩余鸭子数 System.out.println(&quot;经过第&quot;+i+&quot;个村子卖出了&quot;+num+&quot;只鸭子,还剩下&quot;+sum+&quot;只鸭子&quot;); &#125; &#125; public static int one(int n) &#123; if(n&lt;8) &#123; return 2*(one(n+1)+1); &#125; else if(n==8) &#123; return 2; &#125; return n; &#125;&#125; ②非递归实现： 1234567891011121314151617181920package DuckSale;public class 卖鸭子非递归&#123; static int sum=2;//鸭子总数 public static void main(String[] args) &#123; int num; for(int i=1;i&lt;8;i++) &#123; sum=(sum+1)*2;//循环计算出鸭子总数 &#125; System.out.println(&quot;一共有&quot;+sum+&quot;只鸭子&quot;); for(int i=1;i&lt;8;i++) &#123; num=sum/2+1; sum-=num; System.out.println(&quot;经过第&quot;+i+&quot;个村子卖了&quot;+num+&quot;只鸭子，还剩&quot;+sum+&quot;只鸭子&quot;); &#125; &#125;&#125; &lt;2&gt;角谷定理： ①递归实现： 12345678910111213141516171819202122232425262728293031323334353637package JiaoGuTheory;import java.util.Scanner;public class 角谷定理递归 &#123; static int sum=0; //计算次数 public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); int sum=one(x); System.out.println(); System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125; public static int one(int x) &#123; if(x==1) //输入的自然数为1 &#123; System.out.print(x+&quot; &quot;); sum++; &#125; else if(x%2==0) //输入的自然数为偶数 &#123; System.out.print(x+&quot; &quot;); one(x/2);//将这个数有限次除以2 sum++; &#125; else if(x%2!=0) //输入的自然数为奇数 &#123; System.out.print(x+&quot; &quot;); one(x*3+1); //将这个数有限次乘以3再加1 sum++; &#125; return sum; &#125;&#125; ②非递归实现： 1234567891011121314151617181920212223242526272829303132333435package JiaoGuTheory;import java.util.Scanner;public class 角谷定理非递归 &#123; static int sum=0; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.print(&quot;请输入一个自然数：&quot;); int x=sc.nextInt(); sc.close(); while(x&gt;=1) &#123; if(x==1) &#123; sum++; System.out.println(x); break; &#125; else if(x%2==0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x/2; &#125; else if(x%2!=0) &#123; System.out.print(x+&quot; &quot;); sum++; x=x*3+1; &#125; &#125; System.out.println(&quot;一共经过了&quot;+sum+&quot;次&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模拟肯德基快餐店的收银系统]]></title>
    <url>%2F2019%2F05%2F10%2FJava%E6%A8%A1%E6%8B%9F%E8%82%AF%E5%BE%B7%E5%9F%BA%E5%BF%AB%E9%A4%90%E5%BA%97%E7%9A%84%E6%94%B6%E9%93%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1.题目名称 模拟肯德基快餐店的收银系统 要求：结合设计模式（2种以上）至少实现系统的以下功能： 1.正常餐品结算和找零。 2.基本套餐结算和找零。 3.使用优惠劵购买餐品结算和找零。 4.可在一定时间段参与店内活动（自行设计或参考官网信息）。 5.模拟打印小票的功能（写到文件中）。 2.算法构造 这个系统需要用到两种设计模式，分别是工厂方法模式和抽象工厂模式。 &lt;1&gt;工厂方法模式：在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口。 抽象工厂(IKfcFactory)：给出具体工厂必须实现的接口； 具体工厂(ChinaKfcFactory)：在该工厂中指明生产各种抽象食物的方法：生产汉堡、薯条、鸡翅、饮料、套餐1、套餐2； 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：负责输出用户的订单信息 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：这个工厂需要生产具体的食品：麻辣奥尔良烤堡、奥尔良烤翅、普通霸王薯条、可乐饮料。 &lt;2&gt;抽象工厂模式：抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 抽象工厂(AbstractBaseFood) 具体工厂(ChinaKfcFactory) 抽象产品(Hamburg, FrenchFries, ChickenWings, Beverage, TaoCan1, TaoCan2)：相当于产品等级 具体产品(ChinaHamburg, ChinaFrenchFries, ChinaChickenWings, ChinaBeverage, RealTaocan1, RealTaocan2)：相当于产品族，生产出具体的食物 客户类(Customer)：向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。 3.类图 4.调试及运行结果 4.1调试结果 4.2运行结果 1.选择单点： 2.选择套餐 4.文件里的账单（在eclipse中打开.txt文件） 5.经验归纳 5.1遇到的问题 &lt;1&gt;将账单写入文件后.txt文件里什么都没有~ &lt;2&gt;不熟悉抽象工厂模式，将工厂方法模式和抽象方法模式混在一起了 &lt;3&gt;单品的种类太少，抽象工厂模式运用的不全面 &lt;4&gt;该系统还存在一些不足，打算后期进行优化 5.2心得体会 这个系统中，最核心的就是设计模式的选择与应用了！个人感觉我做的系统用的工厂方法模式比抽象工厂模式全面一些，因为每一种食品只有一种，没有分很多种，所以产品族的产品对象是不全面的。 还有一个很大的问题，就是账单没有办法写入文件中。我选择的是FileWriter方法将账单写入文件的，然而文件中却什么都没有。后来我发现在eclipse中打开.txt文件，账单是在文件里的，所以我没有用记事本打开.txt文件，而是选择了eclipse。 其实我觉得界面可以用Java的图形图像处理来实现，还涉及到数据库，打算考完试实现一下~~ 附：源代码 1.AbstractBaseFood接口 1234567891011121314151617package inter.KFC;//食物基类 public abstract class AbstractBaseFood &#123; //类别 protected String kind; //数量 protected int num; //价格 protected int price; //合计 public int totalPrice() &#123; return this.num * this.price; &#125;&#125; 2.抽象食物接口IFood 123456789package inter.KFC; //抽象食物接口 public interface IFood &#123; //打印输出食物信息 void printMessage();&#125; 3.肯德基抽象工厂接口IKfcFactory 12345678910111213141516171819202122232425package inter.KFC;//肯德基抽象工厂 public interface IKfcFactory &#123; //生产汉堡 public Hamburg createHamburg(int num); //生产薯条 public FrenchFries createFrenchFries(int num); //生产鸡翅 public ChickenWings createChickenWings(int num); //生产饮料 public Beverage createBeverage(int num); //生产套餐1 public TaoCan1 createTaoCan1(int num); //生产套餐2 public TaoCan2 createTaoCan2(int num);&#125; 4.肯德基具体工厂ChinaKfcFactory继承接口IKfcFactory 123456789101112131415161718192021222324252627282930313233343536package inter.KFC;//肯德基具体工厂public class ChinaKfcFactory implements IKfcFactory&#123; //生产汉堡 public Hamburg createHamburg(int num) &#123; return new ChinaHamburg(num); &#125; //生产薯条 public FrenchFries createFrenchFries(int num) &#123; return new ChinaFrenchFries(num); &#125; //生产鸡翅 public ChickenWings createChickenWings(int num) &#123; return new ChinaChickenWings(num); &#125; //生产饮料 public Beverage createBeverage(int num) &#123; return new ChinaBeverage(num); &#125; //生产套餐1 public TaoCan1 createTaoCan1(int num) &#123; return new RealTaoCan1(num); &#125; //生产套餐2 public TaoCan2 createTaoCan2(int num) &#123; return new RealTaoCan2(num); &#125; &#125; 5.客户类Customer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package inter.KFC;//客户类public class Customer &#123; //抽象工厂 private IKfcFactory kfcFactory; //构造方法将抽象工厂作为参数传入 public Customer(IKfcFactory kfcFactory)&#123; this.kfcFactory = kfcFactory; &#125; //订购食物 //订购麻辣鸡腿汉堡 public int orderHamburg(int num)&#123; //获得奥尔良烤堡 Hamburg hamburg = kfcFactory.createHamburg(num); //输出订购信息 hamburg.printMessage(); //返回总价 return hamburg.totalPrice(); &#125; //订购奥尔良烤翅 public int orderChickenWings(int num)&#123; //获得奥尔良烤鸡翅 ChickenWings chickenWings = kfcFactory.createChickenWings(num); //输出订购信息 chickenWings.printMessage(); //返回总价 return chickenWings.totalPrice(); &#125; //订购薯条 public int orderFrenchFries(int num)&#123; //获得霸王薯条 FrenchFries frenchFries = kfcFactory.createFrenchFries(num); //输出订购信息 frenchFries.printMessage(); //返回总价 return frenchFries.totalPrice(); &#125; //订购可乐 public int orderBeverage(int num)&#123; //获得可乐 Beverage beverage = kfcFactory.createBeverage(num); //输出订购信息 beverage.printMessage(); //返回总价 return beverage.totalPrice(); &#125; //订购套餐1 public int orderTaoCan1(int num)&#123; //获得套餐1 TaoCan1 taocan1=kfcFactory.createTaoCan1(num); //输出订购信息 taocan1.printMessage(); //返回总价 return taocan1.totalPrice(); &#125; //订购套餐2 public int orderTaoCan2(int num)&#123; //获得套餐2 TaoCan2 taocan2=kfcFactory.createTaoCan2(num); //输出订购信息 taocan2.printMessage(); //返回总价 return taocan2.totalPrice(); &#125;&#125; 6.汉堡基类Hamburg 1234567891011package inter.KFC;//汉堡基类 public abstract class Hamburg extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;奥尔良烤堡，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 7.汉堡子类(具体产品实现)ChinaHamburg 12345678910111213package inter.KFC;//奥尔良烤堡//具体产品public class ChinaHamburg extends Hamburg&#123; public ChinaHamburg(int num) &#123; this.kind = &quot;麻辣&quot;; this.price = 28; this.num = num; &#125;&#125; 8.薯条基类(抽象产品)FrenchFries 123456789101112package inter.KFC;//薯条基类//抽象产品public abstract class FrenchFries extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;霸王薯条，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 9.薯条子类(具体产品实现)ChinaFrenchFries 123456789101112package inter.KFC;//薯条实现类//具体产品public class ChinaFrenchFries extends FrenchFries&#123; public ChinaFrenchFries(int num) &#123; this.kind = &quot;普通&quot;; this.price = 8; this.num = num; &#125;&#125; 10.鸡翅基类(抽象产品)ChickenWings 1234567891011package inter.KFC;//鸡翅基类public abstract class ChickenWings extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;烤翅，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 11.鸡翅子类(具体产品实现)ChinaChickenWings 123456789101112package inter.KFC;//鸡翅实现类 //具体产品public class ChinaChickenWings extends ChickenWings&#123; public ChinaChickenWings(int num) &#123; this.kind = &quot;奥尔良&quot;; this.price = 5; this.num = num; &#125;&#125; 12.饮料基类(抽象产品)Beverage 1234567891011package inter.KFC;//饮料基类 public abstract class Beverage extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;饮料，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 13.饮料子类(具体产品实现)ChinaBeverage 1234567891011package inter.KFC;//可乐实现类public class ChinaBeverage extends Beverage&#123; public ChinaBeverage(int num) &#123; this.kind = &quot;可乐&quot;; this.price = 10; this.num = num; &#125;&#125; 14.套餐1基类(抽象产品)TaoCan1 12345678910package inter.KFC;//套餐1基类public abstract class TaoCan1 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐1，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 15.套餐1子类(具体产品实现)RealTaoCan1 1234567891011package inter.KFC;//套餐1实现类public class RealTaoCan1 extends TaoCan1&#123; public RealTaoCan1(int num) &#123; this.kind = &quot;超值&quot;; this.price = 50; this.num = num; &#125;&#125; 16.套餐2基类(抽象产品)TaoCan2 12345678910package inter.KFC;//套餐2基类public abstract class TaoCan2 extends AbstractBaseFood implements IFood&#123; public void printMessage()&#123; System.out.println(&quot;--&quot;+this.kind+&quot;套餐2，\t单价：&quot;+this.price+ &quot;,\t数量：&quot;+this.num+&quot;，\t合计：&quot;+this.totalPrice()); &#125;&#125; 17.套餐2子类(具体产品实现)RealTaoCan2 1234567891011package inter.KFC;//套餐2实现类public class RealTaoCan2 extends TaoCan2&#123; public RealTaoCan2(int num) &#123; this.kind = &quot;超值&quot;; this.price = 40; this.num = num; &#125;&#125; 18.菜单类MainMenu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package inter.KFC;import java.util.Scanner;import java.io.*;import java.io.FileWriter;//菜单public class MainMenu &#123; //定义一个肯德基（IKfcFactory类型） IKfcFactory kfcFactory = new ChinaKfcFactory(); //创建客户 Customer customer = new Customer(kfcFactory); Scanner sc=new Scanner(System.in); public int a; public int num1; public int num2; public int num3; public int num4; public int num5; public int num6; int hamburgMoney=customer.orderHamburg(num1); int chickenWingsMoney = customer.orderChickenWings(num2); int frenchFriesMoney = customer.orderFrenchFries(num3); int singleMoney = customer.orderBeverage(num4); int taocan1Money =customer.orderTaoCan1(num5); int taocan2Money =customer.orderTaoCan2(num6); public int price; public String b; public int c; public int d; //用户付款金额 public int e; //找零 public void menu() &#123; System.out.println(&quot;* * * * * 欢迎进入肯德基炸鸡店 * * * * *&quot;); System.out.println(&quot;* 您可以选择：1.单点 2.套餐 *&quot;); System.out.println(&quot;* 请您选择：&quot;); a=sc.nextInt(); switch(a) &#123; case 1: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;1.汉堡类：奥尔良烤堡_28元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;2.鸡翅类：奥尔良烤翅_5元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;3.小食类：霸王薯条_8元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;4.饮料类：可乐_10元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择奥尔良烤堡的数量：&quot;); num1=sc.nextInt(); hamburgMoney = customer.orderHamburg(num1); System.out.print(&quot;请您选择奥尔良烤翅的数量：&quot;); num2=sc.nextInt(); chickenWingsMoney = customer.orderChickenWings(num2); System.out.print(&quot;请您选择霸王薯条的数量：&quot;); num3=sc.nextInt(); frenchFriesMoney = customer.orderFrenchFries(num3); System.out.print(&quot;请您选择可乐的数量：&quot;); num4=sc.nextInt(); singleMoney = customer.orderBeverage(num4); price=hamburgMoney+chickenWingsMoney+frenchFriesMoney+singleMoney; System.out.println(&quot;总计：&quot;+price); break; case 2: System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐1：奥尔良烤堡+霸王薯条+可乐_50元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.println(&quot;套餐2：香辣鸡腿堡+麻辣烤翅+可乐_40元&quot;); System.out.println(&quot;- - - - - - - - - - - - - - - - - - - - - - - - &quot;); System.out.print(&quot;请您选择套餐1的数量：&quot;); num5=sc.nextInt(); taocan1Money =customer.orderTaoCan1(num5); System.out.print(&quot;请您选择套餐2的数量：&quot;); num6=sc.nextInt(); taocan2Money =customer.orderTaoCan2(num6); price=taocan1Money+taocan2Money; System.out.println(&quot;总计：&quot;+price); &#125; &#125; //领取优惠券并付款找零 public void other()&#123; System.out.println(&quot;为迎接新老顾客的到来，本店特地准备了两种优惠券&quot;); System.out.println(&quot;---1.满45减5 ---2.满65减8&quot;); System.out.print(&quot;您是否需要优惠券？(y/n)&quot;); String b=sc.next(); if(&quot;y&quot;.equals(b)) &#123; if(price&gt;=45&amp;&amp;price&lt;65) //价格在45-65之间领取5元 &#123; price-=5; c=5; //5元优惠券 &#125; else if(price&gt;=65) //价格&gt;=65领取8元 &#123; price-=8; c=8; &#125; else System.out.println(&quot;您不能使用优惠券！&quot;); System.out.println(&quot;领取&quot;+c+&quot;元优惠券成功！您一共消费：&quot;+price+&quot;元&quot;); &#125; System.out.print(&quot;付款：&quot;); d=sc.nextInt(); e=d-price; System.out.println(&quot;找零：&quot;+e); &#125; //打印账单 public void paint()&#123; System.out.print(&quot;您需要打印账单吗？(y/n)&quot;); String m=sc.next(); if(&quot;y&quot;.equals(m))&#123; //用户需要打印小票 System.out.println(&quot;您的账单为：&quot;); switch(a)&#123; case 1: hamburgMoney=customer.orderHamburg(num1); chickenWingsMoney = customer.orderChickenWings(num2); frenchFriesMoney = customer.orderFrenchFries(num3); singleMoney = customer.orderBeverage(num4); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; case 2: taocan1Money =customer.orderTaoCan1(num5); taocan2Money =customer.orderTaoCan2(num6); System.out.println(&quot;领取&quot;+c+&quot;元优惠券&quot;); System.out.println(&quot;总计：&quot;+price); System.out.println(&quot;付款：&quot;+d); System.out.println(&quot;找零：&quot;+e); break; &#125; try&#123; fully(); &#125;catch(Exception e)&#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; else if(&quot;n&quot;.equals(m))&#123; System.out.println(&quot;欢迎下次光临~&quot;); &#125; &#125; //在文件中打印小票 public void fully() throws Exception&#123; FileWriter pw=new FileWriter(&quot;zhangdan.txt&quot;,true); BufferedWriter bw=new BufferedWriter(pw); try &#123; switch(a) &#123; case 1: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;麻辣奥尔良烤堡 &quot;+&quot;单价：28 数量：&quot;+num1+&quot;合计：&quot;+hamburgMoney+&quot;\r\n&quot;); bw.write(&quot;奥尔良烤翅 &quot;+&quot;单价：5 数量：&quot;+num2+&quot;合计：&quot;+chickenWingsMoney+&quot;\r\n&quot;); bw.write(&quot;普通霸王薯条 &quot;+&quot;单价：8 数量：&quot;+num3+&quot;合计：&quot;+frenchFriesMoney+&quot;\r\n&quot;); bw.write(&quot;可乐饮料 &quot;+&quot;单价：10 数量：&quot;+num4+&quot;合计：&quot;+singleMoney+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; case 2: bw.write(&quot;* * * * * * 欢迎光临肯德基炸鸡店* * * * * * * *\r\n&quot;); bw.write(&quot;超值套餐1 &quot;+&quot;单价：50 数量：&quot;+num5+&quot;合计：&quot;+taocan1Money+&quot;\r\n&quot;); bw.write(&quot;超值套餐2 &quot;+&quot;单价：40 数量：&quot;+num6+&quot;合计：&quot;+taocan2Money+&quot;\r\n&quot;); bw.write(&quot;总计：&quot;+price+&quot;\r\n&quot;); bw.write(&quot;付款：&quot;+d+&quot;\r\n&quot;); bw.write(&quot;找零：&quot;+e+&quot;\r\n&quot;); bw.flush(); bw.close(); break; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;打印成功！欢迎下次光临~&quot;); &#125; &#125; 19.主函数MainApp 12345678910111213141516package inter.KFC;import java.util.*;import java.text.*; //获取当前系统时间public class MainApp &#123; public static void main(String[] args) &#123; Date date=new Date(); DateFormat fullFormat=DateFormat.getDateInstance(DateFormat.FULL); System.out.println(&quot;当前日期：&quot;+fullFormat.format(date)); //引用菜单类 MainMenu mainmenu=new MainMenu(); mainmenu.menu(); mainmenu.other(); mainmenu.paint(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种简单的程序设计模式实例]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.题目名称 (1)简单工厂模式 使用简单工厂模式模拟女娲（Nvwa）造人（Person），如果传入参数M，则返回一个Man对象，如果传入参数W，则返回一个Woman对象，请实现该场景。现需要增加一个新的Robot类，如果传入参数R，则返回一个Robot对象，对代码进行修改并注意女娲的变化。 (2)工厂方法模式 海尔工厂(Haier)生产海尔空调(HaierAirCondition)，美的工厂(Midea)生产美的空调(MideaAirCondition) 。使用工厂方法模式描述该场景，绘制类图并编程实现。(3)抽象工厂模式 电脑配件生产工厂生产内存、CPU等硬件设备，这些内存、CPU的品牌、型号并不一定相同，根据下面的“产品等级结构-产品族”示意图，使用抽象工厂模式实现电脑配件生产过程并绘制相应的类图，绘制类图并编程实现。 2.题目分析 (1)简单工厂模式 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 &lt;1&gt;工厂角色(Nvwa)：实现所有实例的内部逻辑； &lt;2&gt;抽象产品角色(Person)：所有对象的父类，负责描述所有实例共有的公共接口； &lt;3&gt;具体产品角色(Man,Woman,Robot)：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实现； &lt;4&gt;XML配置文件(XMLUtilNvwa,Simple.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (2)工厂方法模式 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 &lt;1&gt;抽象产品(KongTiao)：产品对象同一的基类，或者是同一的接口； &lt;2&gt;具体产品(Haier,Midea)：各个不同的实例对象类； &lt;3&gt;抽象工厂(KongTiaoFactory)：所有的子类工厂类的基类，或是同一的接口； &lt;4&gt;具体工厂(HaierFactory,MideaFactory)：负责每个不同的产品对象的实际创建； &lt;5&gt;XML配置文件(XMLUtil,FactoryMethod.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码。 (3)抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 产品等级结构：即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 &lt;1&gt;抽象工厂(ComputerFactory)：模式的核心，通常是接口或抽象类，其他的具体工厂类必须实现这个接口或继承这个抽象类； &lt;2&gt;具体工厂(macFactory,pcFactory)：直接在客户端的调用下创建产品的实例； &lt;3&gt;抽象产品(CPU,RAM)：工厂模式所创建的对象的父类，或他们共同的接口； &lt;4&gt;具体产品(pcCPU,macCPU,pcRAM,macRAM)：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。 &lt;5&gt;XML配置文件(XMLUtil,AbstractFactory.xml)：将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 3.类图设计 (1)简单工厂模式： (2)工厂方法模式： (3)抽象工厂模式： 4.经验归纳 4.1遇到的问题 &lt;1&gt;对三种模式都不太熟悉，花费的时间较多 &lt;2&gt;不懂如何解析xml文档 &lt;3&gt;eclipse版本问题导致XMLUtil代码有错误，但可以运行 4.2心得体会 第一次编写程序设计模式的代码，刚开始觉得无从下手。对三种模式不熟悉，导致花费了较多的时间，所以一直在查资料。特别实在xml文档那块，我一直没搞懂为什么要写文档而不直接用输入输出流，结果发现是将参数保存在XML的配置文件中，这样修改参数的时候就没有必要修改任何Java源代码。但是这块还是挺薄弱的，写代码的时候也不能独立完成，还需要参考老师给的代码。第一个简单工厂模式挺简单的，第三个比较难（我觉得），所以要多练习抽象工厂模式的习题~ 附：源代码 (1)简单工厂模式 &lt;1&gt;抽象产品角色(父类):Person 12345package Nvwa;public interface Person&#123; public void make();&#125; &lt;2&gt;工厂角色(实现内部逻辑):Nvwa 1234567891011121314151617181920212223242526package Nvwa;public class Nvwa &#123; public static Person producePerson(String sex) throws Exception &#123; if(sex.equalsIgnoreCase(&quot;M&quot;)) //选择&apos;M&apos; &#123; System.out.println(&quot;造了一个男人！&quot;); return new Man(); //返回参数 &#125; else if(sex.equalsIgnoreCase(&quot;W&quot;))//选择&apos;W&apos; &#123; System.out.println(&quot;造了一个女人！&quot;); return new Woman(); &#125; else if(sex.equalsIgnoreCase(&quot;R&quot;))//选择&apos;R&apos; &#123; System.out.println(&quot;造了一个机器人！&quot;); return new Robet(); &#125; else &#123; throw new Exception(&quot;对不起，女娲正在忙，没空造人！&quot;); &#125; &#125;&#125; &lt;3&gt;具体产品角色(实现类):Man,Woman,Robet: Man: 12345678package Nvwa;public class Man implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造男人...&quot;); &#125;&#125; Woman: 12345678package Nvwa;public class Woman implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造女人...&quot;); &#125;&#125; Robot: 12345678package Nvwa;public class Robet implements Person&#123; public void make() &#123; System.out.println(&quot;女娲正在造机器人...&quot;); &#125;&#125; &lt;4&gt;XML配置文件(方便修改参数):XMLUtilNvwa,Simple.xml XMLUtilNvwa： 12345678910111213141516171819202122232425262728293031XMLUtilNvwa：package Nvwa;import javax.xml.parsers.*;import org.w3c.dom.*;//import org.xml.sax.SAXException;import java.io.*;public class XMLUtilNvwa &#123; //该方法用于从XML配置文件中提取名称，并返回该名称 public static String getSexName() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;Simple.xml&quot;)); //获取包含名称的文本节点 NodeList nl = doc.getElementsByTagName(&quot;sexName&quot;); Node classNode=nl.item(0).getFirstChild(); String sexName=classNode.getNodeValue().trim(); return sexName; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; Simple.xml: 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;sexName&gt;M&lt;/sexName&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 123456789101112131415161718package Nvwa;public class Client &#123; public static void main(String args[]) &#123; try &#123; Person pe; String sexName=XMLUtilNvwa.getSexName(); pe=Nvwa.producePerson(sexName); pe.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (2)工厂方法模式 &lt;1&gt;抽象产品：KongTiao 12345package FactoryMethod;public interface KongTiao &#123; public void make();&#125; &lt;2&gt;具体产品：Haier,Midea Haier： 12345678package FactoryMethod;public class Haier implements KongTiao&#123; public void make() &#123; System.out.println(&quot;海尔空调正在使用...&quot;); &#125;&#125; Midea： 12345678package FactoryMethod;public class Midea implements KongTiao&#123; public void make() &#123; System.out.println(&quot;美的空调正在使用...&quot;); &#125;&#125; &lt;3&gt;抽象工厂：KongTiaoFactory 12345package FactoryMethod;public interface KongTiaoFactory &#123; public KongTiao produceKT();&#125; &lt;4&gt;具体工厂：HaierFactory,MideaFactory HaierFactory： 123456789package FactoryMethod;public class HaierFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---海尔工厂正在生产海尔空调 &quot;); return new Haier(); &#125;&#125; MideaFactory： 12345678package FactoryMethod;public class MideaFactory implements KongTiaoFactory&#123; public KongTiao produceKT() &#123; System.out.println(&quot;---美的工厂正在生产美的空调 &quot;); return new Midea(); &#125; &lt;5&gt;XML配置文件：XMLUtil,FactoryMethod.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123; //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;FactoryMethod.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; FactoryMethod.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;FactoryMethod.HaierFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 1234567891011121314151617package FactoryMethod;public class Client &#123; public static void main(String[] args) &#123; try&#123; KongTiao kt; KongTiaoFactory fa; fa=(KongTiaoFactory)XMLUtil.getBean(); kt=fa.produceKT(); kt.make(); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; (3)抽象工厂模式 &lt;1&gt;抽象工厂：ComputerFactory 123456package AbstractFactory;public interface ComputerFactory &#123; public CPU produceCPU(); public RAM produceRAM();&#125; &lt;2&gt;具体工厂：macFactory,pcFactory macFactory： 12345678910111213141516171819package AbstractFactory;public class macFactory implements ComputerFactory&#123; //生产macCPU public CPU produceCPU() &#123; System.out.println(&quot;生产了macCPU...&quot;); //CPU macCPU; return new macCPU(); &#125; //生产macRAM public RAM produceRAM() &#123; System.out.println(&quot;生产了macRAM...&quot;); return new macRAM(); &#125;&#125; pcFactory： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; &lt;3&gt;抽象产品：CPU,RAM CPU： 12345package AbstractFactory;public interface CPU &#123; public void make();&#125; RAM： 12345package AbstractFactory;public interface RAM &#123; public void make();&#125; &lt;4&gt;具体产品：pcCPU,macCPU,pcRAM,macRAM pcCPU： 12345678package AbstractFactory;public class pcCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;pcCPU&quot;); &#125;&#125; macCPU： 12345678package AbstractFactory;public class macCPU implements CPU&#123; public void make() &#123; System.out.println(&quot;macCPU&quot;); &#125;&#125; pcRAM： 12345678package AbstractFactory;public class pcRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;pcRAM&quot;); &#125;&#125; macRAM： 12345678package AbstractFactory;public class macRAM implements RAM&#123; public void make() &#123; System.out.println(&quot;macRAM&quot;); &#125;&#125; &lt;5&gt;XML配置文件：XMLUtil,AbstractFactory.xml XMLUtil： 12345678910111213141516171819202122232425262728293031323334package AbstractFactory;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;public class XMLUtil &#123;//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;AbstractFactory.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125;catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; AbstractFactory.xml： 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;AbstractFactory.macFactory&lt;/className&gt;&lt;/config&gt; &lt;6&gt;客户端：Client 12345678910111213141516171819202122package AbstractFactory;public class Client &#123; public static void main(String[] args) &#123; try &#123; ComputerFactory fac; CPU cpu; RAM ram; fac=(ComputerFactory)XMLUtil.getBean(); cpu=fac.produceCPU(); cpu.make(); ram=fac.produceRAM(); ram.make(); &#125; catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建RPG游戏角色]]></title>
    <url>%2F2019%2F04%2F17%2FJava%E5%88%9B%E5%BB%BARPG%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[◆题目名称 创建RPG游戏角色 ◆题目分析 该程序需要用到有关类与对象的知识点，所以不能使用C语言来编写代码，这里我选择Java语言。本题目要求的游戏角色应有以下属性：名字、性别、种族、职业、力量、敏捷、体力、智力、智慧、生命值和魔法值。本题目要求力量、敏捷、体力、智力和智慧要求是随机值（利用随机数函数来取得随机数），但是五项属性的总和应该是100，并且应该和职业相关。例如狂战士的体力和力量就要比较高，而巫师需要较高的智力，而祭司则需要较高的智慧。各职业初始属性的大致比例应遵从下表： 职业/属性 力量 敏捷 体力 智力 智慧 狂战士 40 20 30 5 5 圣骑士 25 15 30 20 10 刺客 20 35 20 15 10 猎手 15 40 15 10 20 祭司 15 20 15 35 15 巫师 10 20 10 20 40 例如，前面示意图中的祭司的初始属性，大致满足该比例，但是应该是随机的。然后利用属性值计算生命值和魔法值。 最后向用户显示该角色的所有信息，将用户创建角色的相关信息写入文件保存。 ◆算法构造 &lt;1&gt;玩家选择1，则进入游戏；选择2，可以查看游戏规则；选择3，则游戏结束。 &lt;2&gt;选择1：玩家先输入角色姓名、性别、种族以及职业，根据种族和职业的限制表判断玩家是否可以使用该职业，若不能则重新选择职业； &lt;3&gt;利用随机函数分别生成力量、敏捷、体力、智力和智慧五项属性，并将五项属性的总和控制在100，并且属性值和职业相关。可以由(int)(X+Math.random()_10-5)可以得到符合条件的属性值，其中X表示表1中的属性限定值，并计算生命值和魔法值：生命值=体力_20、魔法值=（智力+智慧）*10； &lt;4&gt;打印所有的信息并向用户显示出来； &lt;5&gt;将用户创建角色的相关信息写入txt文件保存。 ◆算法实现 写入文件代码： 123456789101112131415161718192021222324public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125; ◆调试及运行结果 ◆◆调试结果 ◆运行结果 ◆◆文件保存情况 ◆经验归纳 ◆◆遇到的问题 &lt;1&gt;对于Java中的类和对象用的还不是很熟练(还在努力学习中) &lt;2&gt;Java引用写入文件方法出问题(已解决) &lt;3&gt;Java写入文件方法内部出现异常(已解决) &lt;4&gt;IO流未声明(已解决) ◆◆心得体会 用Java写这个程序，让我查了不少有关Java的知识点。在类与对象那块还不太熟悉，其中，有一些知识点是值得记录的： ①访问另一个类中的某个方法：Start g=new Start();g.start(); ②对象引用：Random r=new Random();r.n=name; ③随机函数生成某个值：strength=(int)(40+Math.random()*10-5)(40是限制条件) ④调用写入文件方法： 12345try &#123; REFile(occ);&#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); 在百度文库查找资料的时候我发现可以将这个代码优化，即编为小游戏的形式，我打算找时间写一下。 附：源代码(部分代码参考百度文库) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package game;import java.io.*;import java.util.Scanner;import java.io.FileWriter;public class First &#123; public static void main(String[] args)&#123; //菜单 System.out.println(&quot;这是一个RPG游戏&quot;); System.out.println(&quot;1.开始游戏&quot;); System.out.println(&quot;2.游戏规则&quot;); System.out.println(&quot;3.结束游戏&quot;); System.out.print(&quot;请输入您想进行的操作：(1-3)&quot;); Scanner x=new Scanner(System.in); int num=x.nextInt(); switch(num)&#123; case 1: Start g=new Start(); g.start(); //访问Start类中的start方法开始创建角色 break; case 2: Rule r=new Rule(); r.rule(); //访问Rule类中的rule方法查看规则 break; default: System.out.println(&quot;游戏结束!&quot;); System.exit(0); //游戏结束标识 &#125; &#125;&#125;//开始游戏class Start&#123; int occ=0; String name; public void start()&#123; System.out.print(&quot;请输入您游戏角色的姓名：&quot;); Scanner a=new Scanner(System.in); String name=a.next(); System.out.print(&quot;请选择您游戏角色的性别：(男或女)&quot;); Scanner b=new Scanner(System.in); String sex=b.next(); System.out.print(&quot;请选择您游戏角色的种族：(1.人类,2.精灵,3.兽人,4.矮人,5.元素)&quot;); Scanner c=new Scanner(System.in); int race=c.nextInt(); switch(race)&#123; //职业选择 case 1: //种族为人类 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=1&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1-6之间的数字选择职业！！&quot;); &#125; break; case 2: //种族为精灵 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ&gt;=3&amp;&amp;occ&lt;=6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入3-6之间的数字选择职业！！&quot;); &#125; break; case 3: //种族为兽人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==4||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,4,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 4: //种族为矮人 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==1||occ==2||occ==5)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入1,2,5这三个数字任意一个选择职业！！&quot;); &#125; break; case 5: //种族为元素 while(true)&#123; System.out.print(&quot;请选择您的职业：(1.狂战士,2.圣骑士,3.刺客,4.猎手,5.祭司,6.巫师)&quot;); Scanner d=new Scanner(System.in); occ=d.nextInt(); if(occ==5||occ==6)&#123; //验证输入正确性，正确则跳出循环，否则输出提示。 break; &#125; else System.out.println(&quot;请输入5-6之间的数字选择职业！！&quot;); &#125; break; &#125; Random r=new Random(); r.n=name; //将姓名、性别、种族对象引用到Random类中 r.s=sex; r.ra=race; r.random(occ);//将职业传递到Random类的random方法中 &#125;&#125;//class Random&#123; String n; String s; int ra; int strength=0; //力量 int smart=0; //敏捷 int body=0; //体力 int talent=0; //智力 int wisdom=0; //智慧 int life=0; //生命值 int magic=0; //魔法值 public void random(int occ)&#123; //随机函数生成各个值 System.out.println(occ); if(occ==1) &#123; strength=(int)(40+Math.random()*10-5);//随机函数生成符合题目条件的各个值 smart=(int)(20+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(5+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==2)&#123; strength=(int)(25+Math.random()*10-5); smart=(int)(15+Math.random()*10-5); body=(int)(30+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==3)&#123; strength=(int)(20+Math.random()*10-5); smart=(int)(35+Math.random()*10-5); body=(int)(20+Math.random()*10-5); talent=(int)(15+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==4)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(40+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(10+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==5)&#123; strength=(int)(15+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(15+Math.random()*10-5); talent=(int)(35+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; else if(occ==6)&#123; strength=(int)(10+Math.random()*10-5); smart=(int)(20+Math.random()*10-5); body=(int)(10+Math.random()*10-5); talent=(int)(20+Math.random()*10-5); wisdom=100-strength-smart-body-talent; &#125; life=body*20; //计算生命值和魔法值 magic=(talent+wisdom)*10; print(occ); //调用打印方法 try &#123; //调用写入文件方法 REFile(occ); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //打印 public void print(int occ)&#123; System.out.println(&quot;* * * * * * * * * * * * *&quot;); System.out.println(&quot;* 姓名：&quot;+n+&quot; *&quot;); System.out.println(&quot;* 性别：&quot;+s+&quot; *&quot;); System.out.println(&quot;* 种族：&quot;+ra+&quot; *&quot;); System.out.println(&quot;* 职业：&quot;+occ+&quot; *&quot;); System.out.println(&quot;* 力量：&quot;+strength+&quot; *&quot;); System.out.println(&quot;* 敏捷：&quot;+smart+&quot; *&quot;); System.out.println(&quot;* 体力：&quot;+body+&quot; *&quot;); System.out.println(&quot;* 智力：&quot;+talent+&quot; *&quot;); System.out.println(&quot;* 智慧：&quot;+wisdom+&quot; *&quot;); System.out.println(&quot;* 生命值：&quot;+life+&quot; *&quot;); System.out.println(&quot;* 魔法值：&quot;+magic+&quot; *&quot;); System.out.println(&quot;* * * * * * * * * * * * *&quot;); &#125; //写入文件 public void REFile(int occ) throws IOException&#123; //throws IOException:异常处理 FileWriter writer=new FileWriter(&quot;message.txt&quot;,true);//存入信息，不会将以前的信息覆盖 try &#123; writer.write(&quot;姓名: &quot;+n+&quot;\t&quot;); //&quot;\t&quot;表示空格 writer.write(&quot;性别 : &quot;+s+&quot;\t&quot;); writer.write(&quot;种族 : &quot;+ra+&quot;\t&quot;); writer.write(&quot;职业 : &quot;+occ+&quot;\t&quot;); writer.write(&quot;力量 : &quot;+strength+&quot;\t&quot;); writer.write(&quot;敏捷 : &quot;+smart+&quot;\t&quot;); writer.write(&quot;体力 : &quot;+body+&quot;\t&quot;); writer.write(&quot;智力 : &quot;+talent+&quot;\t&quot;); writer.write(&quot;智慧 : &quot;+wisdom+&quot;\t&quot;); writer.write(&quot;生命值: &quot;+life+&quot;\t&quot;); writer.write(&quot;魔法值: &quot;+magic+&quot;\r\n&quot;);//&quot;\r\n&quot;表示空行 writer.flush(); writer.close(); //关闭文件 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;创建成功！&quot;); &#125; &#125;//游戏规则class Rule&#123; public void rule()&#123; System.out.println(&quot;很多职业会限制某些种族选择,种族和职业的限制情况如下：(下表均为不允许)&quot;); System.out.println(&quot;┎---------------------------------------------┒&quot;); System.out.println(&quot;│ 种 类 职 业 │&quot;); System.out.println(&quot;│ 精灵 狂战士、圣骑士 │&quot;); System.out.println(&quot;│ 兽人 圣骑士、刺客、巫师 │&quot;); System.out.println(&quot;│ 矮人 刺客、猎手、巫师 │&quot;); System.out.println(&quot;│ 元素 狂战士、圣骑士、刺客、猎手 │&quot;); System.out.println(&quot;┖---------------------------------------------┚&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24点游戏简单版]]></title>
    <url>%2F2019%2F04%2F10%2F24%E7%82%B9%E6%B8%B8%E6%88%8F%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[●题目名称 24点游戏（经典的纸牌益智游戏） ●题目分析 随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，可以利用穷举法列出4个数字加减乘除的各种可能性，包括括号的算法，并且要利用循环控制计算范围，防止出现重复的表达式。 ●算法构造 &lt;1&gt;利用随机函数生成4个随机数 &lt;2&gt;将4个数所有可能的顺序列举，并调用计算函数 &lt;3&gt;循环调用使4个数字分别进行两两运算，并将表达式储存在一个数组中 &lt;4&gt;将3个运算符的顺序进行调整，调用加减乘除运算操作函数计算并输出 ●算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #define N 10 //定义四个数的取值最大为10double operate(double a,double b,char ch) //加减乘除运算操作函数 &#123; if(ch==&apos;+&apos;) return a+b; else if(ch==&apos;-&apos;) return a-b; else if(ch==&apos;/&apos;) return a/b; else if(ch==&apos;*&apos;) return a*b; else return 0; &#125; int precede(char a,char b) //判断优先级函数 &#123; if(a==&apos;+&apos;||a==&apos;-&apos;) &#123; if(b==&apos;*&apos;||b==&apos;/&apos;) return 1; if(b==&apos;+&apos;||b==&apos;-&apos;) return 0; &#125; if(a==&apos;*&apos;||a==&apos;/&apos;) return 0; return 0; &#125; int check(double A,double B,double C,double D) &#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; //数组储存运算符 double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) //循环调用使A,B进行运算操作,d[]为运算符,运算结果存到a[]中 a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); //A,B运算的结果和C运算，结果存到b[][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //循环防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); //A,B,C运算的结果和D运算，结果存到c[][][]中 for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 return 1; &#125; return 0; &#125; void SHOW(double A,double B,double C,double D) //输出函数，运算过程与check()函数相同&#123; int i,j,k; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; double a[N],b[N][N],c[N][N][N]; for(i=0;i&lt;4;i++) a[i]=operate(A,B,d[i]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) b[i][j]=operate(a[i],C,d[j]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) //防止重复 c[i][j][k]=operate(b[i][j],D,d[k]); for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) for(k=0;k&lt;4;k++) &#123; if(c[i][j][k]==24.0) //判断四个数运算结果是否为24 &#123; if(precede(d[i],d[j])) //调用判断优先级函数，判断第一、第二个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f)%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); //(AB)CD printf(&quot;\n&quot;); &#125; else if(precede(d[j],d[k])) //调用判断优先级函数，判断第二、第三个运算符可能出现的情况 &#123; printf(&quot;(%.0f%c%.0f%c%.0f)%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; else //调用判断优先级函数，判断第一、第三个运算符可能出现的情况 &#123; printf(&quot;%.0f%c%.0f%c%.0f%c%.0f=24&quot;,A,d[i],B,d[j],C,d[k],D); printf(&quot;\n&quot;); &#125; &#125; &#125; &#125; void game_24() &#123; double A=0,B=0,C=0,D=0; char j; char d[4]=&#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;; srand((unsigned)time(NULL)); while(1) &#123; while((A==0||B==0)||(C==0||D==0)) //当A,B,C,D不为0时，4个随机数赋值给A,B,C,D &#123; A=rand()%10*1.0; B=rand()%10*1.0; C=rand()%10*1.0; D=rand()%10*1.0; &#125; if((check(A,B,C,D)||check(B,C,A,D))||(check(C,B,D,A)||check(D,A,B,C))) break; else &#123; A=0; B=0; C=0; D=0; &#125; &#125; printf(&quot;随机生成四个数为：&quot;); printf(&quot;%.0f %.0f %.0f %.0f\n&quot;,A,B,C,D); printf(&quot;是否要看答案(y/n):&quot;); while(1) &#123; scanf(&quot;%s&quot;,&amp;j); if(j==&apos;y&apos;||j==&apos;Y&apos;) &#123; SHOW(A,B,C,D); //将24种可能列举，并调用函数计算并输出结果 SHOW(A,B,D,C); SHOW(A,D,B,C); SHOW(A,D,C,B); SHOW(A,C,B,D); SHOW(A,C,D,B); SHOW(B,A,C,D); SHOW(B,A,D,C); SHOW(B,C,A,D); SHOW(B,C,D,A); SHOW(B,D,A,C); SHOW(B,D,C,A); SHOW(C,A,B,D); SHOW(C,A,D,B); SHOW(C,B,A,D); SHOW(C,B,D,A); SHOW(C,D,A,B); SHOW(C,D,B,A); SHOW(D,A,B,C); SHOW(D,A,C,B); SHOW(D,B,A,C); SHOW(D,B,C,A); SHOW(D,C,A,B); SHOW(D,C,B,A); break; &#125; else printf(&quot;是否要看答案(y/n):&quot;); &#125; &#125; void menu() &#123; int i; while(1) &#123; system(&quot;cls&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 智力游戏24点 *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* 1.开始游戏. *\n&quot;); printf(&quot;* 2.退出游戏. *\n&quot;); printf(&quot;* *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;你准备好了吗？\n&quot;); printf(&quot;输入你的选择:&quot;); scanf(&quot;%d&quot;,&amp;i); if(i==3) break; switch(i) &#123; case 1: game_24(); //开始游戏 system(&quot;PAUSE&quot;); break; default: printf(&quot;error input!\n&quot;); system(&quot;PAUSE&quot;); &#125; &#125; &#125; void main() &#123; menu(); &#125; ●经验归纳 ●●遇到的问题 &lt;1&gt;在防止重复问题上有点迷茫，已解决 &lt;2&gt;对数据结构栈不够清楚，未写提高要求 ●●心得体会 感觉自己对数据结构栈的知识点很薄弱，需要加强。而且在解决基本要求时考虑的不够全面，刚开始没有考虑到防止重复的问题，还有出现过进入无限循环的问题，好在均已解决，但是随机函数生成4个数字的时候，4个数字可能会出现重复的情况，我在网上找了一下，有不重复的随机函数代码，在这里不赘述了。 个人认为这个代码还可以优化~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于文件的C语言学生信息管理系统]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[●题目名称 C语言学生信息管理系统 ●题目分析 将文件引入学生信息管理系统，完善学生信息数据的处理，包括信息的读取、保存、刷新。编写与文件有关的程序，需要考虑将对文件以什么方式操作，文件能否被打开，文件在什么位置。为了程序的可读性，一般将文件的读取、存盘、操作自定义为函数。 ●算法构造 ●●刷新学生信息update()函数 &lt;1&gt;以只读方式打开指定文件，判断文件是否为空，若为空，则提示：文件为空！ &lt;2&gt;循环读入学生信息，并累加当前记录的学生人数n &lt;3&gt;输出提示：刷新成功！ &lt;4&gt;关闭文件 ●●查询学生信息seek()函数 &lt;1&gt;用户输入要进行的操作:1.按学号查询；2.按姓名查询；3.退出本菜单 &lt;2&gt;选择1：输入要查询的学生的学号；判断输入的学号和存好的学号一致；一致则输出学生的信息，不一致则输出：该学号不存在！ &lt;3&gt;选择2：输入要查询的学生的姓名；判断输入的姓名和存好的姓名一致；一致则输出学生的信息，不一致则输出：该姓名不存在！ ●●修改学生信息modify()函数 &lt;1&gt;输入要修改的学生的学号 &lt;2&gt;比较输入的学号和文件存好的学号是否一致，选择要进行的操作编号：1.修改姓名；2.修改年龄；3.修改性别；4.修改C语言成绩；5.修改高等数学成绩；6.修改大学英语成绩；7.退出本菜单 &lt;3&gt;选择1：输入新的姓名s2；新的姓名s2替换原来的姓名；保存新的姓名 &lt;4&gt;选择2：输入新的年龄age；新的姓名age替换原来的年龄；保存新的年龄 &lt;5&gt;选择3：输入新的性别sex1；新的性别sex1替换原来的性别；保存新的性别 &lt;6&gt;选择4：输入新的C语言成绩score1；新的C语言成绩score1替换原来的C语言成绩；保存新的C语言成绩 &lt;7&gt;选择5：输入新的高等数学成绩score1；新的高等数学成绩score1替换原来的高等数学成绩；保存新的高等数学成绩 &lt;8&gt;选择6：输入新的大学英语成绩score1；新的大学英语成绩score1替换原来的姓名；保存新的大学英语成绩 &lt;9&gt;选择7：返回主菜单 ●●插入学生信息函数insert()函数 &lt;1&gt;输入待增加的学生数n &lt;2&gt;循环依次输入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;将这些信息依次写入文件 &lt;4&gt;提示：添加成功！ &lt;5&gt;调用按学号排序函数，将信息排序好 &lt;5&gt;关闭文件 ●●按学号删除信息del()函数 &lt;1&gt;输入要删除学生的学号s1 &lt;2&gt;初始化flag=0，进入循环，比较输入的学号和文件记录的学号是否一致，若一致则令flag=1，循环将后面的学生记录向前移动 &lt;3&gt;判断flag=0，提示：该学号不存在！ &lt;4&gt;判断flag=1，学生人数-1并保存，提示：删除成功！ &lt;5&gt;关闭文件 ●●显示当前信息display()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次输出每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●●保存当前学生信息fileWrite()函数 &lt;1&gt;打开文件 &lt;2&gt;读取文件信息；若文件为空，则提示：文件为空！若文件不为空，则循环依次写入每个学生的学号、姓名、性别、年龄、C语言成绩、高等数学成绩、大学英语成绩 &lt;3&gt;关闭文件 ●源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432#include&lt;stdio.h&gt; /*I/O函数*/#include&lt;stdlib.h&gt; /*其它说明*/#include&lt;string.h&gt; /*字符串函数*/#define max 100#define LEN 15 /* 学号和姓名最大字符数,实际请更改*/#define N 100 /* 最大学生人数,实际请更改*/int k=1,n=0, m=0;/* n代表当前记录的学生人数*///学生信息结构体struct student &#123; char no[LEN];//学号 char name[LEN];//姓名 char sex[LEN];//性别 int age;//年龄 float C;//c语言成绩 float M;//数学成绩 float E;//英语成绩&#125;stu[N];void fileWrite();//系统帮助及说明void help() &#123; printf("\n0.欢迎使用系统帮助！\n"); printf("\n1.初次进入系统后,请先选择增加学生信息;\n"); printf("\n2.按照菜单提示键入数字代号;\n"); printf("\n3.增加学生信息后,切记保存;\n"); printf("\n4.谢谢您的使用！\n");&#125;//刷新学生信息void update()&#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s,%s,%s,%d,%f,%f,%f\n",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) //从文件中读取信息 &#123; j++; &#125; n=j; printf("\n 提示：刷新成功!!! \n"); fclose(fp);&#125;//查询学生信息void seek() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i=0,item,flag; char s1[LEN+1]; /* 以姓名和学号最长长度+1为准*/ printf("----------------------\n"); printf("-----1.按学号查询-----\n"); printf("-----2.按姓名查询-----\n"); printf("-----3.退出本菜单-----\n"); printf("----------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); //用户输入要进行的操作 flag=0; switch(item) &#123; case 1: printf("请输入要查询的学生的学号:\n"); scanf("%s",&amp;s1); for(i=0; i&lt;n; i++) //n代表当前记录的学生人数 if(strcmp(s1,stu[i].no)==0) //strcmp()是字符串比较函数，判断输入的学号和存好的学号一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的学号和存好的学号不一致 printf("该学号不存在！\n"); break; case 2: printf("请输入要查询的学生的姓名:\n"); scanf("%s",&amp;s1); //输入学生姓名 for(i=0; i&lt;n; i++) if(strcmp(stu[i].name,s1)==0) //输入的姓名和存好的姓名一致 &#123; flag=1; printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); //输出学生的信息 &#125; if(0==flag) //输入的姓名和存好的姓名不一致 printf("该姓名不存在！\n"); break; case 3: return; default: printf("请在1-3之间选择\n"); &#125; &#125;&#125;//修改学生信息void modify() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) &#123; printf("\n 警告：打开文件错误，请退出重新打开！\n"); system("pause"); exit(0); &#125; while(fscanf(fp,"%s %s %s %d %f %f %f",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,item=0,num; int age; char sex1[4],s1[LEN+1],s2[LEN+1]; /* 以姓名和学号最长长度+1为准*/ float score1; printf("请输入要修改的学生的学号:"); scanf("%s",s1); for(i=0;i&lt;n;i++) &#123; if(strcmp(stu[i].no,s1)==0) /*比较字符串是否相等*/ &#123; num=i; //给num赋i值 printf("------------------\n"); printf("1.修改姓名\n"); printf("2.修改年龄\n"); printf("3.修改性别\n"); printf("4.修改C语言成绩\n"); printf("5.修改高等数学成绩\n"); printf("6.修改大学英语成绩\n"); printf("7.退出本菜单\n"); printf("------------------\n"); while(1) &#123; printf("请选择子菜单编号:"); scanf("%d",&amp;item); switch(item) &#123; case 1: printf("请输入新的姓名:"); scanf("%s",s2); strcpy(stu[num].name,s2); //strcpy()是字符串复制函数，将新输入的值赋给原先的值 fileWrite(); break; case 2: printf("请输入新的年龄:"); scanf("%d",&amp;age); stu[num].age=age; fileWrite(); break; case 3: printf("请输入新的性别:"); scanf("%s",&amp;sex1); strcpy(stu[num].sex,sex1); fileWrite(); break; case 4: printf("请输入新的C语言成绩:"); scanf("%d",&amp;score1); stu[num].C=score1; fileWrite(); break; case 5: printf("请输入新的高等数学成绩:"); scanf("%d",&amp;score1); stu[num].M=score1; fileWrite(); break; case 6: printf("请输入新的大学英语成绩:"); scanf("%d",&amp;score1); stu[num].E=score1; fileWrite(); break; case 7: return; default: printf("请在1-7之间选择\n"); &#125; &#125; &#125; else &#123; printf("没有该学生学号!!!"); &#125; &#125;&#125;//按学号排序函数void sort()&#123; int i,j,*p,*q,s; char temp[LEN+1],ctemp[LEN]; float *x,*y,z; float *a,*b,c; float *k,*l,h; for(i=0;i&lt;n-1;i++) &#123; for(j=n-1;j&gt;i;j--) if(strcmp(stu[j-1].no,stu[j].no)&gt;0) &#123; strcpy(temp,stu[j-1].no); strcpy(stu[j-1].no,stu[j].no); strcpy(stu[j].no,temp); strcpy(temp,stu[j-1].name); strcpy(stu[j-1].name,stu[j].name); strcpy(stu[j].name,temp); p=&amp;stu[j-1].age; q=&amp;stu[j].age; s=*q; *q=*p; *p=s; strcpy(ctemp,stu[j-1].sex); strcpy(stu[j-1].sex,stu[j].sex); strcpy(stu[j].sex,ctemp); x=&amp;stu[j-1].C; y=&amp;stu[j].C; z=*x; *x=*y; *y=z; a=&amp;stu[j-1].M; b=&amp;stu[j].M; c=*a; *a=*b; *b=c; k=&amp;stu[j-1].E; l=&amp;stu[j].E; h=*k; *k=*l; *l=h; &#125; &#125;&#125;//插入学生信息函数void insert() &#123; int i; printf("请输入待增加的学生数:"); scanf("%d",&amp;n); FILE * fp; if((fp=fopen("student.txt","at"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; printf("\n请输入第%d个学生的学号：",i+1); scanf("\n%s",&amp;stu[i].no); printf("\n请输入第%d个学生的姓名：",i+1); scanf("%s",&amp;stu[i].name); printf("\n请输入第%d 个学生的性别：",i+1); scanf("%s",&amp;stu[i].sex); printf("\n请输入第%d 个学生的年龄:",i+1); scanf("%d",&amp;stu[i].age); printf("\n请输入第%d 个学生的C语言成绩:",i+1); scanf("%d",&amp;stu[i].C); printf("\n请输入第%d 个学生的高等数学成绩:",i+1); scanf("%d",&amp;stu[i].M); printf("\n请输入第%d 个学生的大学英语成绩:",i+1); scanf("%d",&amp;stu[i].E); sort(); //调用按学号排序函数 //写入文件 fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; printf("\n添加成功!!!\n"); fclose(fp);&#125;//按学号删除信息void del() &#123; int j=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) return ; while(fscanf(fp,"%s %s %s %d %f %f %f ",&amp;stu[j].no,&amp;stu[j].name,&amp;stu[j].sex,&amp;stu[j].age,&amp;stu[j].C,&amp;stu[j].M,&amp;stu[j].E)==7) &#123; j++; &#125; n=j; int i,flag=0; char s1[LEN+1]; printf("请输入要删除学生的学号:\n"); scanf("%s",s1); for(i=0; i&lt;n; i++) &#123; if(strcmp(stu[i].no,s1)==0) //比较输入的学号和记录的学号一致 &#123; flag=1; for(j=i; j&lt;n-1; j++) &#123; stu[j]=stu[j+1]; //后面的学生记录向前移动 &#125; &#125; &#125; if(flag==0) //比较输入的学号和记录的学号不一致 printf("该学号不存在！\n"); if(flag==1) //判断flag的值为1，则成功删除 &#123; n--; //删除成功后，学生人数-1 fileWrite(); fclose(fp); printf("删除成功,显示结果请选择菜单\n"); &#125;&#125;//显示当前信息void display() &#123; int i=0; FILE * fp; if((fp=fopen("student.txt","r"))==NULL) printf("文件为空！\n"); while(fscanf(fp,"%s %s %s %d %f %f %f",stu[i].no,stu[i].name,stu[i].sex,&amp;stu[i].age,&amp;stu[i].C,&amp;stu[i].M,&amp;stu[i].E)==7) &#123; i++; &#125; n=i; //记录文件中数据的行数 printf("学生学号 学生姓名 年龄 性别 C语言成绩 高等数学 大学英语成绩\n"); printf("--------------------------------------------------------------------\n"); for(i=0;i&lt;n;i++) //依次输出学生信息 &#123; printf("%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp);&#125;//保存当前学生信息void fileWrite()&#123; FILE *fp; int i; if((fp=fopen("student.txt","w"))==NULL) printf("文件为空！\n"); for(i=0; i&lt;n; i++) &#123; fprintf(fp,"%s %16s %10s %10d %10.1f %10.1f %10.1f\n",stu[i].no,stu[i].name,stu[i].sex,stu[i].age,stu[i].C,stu[i].M,stu[i].E); &#125; fclose(fp); printf("保存成功!!!");&#125; //界面void menu() &#123; int num; printf(" \n\n \n\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf(" * 学生信息管理系统 *\n"); printf(" * *\n"); printf(" * * * * * * * *系统功能菜单* * * * * * * *\n"); printf(" * -------------------------------------------- *\n"); printf(" * *\n"); printf(" * 0.系统帮助及说明 | 1.刷新学生信息 *\n"); printf(" * *\n"); printf(" * 2.查询学生信息 | 3.修改学生信息 *\n"); printf(" * *\n"); printf(" * 4.增加学生信息 | 5.按学号删除信息 *\n"); printf(" * *\n"); printf(" * 6.显示当前信息 | 7.保存当前学生信息 *\n"); printf(" * *\n"); printf(" * 8.退出系统 *\n"); printf(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n"); printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n"); printf("请选择菜单编号:"); scanf("%d",&amp;num); switch(num) &#123; case 0: help(); break; case 1: update(); break; case 2: seek(); break; case 3: modify(); break; case 4: insert(); break; case 5: del(); break; case 6: display(); break; case 7: fileWrite(); break; case 8: k=0; break; default: printf("请在0-8之间选择\n"); &#125;&#125;//主函数 int main() &#123; while(k) &#123; menu(); &#125; system("pause"); return 0;&#125; ●经验归纳 ●●遇到的问题 程序无法读取文件信息：对文件的概念不清楚，文件的读取中各个数据之间不能用逗号隔开 ●●算法优化 &lt;1&gt;将主函数写到子函数后面，删去函数声明 &lt;2&gt;利用结构体，使学生信息更加结构化 &lt;3&gt;新增按学号排序函数，用户在增加了学生信息后，调用该函数，将文件中学生信息按学号排序好 &lt;4&gt;优化删除学生信息函数，直接将后面的学生记录向前移动 &lt;5&gt;将每个涉及文件的子函数都加入了文件读取功能，目的是进行相应操作时不必每次都要先执行刷新函数 &lt;6&gt;优化修改学生信息函数，每次修改完都调用保存函数，实现自动保存 ●●心得体会 学生信息管理系统是我们在学习C语言时的典例，但是我感觉在文件读取方面基础还是比较薄弱，一些基础性的知识点还是不能记住，所以以后要多多练习与读取文件有关的习题。]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求N个数的最大公约数和最小公倍数&&Hankson问题]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%B1%82N%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%26%26Hankson%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[● 题目名称 &lt;1&gt;求N个数的最大公约数和最小公倍数 &lt;2&gt;计算出Hankson的“逆问题”的答案 ● 题目分析 &lt;1&gt;求N个数的最大公约数和最小公倍数：可以先求出第一个数和第二个数的最大公约数和最小公倍数，再将这个最大公约数和最小公倍数与下一个数计算出新的最大公约数和最小公倍数，以此类推 &lt;2&gt;计算出Hankson的“逆问题”的答案：先输入组数，再根据组数以每组4个数循环输入，然后判断输入的四个数是否满足条件，接着再调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件，若满足，则累加，最后输出累加的结果 ● 算法构造 ● ● 求N个数的最大公约数和最小公倍数 &lt;1&gt;输入要计算最大公约数和最小公倍数的整数个数 &lt;2&gt;循环输入整数 &lt;3&gt;调用函数，求出这些整数的最大公约数和最小公倍数 &lt;4&gt;先计算出两个数的最大公约数（最小公倍数），再用该最大公约数（最小公倍数）和下一个数求最大公约数（最小公倍数），以此类推 &lt;5&gt;输出这些整数的最大公约数和最小公倍数 ● ● 计算出Hankson的“逆问题”的答案 &lt;1&gt;输入组数 &lt;2&gt;每组输入四个数，判断是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;3&gt;循环依次输入各组，每组4个数 &lt;4&gt;判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &lt;5&gt;循环计算有多少个满足条件的数，调用计算两个数的最大公约数和最小公倍数的函数，判断x是否满足条件 &lt;6&gt;输出累加的数 ● 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;stdio.h&gt;//辗转相除法求两个数的最大公约数int max1(int a,int b) &#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;//求n个数的最大公约数int max2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; z=max1(x,y); //先计算出两个数的最大公约数，再用该最大公约数和下一个数求最大公约数，以此类推 for(int i=2;i&lt;n;i++) z=max1(z,a[i]); return z;&#125; //求两个数的最小公倍数int min1(int a,int b) &#123; int max1(int a,int b); //自定义函数返回值类型 int temp; temp=max1(a,b); //再次调用自定义函数，求出最大公约数 return (a*b/temp); //返回最小公倍数到主调函数处进行输出&#125;//求n个数的最小公倍数int min2(int a[],int n)&#123; int x=a[0],y=a[1],z=0; //与n个数的最大公约数同理 z=min1(x,y); for(int i=2;i&lt;n;i++) z=min1(z,a[i]); return z;&#125;void main()&#123; int n=0,x=0,max=0,min=0,b,sum=0,i=0; int c[4]; int a[]=&#123;0&#125;; printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;* 1.输入n个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.计算出Hankson的“逆问题”的答案. *\n&quot;); printf(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x&lt;1||x&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;x); &#125; switch(x) &#123; case 1: printf(&quot;请输入你想要计算的整数个数（大于1）：&quot;); scanf(&quot;%d&quot;,&amp;n); //输入要计算最大公约数和最小公倍数的整数个数 printf(&quot;请依次输入整数：\n&quot;); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //循环输入整数 max=max2(a,n); //调用函数，求出这些整数的最大公约数 min=min2(a,n); //调用函数，求出这些整数的最小公倍数 printf(&quot;这些数的最大公约数为：%d\n&quot;,max); printf(&quot;这些数的最小公倍数为：%d\n&quot;,min); break; case 2: printf(&quot;请输入数据的组数：&quot;); scanf(&quot;%d&quot;,&amp;b); //输入组数 printf(&quot;每组输入四个数，要求：保证第一个数能被第二个数整除，第三个数能被第四个数整除：\n&quot;); for(;b&gt;0;b--) //循环依次输入b个组 &#123; for(i=0;i&lt;4;i++) //每组4个数 &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; if(c[0]%c[1]!=0||c[3]%c[2]!=0) //判断输入的4个数是否满足第一个数能被第二个数整除，第三个数能被第四个数整除的条件 &#123; printf(&quot;输入不符合条件，请重新输入：\n&quot;); for(i=0;i&lt;4;i++) &#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; &#125; for(int y=0;y&lt;=c[3];y++) //循环计算有多少个满足条件的数 &#123; if(max1(y,c[0])==c[1]&amp;&amp;min1(y,c[2])==c[3]) //调用计算两个数的最大公约数和最小公倍数的函数，判断y是否满足条件 sum++; &#125; printf(&quot;一共有%d个数满足条件\n&quot;,sum); sum=0; //累加sum初始化 &#125; &#125;&#125; ● 经验归纳 ● ● 遇到的问题 &lt;1&gt;习惯了计算两个数的最大公约数和最小公倍数，对N个数迷茫了… &lt;2&gt;最大公约数和最小公倍数计算有误 &lt;3&gt;提高要求要输入的那四个数的限制条件运用不当，审题不清，导致频繁出错 &lt;4&gt;在一次循环之后未将累加的值初始化，导致下一次循环完毕后的结果有误 ● ● 心得体会 以前都是计算两个数的最大公约数和最小公倍数，这次要计算n个数的最大公约数和最小公倍数，我其实运用的还是计算两个数的那个思想，就是加入了函数调用。 感觉自己有时候还挺粗心的（也可能是代码敲久了有点晕hhh），还有就是提高要求把我卡住了。。完全不知道逆着怎么求…查了一些资料，然后和一起去图书馆敲代码的同学讨论了一下，大体有思路了，但只要写程序就有错误。。。。 失误挺多的，希望自己能在以后的程序生涯里越来越棒，小细节都可以注意到~]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JAVA编写奇数累加和猜数字小游戏代码（包含JAVA产生随机数）]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8JAVA%E7%BC%96%E5%86%99%E5%A5%87%E6%95%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%8C%9C%E6%95%B0%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8C%85%E5%90%ABJAVA%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.题目名称： 奇数累加、猜数字小游戏 2.题目要求： 求自然数1-99的所有奇数累加的和； 计算机自动生成答案，玩家手动输入其猜想的数字，判断玩家是否猜对。 3.算法分析： 3.1奇数累加 （1）利用for循环，遍历自然数并限制累加范围在1-99之内 （2）遍历过程中，判断正在遍历的自然数是否奇数 （3）如果是奇数，则进行累加 3.2猜数字小游戏 （1）利用随机数产生一个1-100的整数，即为正确答案 （2）玩家输入一个整数 （3）如果玩家输入的数为0，则退出游戏；如果玩家输入的数小于0或大于100，则重新输入 （4）利用循环判断计算机生成的数和玩家输入的数是否一致 （5）如果不一致：玩家输入的过大，则提示“太大了”；玩家输入的过小，则提示“太小了” （6）如果玩家输入的数与计算机产生的数一致，则提示“恭喜你，答对啦！” 4.源代码： 4.1奇数累加 12345678910111213package com.itheima.first;public class Sum &#123; public static void main(String[] args)&#123; int i,sum=0; for(i=1;i&lt;100;i++) &#123; if(i%2!=0) sum+=i; &#125; System.out.println(&quot;在自然数1-99中奇数累加之和为：&quot;+sum); &#125;&#125; 4.2猜数字小游戏 12345678910111213141516171819202122232425262728293031323334package interesting;import java.util.Scanner;public class game &#123; public static void main(String[] args) &#123; int n=(int)(Math.random()*100)+1; //利用随机数生成一个正确答案 Scanner a=new Scanner(System.in); System.out.println(&quot;***********这是一个猜数字的游戏***********\n&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)，退出游戏请按0：&quot;); int b=a.nextInt(); while(b&lt;0||b&gt;100) &#123; System.out.println(&quot;输入错误~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; if(b==0) System.out.println(&quot;你已退出游戏~~~&quot;); else &#123; while(b!=n) //如果用户输入的数与正确答案不符 &#123; if(b&gt;n) System.out.println(&quot;太大了~&quot;); else if(b&lt;n) System.out.println(&quot;太小了~&quot;); System.out.println(&quot;请输入你认为的正确答案(1-100)：&quot;); b=a.nextInt(); &#125; &#125; if(b==n) System.out.println(&quot;恭喜你，猜对啦!&quot;); &#125;&#125; 5.心得体会： 这些都是简单的程序，但是JAVA与C语言和C++的语法不一样，比如游戏里的产生随机数，我本来用的是C语言的随机数，但运行的时候发现了错误，于是我上网搜了一下，发现JAVA和C语言的随机数不一样；JAVA的输入代码，我在网上找了一下，接收字符和数字的输入代码是不一样的~ 还有程序最后保存是以文件夹的形式，我不知道最好是删除某个文件还是保留整个文件夹…于是我又做了新的尝试，我只留了src那个文件夹，然后…代码运行不了…我只好重新建了个项目，这次不敢删了… 不过这是我第一次用JAVA写代码呢感觉自己学到了很多*****]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方法计算两个数的最大公约数]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0~~~%2F</url>
    <content type="text"><![CDATA[1.题目名称 计算两个数的最大公约数 2.题目分析 计算两个数的最大公约数，可以采用最大公约数的四种常用算法，分别是辗转相除法、穷举法、更相减损法、Stein算法。每种方法写一个函数，分别计算出最大公约数，主函数的菜单里有选择功能，用户可以选择自行输入两个数，然后调用这四种方法的任一种；也可以选择程序的测试功能，通过自己选择的组数，计算机自动产生随机函数，然后调用四种方法的任一种，并计算出程序运行的时间。 3.算法构造 3.1辗转相除法 设两数为a,b设其中a 做被除数,b做除数，temp为余数 1、大数放a中、小数放b中； 2、求a/b的余数； 3、若temp=0则b为最大公约数； 4、如果temp!=0则把b的值给a、temp的值给a； 5、返回第二步； 3.2穷举法（利用数学定义） 穷举法（也叫枚举法）穷举法求两个正整数的最大公约数的解题步骤： 从两个数中较小数开始由大到小列举，直到找到公约数立即中断列举，得到的公约数便是最大公约数 。 对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp能同时被a和b所整除，则temp即为最大公约数。 3.3更相减损法 更相减损术，是出自《九章算术》的一种求最大公约数的算法，它原本是为约分而设计的，但它适用于任何需要求最大公约数的场合。《九章算术》是中国古代的数学专著，其中的“更相减损术”可以用来求两个数的最大公约数，即“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 翻译成现代语言如下： 第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。 3.4 Stein算法 Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。来研究一下最大公约数的性质，发现有 gcd( k_x,k_y ) = k_gcd( x,y ) 这么一个非常好的性质。试取 k=2，则有 gcd( 2x,2y ) = 2 * gcd( x,y )。很快联想到将两个偶数化小的方法。那么一奇一个偶以及两个奇数的情况如何化小呢？ 先来看看一奇一偶的情况： 设有2x和y两个数，其中y为奇数。因为y的所有约数都是奇数，所以 a = gcd( 2x,y ) 是奇数。根据2x是个偶数不难联想到，a应该是x的约数。我们来证明一下：(2x)%a=0，设2x=n_a，因为a是奇数，2x是偶数，则必有n是偶数。又因为 x=(n/2)*a，所以 x%a=0，即a是x的约数。因为a也是y的约数，所以a是x和y的公约数，有 gcd( 2x,y ) &lt;= gcd( x,y )。因为gcd( x,y )明显是2x和y的公约数，又有gcd( x,y ) &lt;= gcd( 2x,y )，所以 gcd( 2x,y ) = gcd( x,y )。至此，我们得出了一奇一偶时化小的方法。 再来看看两个奇数的情况：设有两个奇数x和y，不妨设x&gt;y，注意到x+y和x-y是两个偶数，则有 gcd( x+y,x-y ) = 2 * gcd( (x+y)/2,(x-y)/2 )，那么 gcd( x,y ) 与 gcd( x+y,x-y ) 以及 gcd( (x+y)/2,(x-y)/2 ) 之间是不是有某种联系呢？为了方便设 m=(x+y)/2 ，n=(x-y)/2 ，容易发现 m+n=x ，m-n=y 。设 a = gcd( m,n )，则 m%a=0,n%a=0 ，所以 (m+n)%a=0，(m-n)%a=0 ，即 x%a=0 ，y%a=0 ，所以a是x和y的公约数，有 gcd( m,n )&lt;= gcd(x,y)。再设 b = gcd( x,y )肯定为奇数，则 x%b=0,y%b=0 ，所以 (x+y)%b=0 ，(x-y)%b=0 ，又因为x+y和x-y都是偶数，跟前面一奇一偶时证明a是x的约数的方法相同，有 ((x+y)/2)%b=0,((x-y)/2)%b=0 ，即 m%b=0 ，n%b=0 ，所以b是m和n的公约数，有 gcd( x,y ) &lt;= gcd( m,n )。所以 gcd( x,y ) = gcd( m,n ) = gcd( (x+y)/2,(x-y)/2 )。 整理一下，对两个正整数 x&gt;y ： 1.均为偶数 gcd( x,y ) =2gcd( x/2,y/2 )； 2.均为奇数 gcd( x,y ) = gcd( (x+y)/2,(x-y)/2 )； 2.x奇y偶 gcd( x,y ) = gcd( x,y/2 )； 3.x偶y奇 gcd( x,y ) = gcd( x/2,y ) 或 gcd( x,y )=gcd( y,x/2 )； 现在已经有了递归式，还需要再找出一个退化情况。注意到 gcd( x,x ) = x ，就用这个。 4.算法实现 4.1辗转相除法 123456789101112131415161718192021222324int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125; 4.2穷举法（利用数学定义） 12345678910111213141516int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125; 4.3更相减损法 123456789101112131415161718192021222324252627int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125; 4.4 Stein算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;****4.5完整代码**** 在这里插入代码片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include&lt;stdio.h&gt;#include&lt;math.h&gt; //计算2的i次方的函数pow(2,i)的头文件#include&lt;time.h&gt; //计算程序运行时间和随机产生数的头文件#include&lt;stdlib.h&gt;int max1(int a,int b) //辗转相除法-------1.函数嵌套调用&#123; int temp; if(a&lt;b) //若存在a小于b的情况，则交换数值 &#123; temp=a; a=b; b=temp; &#125; while(b!=0) //直到b为0，通过赋值得到最大公约数为a的值 &#123; temp=a%b; //temp为余数 a=b; //将b的值赋给a b=temp; //将余数temp的值赋给b &#125; return a;&#125;int max2(int m,int n) //辗转相除法-------2.函数递归调用&#123; if(m%n==0) //若m和n取余后余数为0，则返回最大公约数n return n; else return max2(n,m%n); //返回到max2这个函数中，并给m,n赋值&#125;int max3(int x,int y) //3.穷举法&#123; int temp; if(x&lt;y) //把较小的值赋给temp temp=x; else temp=y; while(temp&gt;0) &#123; if(x%temp==0&amp;&amp;y%temp==0) //若大数取余小数余数为0，则结束循环，小数就是两个数的最大公约数 break; else temp--; //两个数中较小的数temp减一，直到找到最大公约数或temp为0为止 &#125; return temp;&#125;int max4(int c,int d) //4.更相减损法&#123; int i=0; int temp,x; while(c%2==0&amp;&amp;d%2==0) //检测c和d是否偶数，若是，则用2约简 &#123; c=c/2; d=d/2; i++; //计算c和d被2约了几次 &#125; if(c&lt;d) //始终令c&lt;d &#123; temp=c; c=d; d=temp; &#125; while(x) //当x不等于0时 &#123; x=c-d; //以较大的数减较小的数 c=(d&gt;x)?d:x; //把所得的差与较小的数比较 d=(d&lt;x)?d:x; if(x==d) //所得的减数和差相等 break; &#125; if(i) //当i不等于0 return (int)pow(2,i)*d; //pow(2,i)表示2的i次方，即2的i次方与d的乘积就是最大公约数&#125;int max5(unsigned int x,unsigned int y) //5.Stein算法&#123; int factor=0; int temp; if(x&lt;y) //赋值令x&gt;y &#123; temp=x; x=y; y=temp; &#125; if(0==y) &#123; return 0; &#125; while(x!=y) //当x和y不相等 &#123; if(x &amp; 0x1 ) //0x是十六进制的表示方式，这里表示十六进制的1,即x相与1，也就是判断x是奇数 &#123; if(y &amp; 0x1 ) //如果x,y都是奇数 &#123; y=(x-y)&gt;&gt;1; // (x-y)即两个奇数的差是偶数，&gt;&gt;表示右移/2 x-=y; &#125; else //如果x是奇数，y是偶数 &#123; y&gt;&gt;=1; &#125; &#125; else &#123; if(y &amp; 0x1 ) //如果x是偶数，y是奇数 &#123; x&gt;&gt;=1; if(x&lt;y) //始终令x&gt;y &#123; temp=x; x=y; y=temp; &#125; &#125; else //如果x,y是两个偶数 &#123; x&gt;&gt;=1; y&gt;&gt;=1; ++factor; &#125; &#125; &#125; return (x&lt;&lt;factor);&#125;void main()&#123; int x,y,p,i,n,N,m[1000]; int a,b,c,d,e; printf(&quot;*********************你有两种选择********************\n&quot;); printf(&quot;* 1.输入两个你想计算最大公约数的正整数并计算. *\n&quot;); printf(&quot;* 2.利用随机数测试最大公约数并计算程序运行时间. *\n&quot;); printf(&quot;*****************************************************\n&quot;); printf(&quot;请选择你想要进行的操作:\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n&lt;1||n&gt;2) &#123; printf(&quot;没有这个选项！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;n); &#125; if(n==1) &#123; printf(&quot;请输入两个正整数:\n&quot;); //用户自行输入两个数 scanf(&quot;%d%d&quot;,&amp;x,&amp;y); while(x&lt;0||y&lt;0||x==0||y==0) &#123; printf(&quot;请按要求输入正整数:\n&quot;); scanf(&quot;%d%d&quot;,&amp;x,&amp;y); &#125; printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); break; case 2: a=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); break; case 3: a=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); break; case 4: a=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); break; case 5: a=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); break; &#125; printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125;&#125;else if(n==2)&#123; clock_t start,finish; //计算随机函数 double duration; srand((unsigned)time(NULL)); printf(&quot;你想测试多少组数据？\n&quot;); scanf(&quot;%d&quot;,&amp;N); for(i=0;i&lt;N;i++) //随机取20个数（1-100） &#123; m[i]=rand()%100+1; printf(&quot;%d\t&quot;,m[i]); &#125; printf(&quot;\n&quot;); printf(&quot;在这里你有5种方法计算最大公约数:\n&quot;); //选择菜单 printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); printf(&quot; * 1.辗转相除法----函数嵌套调用. *\n&quot;); printf(&quot; * 2.辗转相除法----函数递归调用. *\n&quot;); printf(&quot; * 3.穷举法. *\n&quot;); printf(&quot; * 4.更相减损法. *\n&quot;); printf(&quot; * 5.Stein算法. *\n&quot;); printf(&quot; * * * * * * * * * * * * * * * * * * * * *\n&quot;); while(1) &#123; int j=0; printf(&quot;请输入你的选择(1-5):\n&quot;); scanf(&quot;%d&quot;,&amp;p); while(p&lt;1||p&gt;5) &#123; printf(&quot;输入错误！请重新输入:\n&quot;); scanf(&quot;%d&quot;,&amp;p); &#125; switch(p) &#123; case 1: start=clock(); //程序运行，开始计时 while(j&lt;20) &#123; x=m[j++]; y=m[j++]; a=max1(x,y); printf(&quot;你选择了辗转相除法中的函数嵌套调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,a); &#125; finish=clock(); //程序运行结束，结束计时 break; case 2: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; b=max2(x,y); printf(&quot;你选择了辗转相除法中的函数递归调用.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,b); &#125; finish=clock(); break; case 3: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; c=max3(x,y); printf(&quot;你选择了穷举法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,c); &#125; finish=clock(); break; case 4: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; d=max4(x,y); printf(&quot;你选择了更相减损法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,d); &#125; finish=clock(); break; case 5: start=clock(); while(j&lt;20) &#123; x=m[j++]; y=m[j++]; e=max5(x,y); printf(&quot;你选择了Stein算法.\n&quot;); printf(&quot;用这种方法计算的最大公约数为%d:\n&quot;,e); &#125; finish=clock(); break; &#125; duration=(double)(finish-start)/1000; ////计算时间差，由于计算机计算的是毫秒，转换成秒要除以1000 printf(&quot;这个方法的运行时间是%f秒\n&quot;,duration); &#125; &#125; &#125; 5.经验归纳 5.1遇到的问题 1.对随机函数不熟悉； 2.测试环节，对计算程序运行时间不熟悉； 3.在更相减损法的最后，用到了pow()函数，因没加头文件#include&lt;math.h&gt;而出错； 4.因知识储备不足，对最后一种方法（Stein算法）不理解。 PS：以上问题均已解决。 5.2心得体会 我觉得这四种方法里Stein算法我有点看不懂（可能是因为有&gt;&gt;运算符），还有随机数的生成和计算程序运行时间的函数都只是有一些印象，并不熟悉。（但是我可以查资料和问同学啊hhh） 主函数我改了很多次，就是想让界面更加美化一些，改完就发现程序出错了…其实就是赋值这么一个小细节，但就是发现不了（Emmmm），感觉自己还需要学很多东西，动手能力也要加强 总之就是~add oil!!!]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三天打鱼两天晒网]]></title>
    <url>%2F2019%2F03%2F01%2F%E2%80%9C%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91%E2%80%9D%2F</url>
    <content type="text"><![CDATA[♦ 题目： 三天打鱼两天晒网 ♦问题： 某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。 ♦ 要求： 基本要求：1.程序风格良好(使用自定义注释模板)，提供友好的输入输出。 提高要求：1.输入数据的正确性验证。 2.使用文件进行数据测试。如将日期 20100101 20111214 等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。 ♦程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void hanshu(int year,int month,int day)&#123; int sum=0; int a=0; int b=0; int c=0; int x[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; //平年各月份的天数 int y[12]=&#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; //闰年各月份的天数 for(int i=2010;i&lt;year;i++) //利用循环结构计算出在输入年份之前的那几年一共有几天 &#123; if((i%4==0&amp;&amp;i%100!=0)||i%400==0) //判断是否有闰年，有的话，一年为366天；否则一年为365天 a+=366; else a+=365; &#125; for(int j=0;j&lt;month-1;j++) //利用循环计算在输出月份之前的几个月一共有几天 &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) //判断该年是否为闰年，如果是，则用闰年数组；否则，用平年数组 b+=y[j]; else b+=x[j]; &#125; c=day; //用户输入的天数 sum=a+b+c; //将年，月，日所计算的天数相加，即为总天数 printf(&quot;距离2010年1月1日一共有%d天\n&quot;,sum); if(sum%5==1||sum%5==2||sum%5==3) //判断总天数取余后余数是否为1,2,3，如果是，输出“你在打鱼”；否则，输出“你在晒网” printf(&quot;你在打鱼~~~\n&quot;); else printf(&quot;你在晒网~~~\n&quot;);&#125;void main()&#123; int year,month,day,m,p,a,b,c; printf(&quot;***************计算你到底在打鱼还是晒网***************\n&quot;); printf(&quot;1.使用文件测试\n&quot;); printf(&quot;2.从键盘输入计算\n&quot;); printf(&quot;请输入你想选择的操作的序号：\n&quot;); scanf(&quot;%d&quot;,&amp;m); if(m==1) //选择1，进入文件测试环节 &#123; FILE *fp1; FILE *fp2; fp1=fopen(&quot;in.txt&quot;,&quot;r&quot;); fp2=fopen(&quot;out.txt&quot;,&quot;w&quot;); if(fp1==NULL) //判断文件in.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else if(fp2==NULL) //判断文件out.txt是否为空 &#123; printf(&quot;无法打开该文件，请按任意键退出！\n&quot;); exit(1); &#125; else fscanf(fp1,&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); //文件不为空，则用格式化读写函数fscanf()和fprintf()来读取文档in.txt和out.txt中的信息 hanshu(a,b,c); fprintf(fp2,&quot;%1d&quot;,&amp;p); fclose(fp1); //关闭文件 fclose(fp2); &#125; else if(m==2) &#123; printf(&quot;请输入年，月，日：(在2010年1月1日之后)\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); while(year&lt;2010||month&gt;12||day&gt;31) //判断输入年份是否小于2010年，如果是，则重新输入 &#123; printf(&quot;输入错误！请重新输入！\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); &#125; hanshu(year,month,day); &#125; else &#123; printf(&quot;你的输入有误！请重新输入：\n&quot;); scanf(&quot;%d&quot;,&amp;m); &#125;&#125; ♦ 心得： 第一次接触文件测试这样的问题，我刚开始还真无从下手还好问了班里比较厉害的同学，然后自己复习了C语言课本上的文件那一章，感觉遇到的问题挺多的，但是还好在我的不懈努力（不断问别人）下，最终是把文件测试这关通过了！！！ 刚开始敲得那个代码只有一个主函数，后来检查了一下觉得太简单了，然后运用了子函数，感觉自己对C语言还掌握的不是很清楚，还需要多多动手敲代码啊！！！（希望老师能看到我这个代码小白的认真） 我觉得这次作业让我学到了好多东西，也了解到了大企业的程序设计风格，我可以从现在开始学习他们的风格。 个人感觉还是对C语言感情更深一些，毕竟是接触计算机学到的第一门语言hhhh希望我能够在史晓楠老师（超级厉害）的教导下学到更多以前没接触过的东西！！！ 新的一年，新一学期，新的起点，FIGHTING]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
